<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jupyter的基本使用</title>
      <link href="/2020/06/06/jupyter%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/06/06/jupyter%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用anaconda安装python，不得不使用的就是jupyter notebook。jupyter是以网页形式打开，可以在网页中直接编写和运行代码，运行的结果也可以在代码块下方显示，并且可以使用markdown语言进行标记，可以远程搭建jupyter服务，使用电脑或者移动设备就能进行远程开发。除此之外还用众多一般IDE不具备且非常使用的功能。那么本篇博客便从一个新手角度讲述如何流畅使用jupyter。</p><h2 id="本文章中使用的软件版本"><a href="#本文章中使用的软件版本" class="headerlink" title="本文章中使用的软件版本"></a>本文章中使用的软件版本</h2><p>本文的环境使用<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">Miniconda3-4.7.12.1-Windows-x86_64</a>进行安装，linux平台操作类似，文章中尽量考虑linux平台差异带来的问题，若不全之处可使用搜索引擎解决问题。</p><ul><li>python 3.7.4        Ps:miniconda自带的python版本。</li><li>python 3.6.10      Ps:虚拟环境中的pythhon环境，考虑到较新的python版本需要tensorflow不稳定，因此选择相对较低的版本。，</li><li>jupyter-notebook 6.0.1(最新版)</li><li>jupyter core 4.6.3(最新版)</li><li>ipython 7.8.0(最新版)</li></ul><p>这里建议不使用最新的软件，可能有的包不支持最新的版本，也不要使用太老旧的版本，老版本可能不兼容新版本依赖库，需要查找合适的版本进行安装。后面的jupyter默认表示jupyter notebook。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="jupyter安装"><a href="#jupyter安装" class="headerlink" title="jupyter安装"></a>jupyter安装</h3><p>在windows平台下，如果使用python官网的程序进行安装，在成功构建python环境后，使用pip安装jupyter notebook库<code>pip install jupyter -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</code>，确认即可安装。这里使用国内的pip源(<a href="https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</a>)进行安装。如果使用miniconda安装python，可以使用<code>conda install jupyter</code>安装jupyter，如果安装速度过慢，推荐换源安装，参考文章<a href="/2020/06/04/anaconda初使用/" title="anaconda换源">anaconda换源</a>。如果是使用anaconda安装python，那么anaconda默认安装jupyter，不用再次安装jupyter。</p><h3 id="安装额外插件"><a href="#安装额外插件" class="headerlink" title="安装额外插件"></a>安装额外插件</h3><p>为了更加方便使用jupyter，建议安装插件nbconda和nbextensions</p><pre><code># conda安装nb_conda和nbextensionsconda install nb_condaconda install jupyter_contrib_nbextensions        # 或者使用pip install jupyter_contrib_nbextensions安装jupyter contrib nbextension install</code></pre><p>安装插件之后可能出现当前插件不兼容当前的软件版本，可以将”disable configuration for nbextensions without explicit compatibility (they may break your notebook environment, but can be useful to show for nbextension development)”这个选项去掉，即可使用。</p><h4 id="插件详解"><a href="#插件详解" class="headerlink" title="插件详解"></a>插件详解</h4><ul><li>(some) LaTeX environments for Jupyter，在单元内支持LaTex；</li><li>AutoSave Time，可以设置自动保存时间；</li><li>Code prettify，使用内核特定的代码美化单元格代码；</li><li>Collapsible Headings，可折叠标题；</li><li>Equation Auto Numbering，等式自动标号；</li><li>Exercise2，将一组单元格定义为”联系”,其他的单元格是答案,通过单击问题单元的小部件可以隐藏/显示解决方案；</li><li>Highlight selected word，高亮选词；</li><li>isort formatter，使用isort对python导入的文件排序；</li><li>Limit Output，对单元的输出进行限制，太长的直接隐藏；</li><li>Navigation-Hotkeys，使用额外的热键便于在notebook里边导航；</li><li>Notify，核心运行代码完成进行提醒；</li><li>ScrollDown，输出自动往下滚动；</li><li>Table of Contents，将单元中的标题集中显示；</li><li>Variable Inspector，显示定义的变量；</li><li>2to3 Converter，将python2转化为python3；</li><li>codefolding，折叠代码，包括函数、循环和条件等结构折叠；</li><li>ExecuteTime，显示代码开始运行时间和总共运行时间；</li><li>snippets menu，可以使用常用的一些编程功能，如numpy中新建一个矩阵；</li><li>Codefolding in Editor，代码折叠，与codefolding功能相似；</li><li>Freezen，冻结单元，不能编辑；</li><li>Hide input，隐藏输入单元；</li><li>Hinterland，语法提示；</li><li>runtools，有关运行的小工具；</li><li>code font size，可以调整代码字体大小；</li><li>Scratchpad，草稿单元，可以在其中做一些小测试；</li></ul><p>这里推荐使用Collapsible Headings、Table of Contents、codefolding、executetime、snippets menu、hinterland这几个插件。</p><h2 id="启动jupyter"><a href="#启动jupyter" class="headerlink" title="启动jupyter"></a>启动jupyter</h2><ul><li>终端环境里运行<code>jupyter notebook</code>即可运行jupyter。默认的路径为当前运行启动命令所在的文件夹。</li></ul><h2 id="配置jupyter"><a href="#配置jupyter" class="headerlink" title="配置jupyter"></a>配置jupyter</h2><h3 id="生成默认配置文件"><a href="#生成默认配置文件" class="headerlink" title="生成默认配置文件"></a>生成默认配置文件</h3><p>运行命令生成配置文件，windows下配置文件位置为C:\Users\当前用户\.jupyter\jupyter_notebook_config.py，Linux系统下配置文件位置为~/.jupyter/jupyter_notebook_config.py。</p><pre><code>jupyter notebook --generate-config</code></pre><p>注意修改其中配置项时，注意是否使用”#”符号对该行进行了注释，如果被注释掉了，需要去掉“#”符号才能使配置生效。</p><h3 id="设置jupyter默认路径"><a href="#设置jupyter默认路径" class="headerlink" title="设置jupyter默认路径"></a>设置jupyter默认路径</h3><p>每次启动都需要cd到想要工作目录，比较麻烦，可以在配置文件中设置默认工作路径，默认打开jupyter的工作目录。</p><pre><code>c.NotebookApp.notebook_dir = u&#39;默认工作路径&#39;</code></pre><h3 id="设置jupyter远程访问ip地址、端口号、密码、默认启动时不打开浏览器"><a href="#设置jupyter远程访问ip地址、端口号、密码、默认启动时不打开浏览器" class="headerlink" title="设置jupyter远程访问ip地址、端口号、密码、默认启动时不打开浏览器"></a>设置jupyter远程访问ip地址、端口号、密码、默认启动时不打开浏览器</h3><ol><li><p>设置IP地址，直接在启动jupyter命令中添加<code>--ip xxx.xxx.xxx.xxx</code>参数，即<code>jupyter notebook --ip 127.0.0.1</code>可使用127.0.0.1访问服务。或者修改配置文件，设定启动时的ip地址，当然该ip设置也可以设置为域名。注意有”#”号要去掉”#”号才能使修改生效。</p><pre><code> c.NotebookApp.ip = &#39;127.0.0.1&#39;</code></pre></li></ol><ol start="2"><li><p>设定端口号，直接在启动jupyter命令中添加<code>--port n</code>参数，即<code>jupyter notebook --port 8890</code>可使用8890访问，默认为8888端口。或者修改配置文件，设置默认启动端口。注意有”#”号要去掉”#”号才能使修改生效。</p><pre><code> c.NotebookApp.port = 8991</code></pre></li><li><p>设定密码，这里需要借助jupyter的工具进行对密码进行加密形成密文。使用<code>jupyter notebook password</code>输入两次密码，即可生成密文，在windows中存储于C:\Users\用户\.jupyter\jupyter_notebook_config.json中。Linux中放置在~/.jupyter\jupyter_notebook_config.json中，文件内容如下:</p><pre><code>{  &quot;NotebookApp&quot;: {    &quot;password&quot;: &quot;sha1:32c1e756f3df:43eaefea21f9e25c9f556e1c22cf3da565e9d165&quot;  }}</code></pre><p>上面的方法设置之后不用再到配置文件中修改，还有另外一种修改密码的方式，在虚拟环境里使用<code>ipython</code>，进入交互界面，输入<code>from notebook.auth import passwd</code>回车之后输入<code>passwd()</code>回车，输入两次密码并回车，就会输出一串sha1开头的字符串将sha1开头双引号内全部字符串全部拷贝，填入配置文件中对应位置:</p><pre><code>c.NotebookApp.password = u&#39;sha1:fbf4296e978d:3d4c173f027c8e5b85655177856c77d1f1ea44a6&#39;</code></pre><p>需要注意，jupyter_notebook_config.json设置密码的优先级高于配置文件，所以使用第一种方法设置密码之后，配置文件中就不要设置密码了(应该使用”#”符号注释掉)，避免报错。如果在配置文件设置密码，一定要将jupyter_notebook_config.json文件删除之后再修改配置文件，避免更改密码失败。</p></li><li><p>设置启动jupyter时默认不打开浏览器</p><p>在启动代码中添加<code>--no-browser</code>或者修改配置文件。</p><pre><code>c.NotebookApp.open_browser = False</code></pre></li></ol><h3 id="设置inline显示"><a href="#设置inline显示" class="headerlink" title="设置inline显示"></a>设置inline显示</h3><p>这个设置主要是针对matplotlib之类的需要绘图的程序，使图显示在网页上。</p><pre><code>c.NotebookApp.pylab = &quot;inline&quot;</code></pre><p>在最新的jupyter上已废弃这样的设置方式，采用<code>%pylab inline</code>或者<code>%matplotlib inline</code>进行设置</p><h2 id="jupyter简单使用"><a href="#jupyter简单使用" class="headerlink" title="jupyter简单使用"></a>jupyter简单使用</h2><h3 id="新建ipynb"><a href="#新建ipynb" class="headerlink" title="新建ipynb"></a>新建ipynb</h3><p>进入到存储文件夹之后，New-&gt;Python3即可新建ipynb文件。</p><h3 id="导入代码"><a href="#导入代码" class="headerlink" title="导入代码"></a>导入代码</h3><p>在jupyter中代码都是依托于ipynb，如果之前的代码存在于py文件中，那么需要将代码导入ipynb文件中。</p><pre><code>%load py文件路径</code></pre><p>或者直接运行py文件</p><pre><code>%run py文件路径</code></pre><h3 id="新建python环境"><a href="#新建python环境" class="headerlink" title="新建python环境"></a>新建python环境</h3><ul><li>运行命令<code>conda create -n 环境名 python=3</code>新建环境，关于python环境管理，参考文章<a href="/2020/06/04/anaconda初使用/" title="python环境管理">python环境管理</a>。</li><li>激活环境<code>conda activate 环境名</code>。</li><li>在虚拟环境内安装nb_conda和ipykernel，命令<code>conda install nb_conda ipykernel</code>。</li><li>将虚拟环境注册到jupyter中，命令<code>python -m ipykernel install --user --name 环境名 --display-name jupyter中显示名(可修改)</code>，在windows下使用这条命令注册之后在jupyter中无法使用环境，但是默认会设置成”Python [conda env:环境名]”，这个环境可以直接使用；在Linux系统下则必须要进行注册，否则jupyter不会显示该虚拟环境。</li><li>启动jupyter即可看到新添加的python环境。</li></ul><h3 id="jupyter快捷键"><a href="#jupyter快捷键" class="headerlink" title="jupyter快捷键"></a>jupyter快捷键</h3><p>jupyter有两种模式，命令模式和编辑模式。进入命令模式的方式：按Esc键即可进入命令模式，单元边框线为蓝色；进入编辑模式的方式：左键双击单元的文本框即可进入编辑模式，单元边框线为绿色。</p><h4 id="命令模式下"><a href="#命令模式下" class="headerlink" title="命令模式下"></a>命令模式下</h4><ul><li>Enter：进入编辑模式；</li><li>Shift-Enter：运行本单元，选中下一单元，没有则新建单元；</li><li>Ctrl-Enter：运行本单元；</li><li>Alt-Enter：运行本单元，下新建一个单元；</li><li>Y：单元转代码状态；</li><li>M：单元转入markdown状态；</li><li>R：单元转入raw状态；</li><li>1：设定为1级标题；</li><li>2：设定为2级标题；</li><li>3：设定为3级标题；</li><li>4：设定为4级标题；</li><li>5：设定为5级标题；</li><li>6：设定为6级标题；</li><li>Up：选中上方单元；</li><li>K：选中上方单元；</li><li>Shift-K：扩大选中上方单元；</li><li>Down：选中下方单元；</li><li>J：选中下方单元；</li><li>Shift-J：扩大选中下方单元；</li><li>A：在上方插入新单元；</li><li>B：在下方插入新单元；</li><li>X：剪切选择的代码块；</li><li>C：复制选择的代码块；</li><li>Shift-V：粘贴到上面；</li><li>V：粘贴到下面；</li><li>Z：撤销删除；</li><li>D·D（按两次D）：删除所选中单元；</li><li>Shift-M：合并选中单元格，如果只有一个单元格被选中，合并下一个单元；</li><li>Ctrl-S：保存并检查；</li><li>S：保存并检查；</li><li>L：切换是否显示行号；</li><li>O：选择单元格输出；</li><li>Shift-O：切换选中单元的输出滚动；</li><li>H：显示快捷键；</li><li>I·I（按两次I）：中断服务；</li><li>Esc：关闭页面；</li><li>Q：关闭页面</li><li>Shift-L：在所有单元格中切换行号，并保持设置；</li><li>Shift-空格：向上滚动；</li><li>空格：向下滚动；</li></ul><h4 id="编辑模式下"><a href="#编辑模式下" class="headerlink" title="编辑模式下"></a>编辑模式下</h4><ul><li>Tab：代码完成或缩进；</li><li>Shift-Tab：工具提示；</li><li>Crtl-]：缩进；</li><li>Ctrl-[：取消缩进；</li><li>Ctrl-A：全选；</li><li>Ctrl-Z：撤销；</li><li>Ctrl-/：注释或取消注释；</li><li>Ctrl-D：删除整行；</li><li>Ctrl-U：撤销选择；</li><li>Insert：切换重写标志；</li><li>Ctrl-Home：转跳到单元格起始处；</li><li>Ctrl-上：转跳到单元格起始处；</li><li>Ctrl-End：转跳到单元格最后；</li><li>Ctrl-下：转跳到单元格最后；</li><li>Ctrl-左：转跳到单词左边；</li><li>Ctrl-右：转跳到单词右边；</li><li>Ctrl-删除：删除前面的单词；</li><li>Ctrl-del：删除后面的单词；</li><li>Ctrl-Y：重做；</li><li>Alt-U：重新选择；</li><li>Ctrl-B：打开草稿面板（安装响应的插件Scratchpad）</li><li>Ctrl-Enter：运行当前单元；</li><li>Shift-Enter：运行当前单元，选中下一单元，没有则新建；</li><li>Ctrl-M：进入命令行模式；</li><li>Ctrl-Shift-F：打开命令配置；</li><li>Ctrl-Shift-P：打开命令配置；</li><li>Esc：进入命令模式；</li><li>Alt-Enter：运行单元并下插入新单元；</li><li>Ctrl-Shift-Minus：在鼠标处分割代码</li><li>Ctrl-S：保存并检查；</li><li>上：光标上移或者上一单元；</li><li>下：光标下移或者下一单元；</li></ul><h3 id="jupyter的魔术命令"><a href="#jupyter的魔术命令" class="headerlink" title="jupyter的魔术命令"></a>jupyter的魔术命令</h3><h4 id="行魔术命令"><a href="#行魔术命令" class="headerlink" title="行魔术命令"></a>行魔术命令</h4><table><thead><tr><th align="center">魔术命令</th><th align="center">含义</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">!</td><td align="center">执行命令行命令</td><td align="center"><code>!jupyter kernelspec list</code></td></tr><tr><td align="center">?</td><td align="center">说明手册，可能会有用例</td><td align="center"><code>?%pwd</code></td></tr><tr><td align="center">%lsmagic</td><td align="center">显示全部可用的魔术指令</td><td align="center"><code>%lsmagic</code></td></tr><tr><td align="center">%matplotlib inline</td><td align="center">图片嵌入窗口，而不是单独显示</td><td align="center"><code>%matplotlib inline</code></td></tr><tr><td align="center">%time</td><td align="center">测试当前行代码运行时间</td><td align="center"><code>%%time</code></td></tr><tr><td align="center">%time</td><td align="center">当前行运行时间</td><td align="center"><code>%time a = list(i for i in range(100000))</code></td></tr><tr><td align="center">%timeit</td><td align="center">使用python的timeit库测试当前代码行运行100000次所花时间</td><td align="center"><code>%timeit b =  list(i for i in range(100000))</code></td></tr><tr><td align="center">%prun</td><td align="center">每个函数消耗时间</td><td align="center"><code>%prun time.sleep(1)</code></td></tr><tr><td align="center">%run</td><td align="center">运行一个py文件</td><td align="center"><code>%run test1.py</code></td></tr><tr><td align="center">%pwd</td><td align="center">查看当前路径</td><td align="center"><code>%pwd</code></td></tr><tr><td align="center">%cd</td><td align="center">更改当前路径</td><td align="center"><code>%cd .</code></td></tr><tr><td align="center">%who</td><td align="center">列举所有全局变量，+类型可过滤</td><td align="center"><code>%who int</code></td></tr><tr><td align="center">%whos</td><td align="center">列举所有变量、类型和信息</td><td align="center"><code>%whos</code></td></tr><tr><td align="center">%who_ls</td><td align="center">使用列表列出所有变量列表</td><td align="center"><code>%who_ls</code></td></tr><tr><td align="center">%reset</td><td align="center">清除所有变量</td><td align="center"><code>%reset</code></td></tr><tr><td align="center">%load</td><td align="center">加载一个文件的内容</td><td align="center"><code>%load test.py</code></td></tr><tr><td align="center">%load_ext</td><td align="center">导入外部模块</td><td align="center"><code>%load_ext autoreload</code></td></tr><tr><td align="center">%reload_ext</td><td align="center">重新导入外部模块</td><td align="center"><code>%reload_ext autoreload</code></td></tr><tr><td align="center">%unload_ext</td><td align="center">卸载ipython拓展模块</td><td align="center"><code>%unload_ext autoreload</code></td></tr><tr><td align="center">%system</td><td align="center">快速检查当前目录和类似的东西</td><td align="center"><code>%system</code></td></tr><tr><td align="center">%automagic</td><td align="center">是否带%，off(0)/on(1)</td><td align="center"><code>%automagic on</code></td></tr><tr><td align="center">%debug</td><td align="center">调试</td><td align="center"><code>%debug</code></td></tr><tr><td align="center">%quickref</td><td align="center">调出快速参考</td><td align="center"><code>%quickref</code></td></tr><tr><td align="center">%magic</td><td align="center">显示魔术命令帮助</td><td align="center"><code>%magic</code></td></tr><tr><td align="center">%dhist</td><td align="center">打印历史访问记录</td><td align="center"><code>%dhist</code></td></tr><tr><td align="center">%hist</td><td align="center">打印所有历史记录，包括魔术命令、指令等等</td><td align="center"><code>%hist</code></td></tr><tr><td align="center">%pdb</td><td align="center">控制交互式调试器的自动调用</td><td align="center"><code>%pdb</code></td></tr><tr><td align="center">%page</td><td align="center">用一页进行打印</td><td align="center"><code>%page</code></td></tr><tr><td align="center">%xdel</td><td align="center">删除、清除一切引用</td><td align="center"><code>%xdel a</code></td></tr><tr><td align="center">%connect_info</td><td align="center">查看连接信息</td><td align="center"></td></tr><tr><td align="center">%echo</td><td align="center">向标准输出中打印字符串</td><td align="center"></td></tr><tr><td align="center">%env</td><td align="center">获取环境变量，并且可以进行设置</td><td align="center"><code>%env OS=&quot;123&quot;</code></td></tr><tr><td align="center">%less、%more</td><td align="center">显示一个文件内容，文件名结尾为.py会语法高亮显示</td><td align="center"><code>%less test.py</code></td></tr><tr><td align="center">%pinfo、%pinfo2</td><td align="center">查看一个object的详细信息</td><td align="center"><code>%pinfo a</code></td></tr><tr><td align="center">%pip</td><td align="center">调用pip,可以通过这个指令安装或者查看包</td><td align="center"><code>%pip install numpy</code>、<code>%pip list</code></td></tr><tr><td align="center">%conda</td><td align="center">调用conda（windows使用会有问题，linux使用正常），安装包之类的操作</td><td align="center"><code>%conda install numpy</code></td></tr><tr><td align="center">%popd、%pushd</td><td align="center">通过入栈出栈改变当前工作目录</td><td align="center"><code>%pushd ..</code>、<code>%popd</code></td></tr><tr><td align="center">%pprint</td><td align="center">改变当前工作目录是否打印出来</td><td align="center"><code>%pprint</code></td></tr><tr><td align="center">%precision</td><td align="center">设置当前打印浮点的精度</td><td align="center"><code>%precision 3</code>保留3位小数；<code>%precision</code>恢复默认设置</td></tr><tr><td align="center">%psearch</td><td align="center">在当前命名空间使用通配符搜索object</td><td align="center"><code>%psearch t*</code></td></tr><tr><td align="center">%pycat</td><td align="center">使用分页语法高亮打印文件</td><td align="center"><code>%pycat test.py</code></td></tr><tr><td align="center">%pylab</td><td align="center">与numpy和matplotlib交互</td><td align="center"><code>%pylab inline</code></td></tr><tr><td align="center">%save</td><td align="center">保存几行或者一个宏到文件中</td><td align="center"><code>%save test2.py 2</code></td></tr><tr><td align="center">%sc</td><td align="center">命令捕获-运行shell命令并捕获输出</td><td align="center"><code>%sc -l print1=echo 123</code></td></tr><tr><td align="center">%store</td><td align="center">轻量级持久性变量</td><td align="center"><code>%store a</code></td></tr><tr><td align="center">%sx</td><td align="center">命令执行</td><td align="center"><code>%sx echo 123</code></td></tr><tr><td align="center">%tb</td><td align="center">打印最后的traceback</td><td align="center"><code>%tb</code></td></tr><tr><td align="center">%alias</td><td align="center">别名</td><td align="center"><code>%alias ppp echo 123</code>调用使用<code>%ppp</code></td></tr><tr><td align="center">%unalias</td><td align="center">取消别名</td><td align="center"><code>%unalias ppp</code></td></tr><tr><td align="center">%macro</td><td align="center">宏</td><td align="center"><code>%macro ppp 3-5</code></td></tr><tr><td align="center">%xmode</td><td align="center">异常处理模式，模式有三种Plain, Context, Verbose, and Minima，默认为Context</td><td align="center"><code>%xmode</code></td></tr></tbody></table><p>注意：设置<code>autoreload 1</code>时需要使用<code>%aimport</code>指定需要重新载入的库，如<code>aimport numpy</code>；如果设置<code>autoreload 2</code>则不需要使用<code>%aimport</code>进行指定。</p><h4 id="单元魔术命令"><a href="#单元魔术命令" class="headerlink" title="单元魔术命令"></a>单元魔术命令</h4><table><thead><tr><th align="center">魔术命令</th><th align="center">含义</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">%%!</td><td align="center">这个单元都是命令行执行指令</td><td align="center"><img src="/2020/06/06/jupyter的基本使用/img1.webp" alt></td></tr><tr><td align="center">%%html</td><td align="center">注明该单元格内为html代码</td><td align="center"><img src="/2020/06/06/jupyter的基本使用/img2.webp" alt></td></tr><tr><td align="center">%%svg</td><td align="center">注明当前单元格内为svg代码</td><td align="center"><img src="/2020/06/06/jupyter的基本使用/img3.webp" alt></td></tr><tr><td align="center">%%cmd、%%bash</td><td align="center">windows下使用%%cmd，linux下使用%%bash，可执行命令行代码</td><td align="center"><img src="/2020/06/06/jupyter的基本使用/img4.webp" alt></td></tr><tr><td align="center">%%debug</td><td align="center">调试整个单元格</td><td align="center"><img src="/2020/06/06/jupyter的基本使用/img5.webp" alt></td></tr><tr><td align="center">%%file、%%writefile</td><td align="center">保存整个单元格内容到文件</td><td align="center"><code>%%writefile 文件名</code></td></tr><tr><td align="center">%%javascript、%%js、%%latex、%%markdown、%%perl、%%pypy、%%python、%%python2、%%python3、%%ruby、%%sh</td><td align="center">指定语言格式</td><td align="center"></td></tr><tr><td align="center">%%sx</td><td align="center">与%sx功能相同</td><td align="center"></td></tr><tr><td align="center">%%time</td><td align="center">整个cell运行所花费的时间</td><td align="center"></td></tr><tr><td align="center">%%timeit</td><td align="center">功能与%timeit相同</td><td align="center"></td></tr></tbody></table><h2 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h2><blockquote><p><a href="https://blog.csdn.net/Detective_0/article/details/106166368" target="_blank" rel="noopener">https://blog.csdn.net/Detective_0/article/details/106166368</a></p><p><a href="https://segmentfault.com/a/1190000010758722" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010758722</a></p><p><a href="https://www.jianshu.com/p/9768a61e1bb7" target="_blank" rel="noopener">https://www.jianshu.com/p/9768a61e1bb7</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见镜像源列表</title>
      <link href="/2020/06/05/%E5%B8%B8%E8%A7%81%E9%95%9C%E5%83%8F%E6%BA%90%E5%88%97%E8%A1%A8/"/>
      <url>/2020/06/05/%E5%B8%B8%E8%A7%81%E9%95%9C%E5%83%8F%E6%BA%90%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时使用开源软件中会遇到使用国外的网站资源，例如python的默认pip源的服务器在国外，网络质量与网络速度不如人意。如果能将pip源服务同步到国内，需要使用到pip源服务时，直接使用国内的pip源，可以有效改善使用效果。同样的情况在很多软件中存在，那么国内就会存在很多镜像网站提供许许多多的镜像服务。本篇博客中对常见的镜像网站进行收集。</p><h2 id="国内镜像网站列表"><a href="#国内镜像网站列表" class="headerlink" title="国内镜像网站列表"></a>国内镜像网站列表</h2><ul><li>网易开源镜像站:<a href="http://mirrors.163.com" target="_blank" rel="noopener">http://mirrors.163.com</a></li><li>阿里云镜像站:<a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com/</a></li><li>中国科学技术阿雪开源镜像站:<a href="http://debian.ustc.edu.cn/" target="_blank" rel="noopener">http://debian.ustc.edu.cn/</a></li><li>中国科学技术大学镜像站:<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></li><li>中国交通大学开源镜像站:<a href="http://mirror.bjtu.edu.cn/cn/" target="_blank" rel="noopener">http://mirror.bjtu.edu.cn/cn/</a></li><li>中国理工大学开源软件镜像服务:<a href="http://mirror.bit.edu.cn/web/" target="_blank" rel="noopener">http://mirror.bit.edu.cn/web/</a></li><li>上海交通大学镜像站:<a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/</a></li><li>清华大学镜像站:<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></li><li>浙江大学镜像站:<a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></li><li>重庆大学镜像站:<a href="http://mirrors.cqu.edu.cn/" target="_blank" rel="noopener">http://mirrors.cqu.edu.cn/</a></li><li>大连理工镜像站:<a href="http://mirror.dlut.edu.cn/" target="_blank" rel="noopener">http://mirror.dlut.edu.cn/</a></li><li>CN99镜像站:<a href="http://mirrors.cn99.com/" target="_blank" rel="noopener">http://mirrors.cn99.com/</a></li><li><del>东北大学开源镜像站:<a href="http://mirror.neu.edu.cn/" target="_blank" rel="noopener">http://mirror.neu.edu.cn/</a></del></li><li>厦门大学开源软件:<a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="noopener">http://mirrors.xmu.edu.cn/</a></li><li>兰大开源社区镜像站:<a href="http://mirror.lzu.edu.cn/" target="_blank" rel="noopener">http://mirror.lzu.edu.cn/</a></li><li>西电开源社区软件源:<a href="http://linux.xidian.edu.cn/" target="_blank" rel="noopener">http://linux.xidian.edu.cn/</a></li><li><del>哈尔冰工业大学开源镜像站:<a href="http://run.hit.edu.cn/html/" target="_blank" rel="noopener">http://run.hit.edu.cn/html/</a></del></li><li><del>电子科技大学开源镜像服务:<a href="http://mirrors.stuhome.net/" target="_blank" rel="noopener">http://mirrors.stuhome.net/</a></del></li><li>东软信息学院开源镜像站:<a href="http://mirrors.neusoft.edu.cn/" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/</a></li><li>搜狐开源镜像站:<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a></li><li><del>淘宝网开源镜像站:<a href="http://ruby.taobao.org" target="_blank" rel="noopener">http://ruby.taobao.org</a></del></li></ul><h2 id="国外镜像网站列表"><a href="#国外镜像网站列表" class="headerlink" title="国外镜像网站列表"></a>国外镜像网站列表</h2><ul><li>北陆先端科学技术大学院大学JAIST开源镜像站:<a href="http://ftp.jaist.ac.jp/pub/" target="_blank" rel="noopener">http://ftp.jaist.ac.jp/pub/</a></li><li>卡内基梅隆大学开源镜像站:<a href="http://www.club.cc.cmu.edu/pub/" target="_blank" rel="noopener">http://www.club.cc.cmu.edu/pub/</a></li><li>麻省理工学院开源镜像站:<a href="http://mirrors.mit.edu/" target="_blank" rel="noopener">http://mirrors.mit.edu/</a></li><li>哥伦比亚大学开源镜像站:<a href="http://mirror.cc.columbia.edu/" target="_blank" rel="noopener">http://mirror.cc.columbia.edu/</a></li><li>俄勒冈州立大学开源镜像站:<a href="http://ftp.osuosl.org/pub/" target="_blank" rel="noopener">http://ftp.osuosl.org/pub/</a></li><li><del>伊利诺伊大学厄巴纳-香槟分校开源镜像站:<a href="http://cosmos.cites.illinois.edu/" target="_blank" rel="noopener">http://cosmos.cites.illinois.edu/</a></del></li><li>杜克大学开源镜像站:<a href="http://archive.linux.duke.edu/" target="_blank" rel="noopener">http://archive.linux.duke.edu/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda初使用</title>
      <link href="/2020/06/04/anaconda%E5%88%9D%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/06/04/anaconda%E5%88%9D%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没有更新博客，上一篇博客还是数个月前写的，那么这么长的时间都在做什么呢？2020年受到新冠的影响，许许多多的工作都被延迟了，整天只能呆在家里，尽量不给大家添麻烦。虽然身体被拘束在家中但是头脑里总是想做点什么，想起了大学期间上操作系统这门课时，我们做实验使用的是老师自制的类Linux操作系统（源码地址：<a href="https://github.com/hongmingjian/epos" target="_blank" rel="noopener">https://github.com/hongmingjian/epos</a>），心血来潮想要自己写一个操作系统，一方面是为了打发时间，另一方面则是为了熟悉操作系统的运行原理。截至目前为止，操作系统完成了一部分，源码地址:<a href="https://github.com/qzt8315/QXOS" target="_blank" rel="noopener">https://github.com/qzt8315/QXOS</a>。好了，我们回到正题上，六月份开始到支教结束这段时间，准备暂时缓一缓自制操作系统的工作，准备好好学习一下tensorflow，为之后入学研究生，开始学习深度学习准备。电脑上使用的最好方式就是使用python中的tensorflow库。之前一直都在使用anaconda，因为可以使用conda（包管理器）安装新库，并且集成了常用的科学计算的库，但是很少去学习anaconda对python环境(和virtualenv类似的功能)和包的管理。那么这篇博客中便介绍anaconda的一些使用技巧。</p><h2 id="安装anaconda"><a href="#安装anaconda" class="headerlink" title="安装anaconda"></a>安装anaconda</h2><p>这次使用window10操作系统，安装的版本是:<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2019.10-Linux-x86_64.sh" target="_blank" rel="noopener">Anaconda3-2019.10-Windows-x86_64</a>，这里由于国内网络的环境，使用的是清华镜像网站链接下载。(也可以安装anaconda的mini安装包，地址<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-4.5.1-Windows-x86_64.exe" target="_blank" rel="noopener">Miniconda3-4.5.1-Windows-x86_64</a>，只有几十兆大小，不会自带安装众多的包)</p><p>安装过程比较简单，除了安装路径和勾选将anaconda添加加到PATH环境变量(PS:强烈建议添加，避免后面手动添加)需要根据自己的需求选择外，其他默认安装即可。</p><h3 id="anaconda添加到环境变量"><a href="#anaconda添加到环境变量" class="headerlink" title="anaconda添加到环境变量"></a>anaconda添加到环境变量</h3><p>将安装路径、安装路径\Scripts、安装路径\Library\mingw-w64\bin和安装路径\Library\bin添加到环境变量。</p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="更改镜像地址"><a href="#更改镜像地址" class="headerlink" title="更改镜像地址"></a>更改镜像地址</h3><p>一般安装的Anaconda默认的源地址在国外，安装时会比较慢，可以修改为国内镜像源地址加快下载安装速度。一般国内源使用清华大学的镜像。在Windows上修改C:\Users\当前用户名\.condarc（Linux或者Mac修改~/.condarc）：</p><pre><code>ssl_verify: truechannels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  - defaultsshow_channel_urls: true</code></pre><p>也可以使用conda配置源</p><pre><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config --set show_channel_urls yes</code></pre><p>如果修改源之后conda下载速度还是比较慢，则可以修改pip源，使用pip安装包，Windows下修改C:\Users\当前用户名\pip\pip.ini（MaxOS或者Linux修改~/.pip.conf）:</p><pre><code>[global]trust-host = pypi.douban.comindex-url  = http://pypi.douban.com/simple</code></pre><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>使用conda安装库与pip类似，使用命令：</p><pre><code># 搜索包conda search 包名# 安装包conda install 包名# 安装指定包conda install 包名=1.2(版本)# 安装多个包conda install 包名1 包名2 ...</code></pre><h3 id="查看包"><a href="#查看包" class="headerlink" title="查看包"></a>查看包</h3><p>conda查看包列表:</p><pre><code>conda list# 查看特定环境的所有的包conda list -n 环境名</code></pre><h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><p>anaconda包管理中，本身可以看作是一个包，python环境可以看作一个包，anaconda也可以看作一个包，因此在conda中除了支持普通的更新第三方包以外，还支持conda、python环境和anaconda更新。</p><pre><code># 更新包conda update 包名# 更新pythonconda update python# 更新anacondaconda update anaconda# 更新condaconda update conda# 防止包更新conda update 包名 --no-pin</code></pre><h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><p>使用conda卸载包和使用pip卸载包（uninstall）有区别：</p><pre><code># 卸载当前环境中的包conda remove 包名# 卸载特定环境中的包conda remove -n 环境名 包名# 删除多个包conda remove 包名1 包名2 ...</code></pre><h2 id="python环境管理"><a href="#python环境管理" class="headerlink" title="python环境管理"></a>python环境管理</h2><p>之所以有环境管理是因为，可能会使用不同版本的python、不同版本的库等等的需求，那么相对独立的python运行环境就比较重要。</p><h3 id="控制环境"><a href="#控制环境" class="headerlink" title="控制环境"></a>控制环境</h3><h4 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h4><p>使用conda创建环境，类似于virtualenv的功能:</p><pre><code># 创建特定名字的环境conda create -n 环境名# 使用特定版本的python创建环境conda create -n 环境名 python=版本(1.2)# 使用特定包创建环境conda create -n 环境名 包名# 使用环境配置文件(.yaml)创建环境conda env create -f 环境配置文件.yaml</code></pre><p>环境配置文件可以通过导出生成</p><pre><code># 激活环境conda activate 需要导出的环境名# 导出conda env export &gt; 环境配置文件.yaml</code></pre><h4 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h4><pre><code>conda activate 环境名</code></pre><h4 id="停用环境"><a href="#停用环境" class="headerlink" title="停用环境"></a>停用环境</h4><pre><code>conda deactivate 环境名</code></pre><h4 id="查看当前环境"><a href="#查看当前环境" class="headerlink" title="查看当前环境"></a>查看当前环境</h4><pre><code>conda info -envs</code></pre><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><pre><code>conda remove --n 环境名 --all</code></pre><h4 id="构建相同的环境"><a href="#构建相同的环境" class="headerlink" title="构建相同的环境"></a>构建相同的环境</h4><h5 id="激活需要导出配置文件的环境"><a href="#激活需要导出配置文件的环境" class="headerlink" title="激活需要导出配置文件的环境"></a>激活需要导出配置文件的环境</h5><pre><code>conda list --explicit &gt; 文件.txt</code></pre><h5 id="在同系统的不同机器执行"><a href="#在同系统的不同机器执行" class="headerlink" title="在同系统的不同机器执行"></a>在同系统的不同机器执行</h5><pre><code>conda create --name 环境名 -f 文件.txt</code></pre><h4 id="克隆环境-同一机器"><a href="#克隆环境-同一机器" class="headerlink" title="克隆环境(同一机器)"></a>克隆环境(同一机器)</h4><pre><code>conda create --name 环境名 --clone 被克隆环境名</code></pre><h4 id="渠道管理"><a href="#渠道管理" class="headerlink" title="渠道管理"></a>渠道管理</h4><h5 id="添加到顶部最高优先级"><a href="#添加到顶部最高优先级" class="headerlink" title="添加到顶部最高优先级"></a>添加到顶部最高优先级</h5><pre><code>conda config --add channels 新渠道# 或者conda config --prepend 新渠道</code></pre><h5 id="添加到底部最低优先级"><a href="#添加到底部最低优先级" class="headerlink" title="添加到底部最低优先级"></a>添加到底部最低优先级</h5><pre><code>conda config --append channels 新渠道</code></pre><h5 id="开启搜索时显示通道地址"><a href="#开启搜索时显示通道地址" class="headerlink" title="开启搜索时显示通道地址"></a>开启搜索时显示通道地址</h5><pre><code>conda config --set show_channel_urls yes</code></pre><h5 id="删除源"><a href="#删除源" class="headerlink" title="删除源"></a>删除源</h5><pre><code># 删除所有新添加源恢复默认源conda config --remove-key channels</code></pre><h5 id="常见的国内源"><a href="#常见的国内源" class="headerlink" title="常见的国内源"></a>常见的国内源</h5><pre><code># 清华源https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forgehttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/# 中科大源https://mirrors.ustc.edu.cn/anaconda/pkgs/main/https://mirrors.ustc.edu.cn/anaconda/pkgs/free/https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/# 上交源https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/main/https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/free/https://mirrors.sjtug.sjtu.edu.cn/anaconda/cloud/conda-forge/</code></pre><h4 id="设置pip源"><a href="#设置pip源" class="headerlink" title="设置pip源"></a>设置pip源</h4><p>临时设置pip源</p><pre><code>pip install 库名 -i pip源网址</code></pre><p>永久设置pip源，修改C:\Users\用户\pip\pip.ini配置文件(不存在时，可以手动创建配置文件)，在linux下配置文件为~/.pip/pip.conf。</p><pre><code>[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simple/trusted-host = pypi.tuna.tsinghua.edu.cn</code></pre><h5 id="其他pip源"><a href="#其他pip源" class="headerlink" title="其他pip源"></a>其他pip源</h5><ul><li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>豆瓣 <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li><li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>华中理工大学 <a href="http://pypi.hustunique.com/simple/" target="_blank" rel="noopener">http://pypi.hustunique.com/simple/</a></li><li>山东理工大学 <a href="http://pypi.sdutlinux.org/simple/" target="_blank" rel="noopener">http://pypi.sdutlinux.org/simple/</a></li></ul><p>常用的镜像网站:<a href="/2020/06/05/常见镜像源列表/" title="国内镜像网站列表">国内镜像网站列表</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> anaconda </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ld链接脚本</title>
      <link href="/2020/05/01/ld%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/05/01/ld%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ld </tag>
            
            <tag> GNU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序管理和SELinux</title>
      <link href="/2020/02/25/%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E5%92%8CSELinux/"/>
      <url>/2020/02/25/%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E5%92%8CSELinux/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux属于多人多工系统，在其上运行许多程序，虽说有操作系统进行调度，但是有时也需要人工去管理。系统管理员此外也会对系统的的权限进行管理，但是由于系统管理员的管理方式不同，有的会直接给予所有权限，导致系统具有严重的安全隐患，这是也需要SELinux帮助保护系统的安全。</p><h2 id="程序管理"><a href="#程序管理" class="headerlink" title="程序管理"></a>程序管理</h2><h3 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h3><p>在命令行下通过在命令最后添加”&amp;”，可以将任务放置在后台管理，后台的所有输出都</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SELinux </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划任务</title>
      <link href="/2020/02/18/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
      <url>/2020/02/18/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在linux系统上，很多任务都是临时启动执行的，但是也会存在计划安排的任务。比如说按照提前设定好的时间发送一封邮件，每天对服务器大的登录日志进行检查，并且筛选出异常的登录记录使用邮件发出提醒系统管理员及时处理。这些功能都需要相关的命令实现。</p><h2 id="计划任务分类"><a href="#计划任务分类" class="headerlink" title="计划任务分类"></a>计划任务分类</h2><p>计划任务分为两类，一种是例行性的，即每个一段时间就执行一次任务；另外一种是突发性的，即执行一次就不再执行的。</p><p>例行性的任务可以使用crontab；突发性的任务可以使用at。</p><h3 id="Linux常见的例行性任务"><a href="#Linux常见的例行性任务" class="headerlink" title="Linux常见的例行性任务"></a>Linux常见的例行性任务</h3><ul><li><strong>登录日志文件的轮替</strong>：Linux系统会把系统所发生的各种信息都记录下来，记录在登录日志中。由于一直记录登录信息，会导致文档所占容量越来越大，同时会导致读取和处理文档越困难，因此需要定期将登录日志文件移到其他地方保存，新旧登录日志分开存储。</li><li><strong>登录日志分析</strong>：系统管理员需定期对登录日志进行分期可以及时发现系统存在的安全威胁，这些威胁包括不限于硬件错误、软件错误和资料安全问题。而周期性的工作更适合使用例行性任务去完成。</li><li><strong>查询资料库的建立更新</strong></li><li><strong>RPM登录档建立</strong></li><li><strong>移除暂存档</strong>：有些软件关闭后还存在一些未清理的失效临时缓存文件，可以定时执行tmpwatch清除临时文件。</li><li><strong>与网络服务有关的分析行为</strong>：在网站服务器上，linux会主动去分析网站服务的登录日志。</li></ul><h2 id="突发性计划任务-at"><a href="#突发性计划任务-at" class="headerlink" title="突发性计划任务(at)"></a>突发性计划任务(at)</h2><p>突发性计划任务使用at即可实现突发性计划任务。</p><h3 id="at的工作方式"><a href="#at的工作方式" class="headerlink" title="at的工作方式"></a>at的工作方式</h3><p>at创建的突发性计划任务都是使用使用文字记录到/var/spool/at/目录下，等待atd服务去读取并在指定时间执行任务。</p><p><img src="/2020/02/18/计划任务/img1.webp" alt="/var/spool/at目录下的文件"></p><h3 id="安装at"><a href="#安装at" class="headerlink" title="安装at"></a>安装at</h3><p>在某些版本的linux系统(centos最小化安装)中，可能未安装at。centos中使用<code>yum install -y at</code>安装at。</p><h3 id="开启at服务"><a href="#开启at服务" class="headerlink" title="开启at服务"></a>开启at服务</h3><p>想要正常使用at，还需要启动at的服务，名称为atd。重启服务使用<code>systemctl restart atd</code>；开机启动服务<code>systemctl enable atd</code>；查看服务的状态<code>systemctl status atd</code>。</p><p><img src="/2020/02/18/计划任务/img2.webp" alt="查看服务状态"></p><h3 id="at的基本使用"><a href="#at的基本使用" class="headerlink" title="at的基本使用"></a>at的基本使用</h3><p>首先说明一下at使用权限的问题:</p><ul><li>当不存在/etc/at.allow和/etc/at.deny配置文件时，只允许root使用；</li><li>当只存在/etc/at.allow配置文件时，只有该文件中的用户可以使用at；</li><li>当只存在/etc/at.deny配置文件时，该文件中的用户不可以使用at，其余用户都可以使用；</li><li>当/etc/at.allow和/etc/at.deny配置文件都存在时，以/etc/at.allow为准。</li></ul><pre><code class="bash">at [-f file] [-mMlvd] time## 参数解释-f 后接文件，指定从文件中读取计划任务内容；-m 任务完成时发送邮件给用户；-M 任务完成时不用发邮件给用户；-l 功能等同于atq-v 显示任务被执行的时间-d 功能等同于atrm#### 注意：at中下达命令最好通过#### at的执行权限问题：当不存在/etc/at.allow和/etc/at.deny文档时，只允许root使用；####    当只存在/etc/at.allow文件时，只有该文件中的用户可以使用at####    当只存在/etc/at/deny配置文件时time的时间格式    HH:MM    今天的HH:MM执行任务，若已经超过该时间，则明天执行；    HH:MM YYYY-MM-DD 指定年月日时间执行；    HH:MM[am|pm] [Month] [Date]    指定某年某月某日指定时间执行；    HH:MM[am|pm] + number [minutes|hours|days|weeks]    指定某个时间之后的某个时间点执行。    使用较多的是使用&quot;now+时间间隔&quot;的方式指定时间。at -c 工作号码## 用于详细列举任务的工作内容。atq## 列举所有计划任务工作。atrm 工作号码## 删除指定计划任务工作batch## 系统空闲时执行计划任务，当系统工作负载小于0.8时可以执行</code></pre><h3 id="at使用示例"><a href="#at使用示例" class="headerlink" title="at使用示例"></a>at使用示例</h3><h4 id="5分钟后向当前终端输出字符串"><a href="#5分钟后向当前终端输出字符串" class="headerlink" title="5分钟后向当前终端输出字符串"></a>5分钟后向当前终端输出字符串</h4><p>由于at在执行时标准输出和错误输出都不会直接输出到终端，因此需要使用重定向将输出重定向于终端。</p><p>首先查询目前使用的终端，使用命令<code>who am i</code>、<code>who</code>或者<code>w</code>即可查询到目前使用的终端。</p><p><img src="/2020/02/18/计划任务/img3.webp" alt="查询目前使用的终端，pts/0"></p><p>利用at实现五分钟后向当前终端输出字符串，命令<code>at now + 5 minutes</code>，输出到当前终端的命令为<code>echo &quot;hello&quot; &gt; /dev/pts/0</code></p><p><img src="/2020/02/18/计划任务/img4.webp" alt="at实现五分钟后输出字符串"></p><h4 id="利用batch实现系统空闲时执行向当前终端输出字符串"><a href="#利用batch实现系统空闲时执行向当前终端输出字符串" class="headerlink" title="利用batch实现系统空闲时执行向当前终端输出字符串"></a>利用batch实现系统空闲时执行向当前终端输出字符串</h4><p>在本实验中使用bc计算100000位pi的值占用cpu来模拟系统负载大，计算100000位pi值的命令为<code>echo &quot;scale=100000; 4*a(1)&quot; | bc -lq &amp;</code>（若提示未安装bc，则使用yum install -y bc安装），使用3个线程同时计算以确保系统负载较大(若计算机性能较好，则可以适当增加个数)。然后命令行使用<code>batch</code>进入计划任务编辑，输入指令<code>echo &quot;hello&quot; &gt; /dev/pts/0</code>。</p><p><img src="/2020/02/18/计划任务/img5.webp" alt="使用batch设置计划任务"></p><p>可以使用<code>atq</code>或者<code>at -l</code>命令查看计划任务列表，使用<code>atrm 工作号码</code>或者<code>at -d 工作号码</code>删除计划任务。</p><p><img src="/2020/02/18/计划任务/img6.webp" alt="使用atq和atrm"></p><h2 id="例行性计划任务（crontab）"><a href="#例行性计划任务（crontab）" class="headerlink" title="例行性计划任务（crontab）"></a>例行性计划任务（crontab）</h2><p>例行性计划任务是每隔一定的时间就需要执行的任务，需要多次执行该任务。</p><h3 id="crontab运行原理"><a href="#crontab运行原理" class="headerlink" title="crontab运行原理"></a>crontab运行原理</h3><p><code>crontab -e</code>可以编辑cron任务的内容，任务格式如<code>* * * * * echo &quot;hello&quot;</code>，”:wq”保存并退出crontab任务编辑，实际以文档的形式存放在/var/spool/cron路径下，通过用户划分不同文档保存，需要注意：不建议直接编辑/var/spool/cron下的计划任务文档。cron计划任务是通过crond服务实现的，crond服务每分钟会检查/var/spool/cron满足执行条件的任务并执行。</p><h3 id="crontab计划任务存储位置"><a href="#crontab计划任务存储位置" class="headerlink" title="crontab计划任务存储位置"></a>crontab计划任务存储位置</h3><ul><li>/var/spool/cron/*    ps:该位置是由个人用户使用<code>crontab -e</code>命令编辑计划任务保存的，保存到名称为用户名的文档中；</li><li>/etc/crontab    ps:该位置存储的是系统的计划任务，如：定期维护系统的脚本等；</li><li>/etc/cron.d/*    ps:该位置的文档也是和系统的运行有关，可以将一个软件的计划任务文档直接放置在该路径下即可生效，更新脚本可以直接覆盖即可。</li></ul><h3 id="crontab权限管理"><a href="#crontab权限管理" class="headerlink" title="crontab权限管理"></a>crontab权限管理</h3><p>crontab的执行权限与at类似，通过/etc/cron.allow和/etc/cron.deny控制，且/etc/cron.allow的优先级高于/etc/cron.deny。当cron.allow和cron.deny都不存在时，只有root能使用；当有cron.allow存在时，只有写入文档中的用户可使用；当只有cron.deny存在时，写入文档中的用户都不可使用。</p><h3 id="crontab的基本用法"><a href="#crontab的基本用法" class="headerlink" title="crontab的基本用法"></a>crontab的基本用法</h3><pre><code class="bash">crontab [-u user] [-l | -r | -e | -i]## 参数解释-u 帮助其他用户管理crontab任务，后接用户名；-l 列举出crontab任务；-r 删除用户所有crontab任务；-e 编辑用户的crontab任务## crontab任务格式* * * * * echo “hello” &gt; /dev/pts/0#分 时 日 月 星期 命令</code></pre><p>以下为crontab例行性任务设置格式，使用命令<code>crontab -e</code>进入例行性任务编辑命令行，按照格式即可添加例行性任务，以下为各参数的数值范围：</p><table><thead><tr><th align="center">代表含义</th><th align="center">分钟</th><th align="center">小时</th><th align="center">日期</th><th align="center">月份</th><th align="center">周</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center">数值范围</td><td align="center">0-59</td><td align="center">0-23</td><td align="center">1-31</td><td align="center">1-12</td><td align="center">0-7</td><td align="center">例行任务的指令</td></tr></tbody></table><p>特别需要注意的是周设置中0和7一样表示周日，且周与日月设置不能同时共存。在设置过程中还涉及到使用一些特殊的符号，其所表示的意义如下表所示：</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*(星号)</td><td align="center">表示接受任何值</td></tr><tr><td align="center">,(逗号)</td><td align="center">表示接受多个值，中间使用逗号分隔</td></tr><tr><td align="center">-(减号)</td><td align="center">表示值的范围，4-6表示4、5、6这3个值</td></tr><tr><td align="center">/n</td><td align="center">表示能被n整除的值</td></tr></tbody></table><p>注意在/etc/crontab中的计划任务在周之后指令之前需要添加指定执行任务所使用的用户。且在/etc/crontab的前三行分别指定使用何种shell执行、执行时的PATH路径和额外的输出使用时谁接收邮件。</p><p><img src="/2020/02/18/计划任务/img7.webp" alt="/etc/crontab内容"></p><p>以以下几个命令讲解基本用法：</p><ul><li><code>* * * * * echo &quot;hello&quot; &gt; /dev/pts/0</code> *表示任意值都满足，那么说明任何时间都能执行任务，由于crontab是由crond服务每分钟调用实现的，那么这条命令则表示每分钟输出一次”hello”到/dev/pts/0终端中。</li><li><code>*/5 6,7 * * 1-5 echo &quot;hello&quot; &gt; /dev/pts/0</code>这条命令中可以看出，分钟使用*/，表示分钟为5的倍数时满足条件，即0、5、10、15……；小时部分使用6,7表示小时为6和7都满足条件；日和月使用*，表示任何日月都满足条件；周使用1-5表示星期一到星期五都满足条件。所以综合上述分析，这条命令表示的是周一到周五每天早上6时至8时两个小时期间每5分钟向/dev/pts/0终端输出”hello”。</li></ul><h3 id="修改或者删除crontab任务"><a href="#修改或者删除crontab任务" class="headerlink" title="修改或者删除crontab任务"></a>修改或者删除crontab任务</h3><p>如果该用户的所有的计划任务都需要删除，则可以直接使用命令<code>crontab -r</code>清除，若只是删除部分任务则需要使用<code>crontab -e</code>将对应的crontab任务行删除即可。</p><h3 id="crontab实例"><a href="#crontab实例" class="headerlink" title="crontab实例"></a>crontab实例</h3><p>这里使用每分钟都向当前终端打印出当前的时间，使用<code>crontab -e</code>进入crontab任务编辑界面，输入crontab指令<code>* * * * * date &gt; /dev/pts/0</code>。</p><p><img src="/2020/02/18/计划任务/img8.webp" alt="设置crontab计划任务"></p><p>保存退出后，系统之后的每一分钟都会在当前终端中打印出当前时间。</p><p><img src="/2020/02/18/计划任务/img9.webp" alt="每一分钟在终端中打印当前时间"></p><h3 id="crontab使用注意事项"><a href="#crontab使用注意事项" class="headerlink" title="crontab使用注意事项"></a>crontab使用注意事项</h3><p>使用crontab时需要注意的是，在不同的使用情况是crontab任务放置的位置是有所差别的。如果是个人用户的需求时，应该使用<code>crontab -e</code>来创建任务；如果关于系统维护管理方面的需要求，可以将任务放置到/etc/crontab中；如果是开发的软件需要，则应该放置在/etc/cron.d目录下。</p><p>除此之外在设计计划任务时需要注意将任务错开执行，避免一起执行导致资源分配不均。</p><h2 id="anacron"><a href="#anacron" class="headerlink" title="anacron"></a>anacron</h2><p>anacron与crontab存在很大的不同。两者都是和计划任务有关，但是crontab的作用是用于7*24小时开机的服务器，而anacron的作用是用于非7*24小时开机的服务器。anacron的实现也是通过crontab实现的，使用crontab每小时调用一次crontab去检查未执行的计划任务。当计划任务超过规定的延期时间，则安排执行计划任务。</p><h3 id="anacron实现方式"><a href="#anacron实现方式" class="headerlink" title="anacron实现方式"></a>anacron实现方式</h3><p>anacron是一个可执行的软件，存放在/sbin/anacron，且只有root用户具有执行的权限。anacron的调用与at和crontab的服务调用不同，是通过crontab计划任务定时调用的，存放在/etc/cron.hourly/0anacron，内容如下：</p><p><img src="/2020/02/18/计划任务/img10.webp" alt="anacron调用脚本0anacron"></p><p>在/etc/cron.hourly/0anacron配置文件中，首先指定了执行的shell：/bin/sh。接着第一个if判断使用test判断/var/spool/anacron/cron.daily文件是否存在且可读，并读出cron.daily文件中存储的日期（这个日期是上次annacron执行的日期），第二个if用于判断今天的日期是否等于记录的日期，若已经执行过anacron则退出脚本，第三个if主要是对电源的判断。最后<code>anacron -s</code>表示检查关机期间未执行的计划任务并且安排执行。</p><p><img src="/2020/02/18/计划任务/img11.webp" alt="/var/spool/anacron/cron.daily内容"></p><p>当执行anacron程序时，检查的/etc/anacrontab配置文档：</p><p><img src="/2020/02/18/计划任务/img12.webp" alt="/etc/anacronrtab内容"></p><p>SHELL：指定执行命令使用的shell工具；</p><p>PATH：指定执行该脚本使用的默认PATH路径；</p><p>MAILTO：指定邮箱通知收件人；</p><p>RANDOM_DELAY：指定最大的随机延迟时间；</p><p>START_HOURs_RANGE：指定执行anacron的时间，这设置的时间是3:00~22:00；</p><p>period in days：表示超期天数，即anacron执行的时间与之前执行的时间的差值大于此值时执行该任务，如1，则上次执行anacron的时间与此次执行相差2天则说明目前该任务已经超期，则需要执行该计划任务；</p><p>delay in munites：表示延迟时间，即安排执行时延迟时间执行，5表示延迟5分钟之后执行；</p><p>job-identifier：表示任务标识符，即任务的名称，一般与目录名称相同；</p><p>command：当满足之前的条件要求时需要执行的指令；</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">@hourly</td><td align="center">每小时一次</td></tr><tr><td align="center">@daily</td><td align="center">每天一次（凌晨）</td></tr><tr><td align="center">@weekly</td><td align="center">每周一次（周日凌晨）</td></tr><tr><td align="center">@monthly</td><td align="center">每个月一次（月初凌晨）</td></tr><tr><td align="center">@yearly</td><td align="center">每年一次（年初凌晨）</td></tr><tr><td align="center">@reboot</td><td align="center">重启执行</td></tr></tbody></table><p>run-parts命令用于执行当前目录下所有脚本。</p><p><strong>注意：anacron使用的时间戳保存在/var/spool/anacron/目录下，且命名为任务的名称。</strong></p><p><img src="/2020/02/18/计划任务/img13.webp" alt="anacron时间戳保存路径"></p><h3 id="anacron基本使用方法"><a href="#anacron基本使用方法" class="headerlink" title="anacron基本使用方法"></a>anacron基本使用方法</h3><pre><code class="bash">anacron [-s] [-f] [-n] [-d] [-q] [-t anacrontab] [-S spooldir] [job]## 参数解释-s    开始连续执行一系列工作，跳过已经执行过或者未超期的工作；-f    不管任务之前是否执行都需要执行；-n    立刻执行未进行的工作，不延迟执行；-d    不后台执行anacron任务，直接输出执行信息到标准错误输出；-q    禁止输出任何信息到标准错误输出，只与-d搭配使用；-t    使用指定的anacrontab配置文件而不是使用/etc/anacrontab配置文件；-S    使用指定的spool dir以存储anacron的时间戳，默认的时间戳位置为：/var/spool/anacron/cron.daily；job    由anacron配置文件定义的各项工作的名称。anacron -u [job]## 仅更新时间戳记录，不做任何操作</code></pre><h3 id="anacron使用注意事项"><a href="#anacron使用注意事项" class="headerlink" title="anacron使用注意事项"></a>anacron使用注意事项</h3><ul><li>想要脚本受支持anacron只需要将脚本放入/etc/cron.daily/、/etc/cron.weekly/或者/etc/cron.monthly/路径下，且注意该上个路径下的脚本都不能是定特定的时间执行，系统会按照天、周或者月为周期调用脚本执行。</li><li>需要注意的是anacron与cron的不同，anacron本身不支持计划任务，以cron实现的能使非7*24小时开机的服务器能即使执行在关机期间未执行的任务。</li><li>anacron一般是一天运行一次，从而也可以照顾到一周和一个月的计划任务的超期执行。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>on_ac_power:<a href="https://linux.die.net/man/1/on_ac_power" target="_blank" rel="noopener">https://linux.die.net/man/1/on_ac_power</a></p><p>run-parts:<a href="https://www.commandlinux.com/man-page/man8/run-parts.8.html" target="_blank" rel="noopener">https://www.commandlinux.com/man-page/man8/run-parts.8.html</a></p><p>nice:<a href="https://linux.die.net/man/1/nice" target="_blank" rel="noopener">https://linux.die.net/man/1/nice</a></p><p>鸟叔的linux私房菜:<a href="http://linux.vbird.org/linux_basic/0430cron.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0430cron.php</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 计划任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的数学公式</title>
      <link href="/2020/02/04/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
      <url>/2020/02/04/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇博客主要记录平时用到的数学公式，便于平时查找。</p><h2 id="矩阵求导公式"><a href="#矩阵求导公式" class="headerlink" title="矩阵求导公式"></a>矩阵求导公式</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>$$<br>\begin{cases}<br>\dfrac{dx^T}{dx}=I \\<br>\dfrac{dx}{dx^T}=I \\<br>\end{cases} \\<br>$$</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>$$<br>\begin{cases}\dfrac{dx^TA}{dx}=A \\<br>\frac{dAx}{dx^T}=A \\<br>\end{cases} \\<br>$$</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>$$<br>\begin{cases}<br>\dfrac{dAx}{dx}=A^T \\<br>\dfrac{dxA}{dx}=A^T  \\<br>\end{cases}<br>$$</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>$$<br>\dfrac{\partial u}{\partial x^T}=(\dfrac{\partial u^T}{\partial x})^T \\<br>$$</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>$$<br>\dfrac{\partial u^Tv}{\partial x}=\dfrac{\partial u^T}{\partial x}v+\dfrac{\partial v^T}{\partial x}u^T<br>$$</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>$$<br>\dfrac{\partial uv^T}{\partial x}=\dfrac{\partial u}{\partial x}v^T+u\dfrac{\partial v^T}{\partial x}<br>$$</p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>$$<br>\begin{cases}<br>\dfrac{dx^Tx}{dx}=2x \\<br>\dfrac{dx^TAx}{dx}=(A+A^T)x \\<br>\end{cases}<br>$$</p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>$$<br>\dfrac{\partial AB}{\partial x}=\dfrac{\partial A}{\partial x}B+A\dfrac{\partial B}{\partial x}<br>$$</p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>$$<br>\dfrac{\partial u^TXv}{\partial X}=uv^T<br>$$</p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p>$$<br>\dfrac{\partial u^TX^TXu}{\partial X}=2Xuu^T<br>$$</p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>$$<br>\dfrac{\partial [(Xu-v)^T(Xu-v)]}{\partial X}=2(Xu-v)u^T<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quota,raid和lvm</title>
      <link href="/2019/12/18/quota-raid%E5%92%8Clvm/"/>
      <url>/2019/12/18/quota-raid%E5%92%8Clvm/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客主要讲解一些磁盘管理的知识。包括硬盘配额、软磁盘阵列和逻辑卷管理。</p><h2 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h2><p>linux系统是一个多人多任务操作系统，会出现多人使用一个磁盘的情况，如果少数几个用户将大部分的硬盘空间使用掉，那么其他用户的使用空间就会大大减小，因此就需要限制用户对磁盘的使用，妥善的分配系统资源。例如/home下有10个用户，总空间大小为10G，那么每个人用户平均使用的最大容量为1G，但是有的用户在home目录下放置了许许多多的大文件，导致占用了大部分空间，影响了其他用户的磁盘使用空间，那么想要磁盘空间能公平使用，就可以使用quota限制用户的磁盘使用。</p><h3 id="quota一般用途"><a href="#quota一般用途" class="headerlink" title="quota一般用途"></a>quota一般用途</h3><ol><li>针对www服务器，限制每个人网页空间的容量限制；</li><li>针对mail服务器，限制每个人的邮件空间限制；</li><li>针对file服务器，限制每人最大的网络硬盘空间。</li></ol><p>在linux系统上一般会有的设置为：</p><ol><li>限制某一群组能使用的最大磁盘配额；</li><li>限制某一用户的最大磁盘配额；</li><li>限制某一目录的最大磁盘配额；</li></ol><p>在xfs文件系统中quota是整合到文件系统中的，因此需要在fstab进行设置开启quota。而其他的文件系统（例如ext系列文件系统）的quota是通过外挂程序实现的，因此quota查询磁盘使用相较du等命令快速，du需要重新计算目录下磁盘使用情况，而xfs直接通过xfs_quota就能查询到相关信息。通过quota，系统管理员可以直接管理磁盘的使用情况。</p><h3 id="quota使用存在的限制"><a href="#quota使用存在的限制" class="headerlink" title="quota使用存在的限制"></a>quota使用存在的限制</h3><p>quota虽然管理磁盘空间方便，但是还是存在一定的局限性：</p><ol><li><p><strong>EXT家族文件系统只能支持整个文件系统的quota。</strong>在设计quota的使用只能针对整个文件系统进行设计，无法对单个目录进行设计。但是xfs已经支持使用project模式对目录的磁盘配额进行设计。</p></li><li><p><strong>核心必须支持quota。</strong>要使用quota还需要linux系统核心支持quota，查询核心是否支持可以通过命令<code>dmesg | grep quota</code>查询。</p></li><li><p><strong>只对一般用户有效。</strong>不能对root用户设置quota。</p></li><li><p><strong>若启用了SELinux，并非对所有的目录都能设置quota。</strong>目前的CentOS系统内核一般预设启动SELinux，在预设情况下只能对/home设置quota。</p><p>PS：设置quota需要注意使用的文件系统。</p></li></ol><h3 id="quota限制设定项目"><a href="#quota限制设定项目" class="headerlink" title="quota限制设定项目"></a>quota限制设定项目</h3><p>quota对于XFS文件系统所能做的限制分为以下几种：</p><ol><li>分别针对使用者、群组和个别目录进行限制，一般是针对磁盘使用率进行限制。</li><li>容量限制或者档案数量限制，也就是限制node的数量和限制inode的数量。</li><li>警告值（soft）和使用阈值（hard）限制。当使用量低于警告值时正常使用，当高于正常值时，每次登录系统都会收到系统警告，但使用量到达阈值则不能再使用磁盘。</li><li>倒数宽限日期（grace time）：当到达警告之后，且磁盘使用量小于阈值时，则开始警告，并且开始倒计时，如果减小磁盘使用量到警告值以下时，则取消倒计时，如果倒计时结束，则<strong>将警告值设置为使用阈值</strong>。</li></ol><h3 id="quota的使用示例"><a href="#quota的使用示例" class="headerlink" title="quota的使用示例"></a>quota的使用示例</h3><p>在这个实例中新建5个用户，分别名为quota1、quota2、quota3、quota4和quota5，密码为password，同时都属于quotagroup，每个用户可以最多可以使用300MB，警告值为200MB，同时，由于/home为单独分区，最大为2GB，同时也有其他用户，为了确保其使用空间则限制群组所使用的空间最大为1GB。最后设置警告倒计时为两周，超时则将警告值设置为阈值。</p><p>为了使之间共享文件，创建一个共享文件夹，最大为500MB。</p><h4 id="创建用户及共享文件夹"><a href="#创建用户及共享文件夹" class="headerlink" title="创建用户及共享文件夹"></a>创建用户及共享文件夹</h4><pre><code class="bash">#!/bin/bash# name: create5users.sh# create 5 users for testing.# author:# qzt# create testing env# bash create5users.sh# clear testing env# bash create5users.sh clear# history:# 2019/12/23 qzt create the script.# clearif [[ -n $1 ]];then        for username in quota1 quota2 quota3 quota4 quota5        do                userdel -r $username                echo $username&#39; delete&#39;        done        rm -rf /home/quota        echo &#39;clear share dir.&#39;        groupdel quotagroup        echo &#39;clear work group&#39;        exit 0fi# addgroupadd quotagroupfor username in quota1 quota2 quota3 quota4 quota5do        useradd -g quotagroup $username        echo &quot;password&quot; | passwd --stdin $usernamedonemkdir /home/quotachgrp quotagroup /home/quotachmod 2770 /home/quota</code></pre><p>运行<code>bash create5users.sh</code>脚本执行结果如下图:</p><p><img src="/2019/12/18/quota-raid和lvm/img1.webp" alt="create5users.sh脚本运行结果"></p><h4 id="开启分区quota功能-user和group的quota"><a href="#开启分区quota功能-user和group的quota" class="headerlink" title="开启分区quota功能(user和group的quota)"></a>开启分区quota功能(user和group的quota)</h4><p>首先查看/home目录是不是属于单独的分区，运行指令<code>df -hT /home</code>，运行的结果如下:</p><p><img src="/2019/12/18/quota-raid和lvm/img2.webp" alt="查询/home是否为单独的分区"></p><p>确认是单独的分区之后，就可以开启quota功能，就xfs文件系统来说，在系统运行挂载磁盘时已经宣告quota功能，不能通过remount来重启quota功能，所以通过修改/etc/fstab配置文件，使得xfs文件系统在挂载时就已经开启了quota功能(PS:修改/etc/fstab配置文件需要使用)。在挂载/home目录的选项中添加<code>usrquota,grpquota</code>选项。</p><p><img src="/2019/12/18/quota-raid和lvm/img3.webp" alt="挂载/home时添加usrquota和grpquota选项"></p><p>重启系统或者卸载/home分区之后重新挂载分区。通过mount命令查看是否生效。</p><p><img src="/2019/12/18/quota-raid和lvm/img4.webp" alt="查看quota是否开启成功"></p><p>进一步验证quota是否正确开启，使用指令<code>xfs_quota -x -c &#39;print&#39;</code>显示quota挂载功能开启情况。</p><p><img src="/2019/12/18/quota-raid和lvm/img5.webp" alt="进一步验证quota开启情况"></p><h5 id="quota的基本使用"><a href="#quota的基本使用" class="headerlink" title="quota的基本使用"></a>quota的基本使用</h5><h6 id="quota基本查询"><a href="#quota基本查询" class="headerlink" title="quota基本查询"></a>quota基本查询</h6><pre><code class="bash">xfs_quota -x -c &#39;指令&#39; [挂载点]参数讲解-x:专家模式，后续才能接-c并输入指令；-c:后面添加指令；指令：    print：简单列出本系统种文件系统的参数信息，一般可用于检测quota是否正确开启；    df：与系统中的df一样的功能，可以加-b(block),-i(inode),-h(单位)等；    report：列出目前的quota项目，有-ugr(usr,group,project)以及-bi等资料；    state：说明目前支援quota的档案系统的咨讯，有没有相关启动项目等。</code></pre><p>查看/home挂载点档案使用情况，命令:<code>xfs_quota -x -c &quot;df -h&quot; /home</code>:</p><p><img src="/2019/12/18/quota-raid和lvm/img6.webp" alt="查看/home挂载点情况"></p><p>查看/home目录的所有用户的quota限制值,<code>xfs_quota -x -c &quot;report -ubih&quot; /home</code>：</p><p><img src="/2019/12/18/quota-raid和lvm/img7.webp" alt="查看/home目录下所有用户的quota限制值"></p><p>列出目前支持quota的文件系统是否开启了quota功能,<code>xfs_quota -x -c &quot;state&quot;</code>：</p><p><img src="/2019/12/18/quota-raid和lvm/img8.webp" alt="查看档案系统支持情况:开启了user和group quota,未开启project quota"></p><h6 id="设置限定值"><a href="#设置限定值" class="headerlink" title="设置限定值"></a>设置限定值</h6><pre><code class="bash">xfs_quota -x -c &quot;limit [-ug] b[soft|hard]=N i[soft|hard]=N name&quot; [挂载点]xfs_quota -x -c &quot;timer [-ug] [-bir] Ndays&quot; [挂载点]## 参数解释limit: 设置限定值命令，可以对user或者group进行设置，设置的内容有:    bsoft/bhard:block数量的soft/hard限制，可以使用单位;    isoft/ihard:inode数量的soft/hard限制;    name:就是user或者group的名称。timer: 用于设置grace time的命令，也是可以针对user/group以及block/inode进行限制。</code></pre><p>根据之前的需求，需要设置每个测试用户(quota1,quota2,quota3,quota4,quota5)限制值,soft值300MBhard值500MB,命令<code>xfs_quota -x -c &quot;limit -u bsoft=200M bhard=300M quota1&quot; /home &amp;&amp; xfs_quota -x -c &quot;limit -u bsoft=200M bhard=300M quota2&quot; /home &amp;&amp; xfs_quota -x -c &quot;limit -u bsoft=200M bhard=300M quota3&quot; /home &amp;&amp; xfs_quota -x -c &quot;limit -u bsoft=200M bhard=300M quota4&quot; /home &amp;&amp; xfs_quota -x -c &quot;limit -u bsoft=200M bhard=300M quota5&quot; /home</code>。</p><p><img src="/2019/12/18/quota-raid和lvm/img9.webp" alt="设置5个用户的quota限制"></p><p>设置用户组的quota限制，<code>xfs_quota -x -c &quot;limit -g bsoft=950M bhard=1G quotagroup&quot; /home</code></p><p><img src="/2019/12/18/quota-raid和lvm/img10.webp" alt="设置quotagroup的quota限制"></p><p>设置grace time,命令<code>xfs_quota -x -c &quot;timer -ug -b 14days&quot; /home</code>:</p><p><img src="/2019/12/18/quota-raid和lvm/img11.webp" alt="设置grace time"></p><h6 id="测试设置值"><a href="#测试设置值" class="headerlink" title="测试设置值"></a>测试设置值</h6><p>切换到quota1用户，在/home/quota1目录下写入310M的文件，测试写入,命令<code>dd if=/dev/zero of=test.img bs=1M count=310</code>:</p><p><img src="/2019/12/18/quota-raid和lvm/img12.webp" alt="单个用户quota设置成功"></p><p>分别用quota1、quota2、quota3、quota4、用户往/home目录下写入310M内容，前三个用户写入299M的内容，若quota4写入126M左右的内容，则说明群组quota设置成功。</p><p><img src="/2019/12/18/quota-raid和lvm/img13.webp" alt="群组quota设置成功"></p><p>通过以上的两张图片也说明grace time设置成功。</p><h4 id="开启分区project-quota功能"><a href="#开启分区project-quota功能" class="headerlink" title="开启分区project quota功能"></a>开启分区project quota功能</h4><p>由于project quota功能与之前的user和group quota功能冲突（比如说放在quota用户的家目录下和/home/quota下都属于在/home目录下，都会受到user quota和group quota的限制，达不到共享目录限制的效果），所以使用另外一个支持quota的空闲分区下的目录作为共享目录较好。</p><p>新建分区，格式化分区(建议为xfs分区)，挂载为project quota(参数为prjquota)分区。</p><p>与设置user和group quota功能不同，project quota还需要设置专案名称和专案id，命令<code>echo &quot;8315:/media/m/share&quot; &gt;&gt; /etc/projects &amp;&amp; echo &quot;quotaproject:8315&quot; &gt;&gt; /etc/projid</code></p><p>设置好专案名称和专案id后，还要初始化专案名称,命令<code>xfs_quota -x -c &quot;project -s quotaproject&quot;</code>，执行结果中有-1不用管。</p><p><img src="/2019/12/18/quota-raid和lvm/img14.webp" alt="初始化专案名称"></p><p>查看project quota设置是否成功，命令<code>xfs_quota -x -c &quot;print&quot; /media/m</code></p><p><img src="/2019/12/18/quota-raid和lvm/img15.webp" alt="设置project quota成功"></p><h5 id="设置project-quota限制值"><a href="#设置project-quota限制值" class="headerlink" title="设置project quota限制值"></a>设置project quota限制值</h5><p>命令<code>xfs_quota -x -c &quot;limit -p bsoft=450M bhard=500M quotaproject&quot; /media/m</code>设置限制值。</p><p><img src="/2019/12/18/quota-raid和lvm/img16.webp" alt="开启project quota"></p><h5 id="测试project-quota"><a href="#测试project-quota" class="headerlink" title="测试project quota"></a>测试project quota</h5><p>使用quota1用户向/media/m目录中写入550M的内容，命令<code>dd if=/dev/zero of=test.img bs=1M count=550</code>。</p><p><img src="/2019/12/18/quota-raid和lvm/img17.webp" alt="测试project quota"></p><h4 id="quota的其他一些设置参数"><a href="#quota的其他一些设置参数" class="headerlink" title="quota的其他一些设置参数"></a>quota的其他一些设置参数</h4><h5 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h5><p>disable命令可以暂时取消quota的限制，但是还是在计算quota。</p><p><img src="/2019/12/18/quota-raid和lvm/img18.webp" alt="暂停/media/m的quota功能"></p><p>命令值得u和p参数分别表示对user和project quota进行限制，group使用g表示。</p><h5 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h5><p>enable是与disable相反的命令，恢复quota限制功能。</p><p><img src="/2019/12/18/quota-raid和lvm/img19.webp" alt="恢复quota功能"></p><h5 id="off"><a href="#off" class="headerlink" title="off"></a>off</h5><p>off命令用于停用quota功能，无法使用enable开启，只有卸载之后重新加载分区之后才能启用quota。一般该命令用于需要移除(remove)quota才会使用到。</p><p><img src="/2019/12/18/quota-raid和lvm/img20.webp" alt="off执行之后需要重新挂载分区才能启用quota"></p><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>remove命令用于永久移除quota功能，即无法再恢复quota数据。注意，remove之前用off停止quota。</p><p><img src="/2019/12/18/quota-raid和lvm/img21.webp" alt="移除/media/m的user quota功能"></p><h2 id="raid"><a href="#raid" class="headerlink" title="raid"></a>raid</h2><p>目前磁盘的单盘容量大多限制在4T，对于大容量存储，尤其是需要PB级存储时，就需要多个磁盘同时存储。raid叫做磁盘阵列，通过软件或者硬件将多个较小的磁盘合并为较大的磁盘，除了提供较大的存储容量以外，还可以提供数据保护方面的功能。raid的等级不同可以提供不同的功能。</p><h3 id="raid-0"><a href="#raid-0" class="headerlink" title="raid-0"></a>raid-0</h3><p>raid-0在所有raid中具有最佳的效能，具备磁盘空间叠加，同时磁盘的速度叠加。但是该raid等级不提供任何的数据保护功能，但磁盘出现问题时，数据无法恢复。在raid0中，首先将所有的磁盘划分成等量的区块（chunk，一般设定为4K~1M之间），当有数据需要写入时，将数据按照chunk大小切割，并将数据分散写入不同的磁盘，当有两个磁盘时，则每个磁盘上存储一半的数据内容。同时，由于是多块磁盘同时读写，则可以叠加多块磁盘的读写速度，提高IO性能。</p><p><img src="/2019/12/18/quota-raid和lvm/img22.svg" alt="raid0实现原理"></p><p>DiskA和DiskB两个磁盘首先以chunk大小划分为一个个小空间。数据在写入磁盘之前也划分为chunk大小的区块，写入数据时将一个个区块写入到不同的磁盘上。因为数据是切分之后放置到磁盘上的，因此单个磁盘的写入量减少。同样的，当磁盘的数量越多，则同样的数据写于到单个磁盘的数据越少，写入的时间花费越少。<strong>多张磁盘组合，存储的容量等于各个磁盘容量相加，速度等于各个磁盘速度叠加。</strong>raid0的缺点同样很明显，当其中一块磁盘损坏时，整个数据就就损坏了。组建raid0一定需要注意使用同样容量大小的磁盘，因为raid0写入数据是磁盘交替写入，当小容量磁盘写满数据后，速度就会下降。</p><h3 id="raid-1"><a href="#raid-1" class="headerlink" title="raid-1"></a>raid-1</h3><p>raid1也称为镜像模式，该模式需要相同容量的磁盘。如果是不同容量的磁盘组raid1则以较小容量的磁盘为主。raid1模式是将同一份资料同时存储到两个磁盘上，即为镜像。</p><p><img src="/2019/12/18/quota-raid和lvm/img23.svg" alt="raid1实现原理"></p><p>当有数据需要写入时，同样的数据会被分别写入两个硬盘，相同的数据通过io写到硬盘之后，写入的数据量变多了，如果是通过软件实现的raid1，通过南桥的数据量会是正常数据量的两倍，可能会使写入效率降低，而读数据由于有两份数据在不同的磁盘上，在两个软件同时读取数据时效率可能会有所提升。如果是使用硬件(磁盘阵列卡)实现raid1则南桥的数据量没有改变，不会降低磁盘的io性能。raid1带来的最大的好处便是任何一个磁盘损坏都不会导致数据丢失。</p><h3 id="raid-10和raid-01"><a href="#raid-10和raid-01" class="headerlink" title="raid-10和raid-01"></a>raid-10和raid-01</h3><p>raid-10和raid-01都是将raid0和raid1组合起来实现的，但是他们又存在一定的差别。raid10是将多个磁盘(4块以上且为偶数块磁盘)，先两两组合成raid1，然后再将多个raid1按照raid0的方式组合。而raid01则是向组合成raid0再组合成raid1。在实际的应用中，raid10在数据恢复难度和数据恢复成本上较raid01更有优势，一般使用raid10。</p><p><img src="/2019/12/18/quota-raid和lvm/img25.svg" alt="raid10和raid01原理图(这里以六块磁盘作为示范)"></p><h3 id="raid5"><a href="#raid5" class="headerlink" title="raid5"></a>raid5</h3><p>raid5至少需要三块硬盘才能组成。raid5与raid0类似，将数据依次写入多个硬盘中，在循环写入数据时，也写入奇偶校验位(parity P)。</p><p><img src="/2019/12/18/quota-raid和lvm/img26.svg" alt="raid5原理图"></p><p>在同一个循环内总有一块磁盘用于存储奇偶校验位，因此组raid5之后会少一块盘的容量，并且可以在有一块硬盘坏掉之时通过冗余方法恢复出该块硬盘的内容(多于一块盘损坏则无法恢复)，同时由于写入方法类似于raid0，也具有raid0速度叠加的好处。由于存在奇偶校验位的原因，如果使用软件组建raid5，则在计算奇偶校验位时会使用到cpu运算，限制了raid5的效率；如果使用硬件组件raid5，则不会计算奇偶校验位只会产生在磁盘阵列卡上，不会影响到整个系统的性能。而raid6则是在raid5的基础上多了一个磁盘的parity，这样即使存在两个磁盘损坏时也可以恢复数据。</p><h3 id="spare-disk（热备份盘）"><a href="#spare-disk（热备份盘）" class="headerlink" title="spare disk（热备份盘）"></a>spare disk（热备份盘）</h3><p>在raid5等raid模式下，出现磁盘损坏需要移除损坏的磁盘并使用完好的磁盘重建raid，但是即使是支持热插拔的磁盘阵列卡，也是需要手动更换损坏的硬盘，但是如果磁盘阵列卡支持热备份盘，并且你也设置了热备份盘的话，出现磁盘损坏时既可以立刻使用设置好的热备份盘重建raid。</p><table><thead><tr><th align="center">项目</th><th align="center">raid0</th><th align="center">raid1</th><th align="center">raid10</th><th align="center">raid5</th><th align="center">raid6</th></tr></thead><tbody><tr><td align="center">最少磁盘数</td><td align="center">2</td><td align="center">2</td><td align="center">4</td><td align="center">3</td><td align="center">4</td></tr><tr><td align="center">最大容错磁盘数</td><td align="center">0</td><td align="center">n-1</td><td align="center">n/2</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">数据安全性</td><td align="center">无</td><td align="center">最好</td><td align="center">较好</td><td align="center">有</td><td align="center">比raid5好</td></tr><tr><td align="center">理论写入效率</td><td align="center">n</td><td align="center">1</td><td align="center">n/2</td><td align="center">n-1</td><td align="center">n-2</td></tr><tr><td align="center">理论读取效率</td><td align="center">n</td><td align="center">n</td><td align="center">n/2</td><td align="center">&lt;n-1</td><td align="center">&lt;n-2</td></tr><tr><td align="center">可用容量</td><td align="center">n</td><td align="center">1</td><td align="center">n/2</td><td align="center">n-1</td><td align="center">n-2</td></tr><tr><td align="center">应用</td><td align="center">个人（提升硬盘性能）</td><td align="center">保存数据与备份</td><td align="center">服务器或云系统</td><td align="center">保存数据与备份</td><td align="center">保存数据与备份</td></tr></tbody></table><h3 id="软件和硬件raid"><a href="#软件和硬件raid" class="headerlink" title="软件和硬件raid"></a>软件和硬件raid</h3><p>软件raid具有成本低的优点，存在占用系统资源，影响系统性能或是影响raid性能等缺点；</p><p>硬件raid具有更高的raid效率且可支持热插拔等特点，但是好的磁盘阵列卡成本都较高。</p><h3 id="软件raid"><a href="#软件raid" class="headerlink" title="软件raid"></a>软件raid</h3><p>在linux下可以使用mdadm指令实现软件raid，除了在磁盘上构建raid外，也可以使用多个分区构建raid。</p><h4 id="mdadm"><a href="#mdadm" class="headerlink" title="mdadm"></a>mdadm</h4><pre><code class="bash">mdadm --detail /dev/md0mdadm --create /dev/md[0-9] --auto=yes --level=[015] --chunk=NK --raid-devices=N --spare-devices=N /dev/sdx /dev/hdx ...# 参数讲解--create 建立raid选项--auto=yes 决定建立后面的软件磁盘阵列设备，即/dev/md0,/dev/md1...--chunk=NK 决定这个装置的chunk大小，一般为64K或者512K;--raid-devices=N 使用几个磁盘组建raid;--spare-devices=N 使用几个磁盘作为备用磁盘;--level=[015] 组建磁盘阵列的等级;--detail 显示指定磁盘阵列的详细信息。</code></pre><h4 id="软件组建raid示例"><a href="#软件组建raid示例" class="headerlink" title="软件组建raid示例"></a>软件组建raid示例</h4><h5 id="创建组建raid所需的分区"><a href="#创建组建raid所需的分区" class="headerlink" title="创建组建raid所需的分区"></a>创建组建raid所需的分区</h5><p>这里我们使用5个1G的分区用于组建raid，首先使用gdisk工具将磁盘划分为5个分区。</p><p><img src="/2019/12/18/quota-raid和lvm/img27.webp" alt="创建5个分区"></p><h5 id="使用mdadm创建raid"><a href="#使用mdadm创建raid" class="headerlink" title="使用mdadm创建raid"></a>使用mdadm创建raid</h5><p>在这个示例中使用4个分区组成raid5，1个分区作为备用，命令<code>mdadm --create /dev/md0 --auto=yes --level=5 --chunk=512K --raid-devices=4 --spare-devices=1 /dev/sdb{1,2,3,4,5}</code></p><p><img src="/2019/12/18/quota-raid和lvm/img28.webp" alt="mdadm组建raid"></p><p><img src="/2019/12/18/quota-raid和lvm/img29.webp" alt="查看raid信息"></p><h5 id="格式化与挂载raid磁盘"><a href="#格式化与挂载raid磁盘" class="headerlink" title="格式化与挂载raid磁盘"></a>格式化与挂载raid磁盘</h5><p>这里格式化为xfs文件系统，但是需要注意的是，因为涉及到的是raid磁盘的xfs文件系统需要注意设置参数以优化xfs文件系统的性能:</p><pre><code>stripe(chunk):在这里问我们设置为chunk大小，su=512K;sw的设置为实际存储的磁盘数量，这里使用4块硬盘作为raid，但是实际上要除去一个硬盘的空间用于存储校验信息，因此sw=3;资料的宽度为512K*3=1536K</code></pre><p>经过以上的分析，格式化命令为:<code>mkfs.xfs -f -d su=512k,sw=3 -r extsize=1536k /dev/md0</code></p><p><img src="/2019/12/18/quota-raid和lvm/img30.webp" alt="格式化raid磁盘"></p><p>挂载raid磁盘<code>mount -rw /dev/md0 /media/md0</code></p><p><img src="/2019/12/18/quota-raid和lvm/img31.webp" alt="挂载磁盘"></p><h5 id="设置自动挂载磁盘"><a href="#设置自动挂载磁盘" class="headerlink" title="设置自动挂载磁盘"></a>设置自动挂载磁盘</h5><p>在开机时较新的linux系统会自动加载raid磁盘。但是为了确保在较旧系统上依旧可以运行则可以配置mdadm的配置文档/etc/mdadm.conf。首先通过命令<code>mdadm --detail /dev/md0 | grep UUID</code>获得UUID，并修改/etc/mdadm.coonf文件。</p><pre><code class="bash"># mdadm.confARRAY /dev/md0 UUID=98d12859:872fd4cd:e71e89d7:c006b989</code></pre><p>设定开机自动挂载磁盘。首先通过命令<code>blkid /dev/md0</code>查询磁盘UUID，其次修改/etc/fstab配置文件。</p><pre><code># /etc/fstab# 最后一行添加UUID=23b36776-09d1-4c0e-95d2-50759cda2aff    /media/md0    xfs    defaults    0    0</code></pre><h5 id="测试自动挂载"><a href="#测试自动挂载" class="headerlink" title="测试自动挂载"></a>测试自动挂载</h5><p><code>umount /dev/md0</code>卸载raid磁盘md0，<code>mount -a</code>挂载所有未挂载磁盘。</p><p><img src="/2019/12/18/quota-raid和lvm/img32.webp" alt="测试自动挂载磁盘"></p><h5 id="测试磁盘出错"><a href="#测试磁盘出错" class="headerlink" title="测试磁盘出错"></a>测试磁盘出错</h5><p>首先在raid磁盘下写入512M的数据<code>dd if=/dev/random of=test.img bs=1M count=512</code>，模拟在使用中的磁盘。</p><p><img src="/2019/12/18/quota-raid和lvm/img33.webp" alt="写入随机数据，模拟使用的raid磁盘"></p><p>使用mdadm命令设置sdb2硬盘工作不正常，查看raid的工作状态。</p><p><img src="/2019/12/18/quota-raid和lvm/img34.webp" alt="模拟硬盘工作不正常"></p><p><img src="/2019/12/18/quota-raid和lvm/img35.webp" alt="重建raid并能访问文件"></p><p>sdb2磁盘并没有损坏，我们可以使用命令直接将磁盘加入，<code>mdadm --manage /dev/md0 --remove /dev/sdb2 &amp;&amp; mdadm --manage /dev/md0 --add /dev/sdb2</code>。</p><p><img src="/2019/12/18/quota-raid和lvm/img36.webp" alt="重新加入sdb2磁盘"></p><h5 id="关闭raid"><a href="#关闭raid" class="headerlink" title="关闭raid"></a>关闭raid</h5><p>首先卸载raid磁盘，命令<code>umount /dev/md0</code>，然后去掉/etc/fstab中自动挂载raid磁盘的部分【删掉(如果不确定可以只是注释掉，后边确认无问题之后再删除)添加的UUID内容】，接着用dd命令向md0中写入50M数据，命令<code>dd if=/dev/zero of=/dev/md0 bs=1M count=50</code>，清除raid的metadata和XFS的superblock，之后再mdadm中关闭raid，命令<code>mdadm --stop /dev/md0</code>，然后分别向5个分区写入10M内容，命令<code>dd if=/dev/zero of=/dev/sdb1 bs=1M count=10 &amp;&amp; dd if=/dev/zero of=/dev/sdb2 bs=1M count=10 &amp;&amp; dd if=/dev/zero of=/dev/sdb3 bs=1M count=10 &amp;&amp; dd if=/dev/zero of=/dev/sdb4 bs=1M count=10 &amp;&amp; dd if=/dev/zero of=/dev/sdb5 bs=1M count=10</code>，避免重新开机后raid重组或是以后划分分区出现问题。接着使用命令<code>cat /proc/mdstat</code>查看是否成功停掉raid，最后将/etc/mdadm.conf中添加的信息删除或注释。</p><p><img src="/2019/12/18/quota-raid和lvm/img37.webp" alt="关闭raid"></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>按照我们的预期，4磁盘组建raid5后，速度也应该接近单个磁盘的3倍，但是我们实际测试的速度还不及单个硬盘的速度，这是什么原因呢？</p><p><img src="/2019/12/18/quota-raid和lvm/img38.webp" alt="普通磁盘测速"></p><p><img src="/2019/12/18/quota-raid和lvm/img39.webp" alt="raid磁盘测速"></p><p>究其原因与实现raid的方式有关，例子组建raid系统所使用的是同一个硬盘上的5个分区，那么所有读写都是发生在同一个”硬件设备”上，组建raid的多个磁盘实际上是共用一个”硬件设备”的IO性能，无法达到速度叠加的效果，相反，写入的实际数据量较写入数据量少的，由于需要写入的信息中包含校验信息。更何况这里的”硬件设备”也只是一个虚拟硬盘。</p><h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><p>LVM即逻辑卷管理，存在的最大意义便是可以不停机弹性调整各个分区大小,也可以加入新分区或者移除分区。LVM通过软件将多个实体分区整合成一个看起来独立的大的磁盘(VG)，之后再将大的磁盘分割成可使用的分区(LV)，最后就可以挂载使用了。</p><h3 id="PV、PE、VG、LV"><a href="#PV、PE、VG、LV" class="headerlink" title="PV、PE、VG、LV"></a>PV、PE、VG、LV</h3><h4 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h4><p>PV(Physical Volume,物理卷)，实体的分区都需要调整系统识别码为8e后经过pvcreate指令转化为LVM的<strong>最</strong>底层的物理卷(PV)。</p><h4 id="VG"><a href="#VG" class="headerlink" title="VG"></a>VG</h4><p>VG(Volume Group,卷组)，将多个物理卷整合为一个卷组，VG就是LVM组合起来的大磁盘。LVM预设使用的是4M大小的PE块，在32位系统中只能使用65534个PE块，也就是256G，但是目前大多数都是使用LVM2+64位系统，不存在容量的限制。</p><h4 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h4><p>PE(Physical Extent,物理区域)，PE则是将卷组(VG)划分为一个个的PE，类似于档案系统的的block。</p><h4 id="LV"><a href="#LV" class="headerlink" title="LV"></a>LV</h4><p>LV(Logical Volume,逻辑卷)，就是将VG分为一个个可用的逻辑卷，类似于磁盘分区，大小需要按照PE为单位大小进行划分。通过LV操作之后就可以在LV上创建文件系统用于存储。</p><p>LVM的弹性分区时通过调整PE实现的，即将需要缩小的LV的未使用的PE划分为需要增大的LV的PE。</p><h3 id="LVM一般操作流程"><a href="#LVM一般操作流程" class="headerlink" title="LVM一般操作流程"></a><div name="LVM一般操作流程">LVM一般操作流程</div></h3><p><img src="/2019/12/18/quota-raid和lvm/img40.svg" alt="LVM的操作流程"></p><h4 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a><div name="创建PV">创建PV</div></h4><p>首先使用<code>pvcreate</code>命令将实体分区转化为PV(物理卷)。</p><pre><code class="bash"># 与PV有关的命令# 将实体分区转化为PVpvcreate 所有分区# 例如 pvcreate /dev/sdb{1,2,3,4,5}# 显示所有的PVpvscan# 显示PV的状态pvdisplay [分区]# 例如 pvdisplay /dev/sdb1# 将PV分区转化为普通实体分区pvremove 分区</code></pre><p>在开始示例之前，我们使用的是上次组建raid的5个分区，因此转换为PV的命令为<code>pvcreate /dev/sdb{1,2,3,4,5}</code></p><p><img src="/2019/12/18/quota-raid和lvm/img41.webp" alt="创建PV"></p><h4 id="创建VG"><a href="#创建VG" class="headerlink" title="创建VG"></a>创建VG</h4><p>然后创建LVM大磁盘–VG。相关操作如下:</p><pre><code># 与VG有关命令# 将PV整合为一个VGvgcretae [-s N[mgt]] VG名称 PV名称# 例如:vgcreate -s 16M lvmvg /dev/sdb{1,2,3}# 查看系统上是否有VG存在vgscan# 显示VG的状态信息vgdisplay VG名称# 在VG内增加额外的PVvgextend VG名称 PV名称# 在VG内减少PVvgreduce VG名称 PV名称# 设定VG是否启动vgchange -a[y|n] VG名称# 移除一个VGvgremove [-f] VG名称</code></pre><p>示例中使用3个PV组建VG，命令为:<code>vgcreate -s 16M lvmvg /dev/sdb{1,2,3}</code></p><p><img src="/2019/12/18/quota-raid和lvm/img42.webp" alt="创建vg"></p><h4 id="创建LV"><a href="#创建LV" class="headerlink" title="创建LV"></a>创建LV</h4><p>最后创建LV，相关操作如下:</p><pre><code class="bash"># 与LV有关的命令如下：# 创建LV命令lvcreate [-L N[mgt]|-l N] [-n LV名称] VG名称# 参数讲解:# L 后接容量，单位可以为m、g、t，最小单位为PE大小；# l 后接PE的个数，不是PE的数量，需要自行PE的数量# n 后接LV名称# 浏览整个卷组的逻辑卷lvscan# 显示LV详细情况lvdisplay LV名称# 增加LV容量lvextend -L [+]N[mgt] LV名称# 注意，有+表示增加的容量，没有+表示调整容量为指定的容量# 减少LV容量lvreduce -L N[mgt] LV名称# 移除LVlvremove [-f] LV名称# 调整LV大小lvresize [-L [+|-]N[mgt]] LV名称# 注意：+后接增加多少空间，-表示减少多少空间，无符号表示调整到多少，# 千万注意缩减空间时一定要注意检查文件系统，避免缩减空间导致文件丢失。</code></pre><p>在示例中创建一个大小为500G的LV，命名为firstlv，命令为：<code>lvcreate -L 500M -n firstlv lvmvg</code>。<br><img src="/2019/12/18/quota-raid和lvm/img43.webp" alt="创建LV"></p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>LV相当于实体分区，需要格式化之后挂载使用。</p><p>首先格式化LV，LV的位置在/dev/VG名称/LV名称，命令<code>mkfs.xfs /dev/lvmvg/firstlv</code></p><p><img src="/2019/12/18/quota-raid和lvm/img44.webp" alt="格式化LV"></p><p>挂载LV，将格式化的LV挂载在/media/lvm,命令<code>mkdir /media/lvm &amp;&amp; mount /dev/lvmvg/firstlv /media/lvm</code></p><p><img src="/2019/12/18/quota-raid和lvm/img45.webp" alt="挂载LV"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>往里写入50M文件测试工作是否正常，命令<code>dd if=/dev/zero of=test.img bs=1M count=50</code></p><p><img src="/2019/12/18/quota-raid和lvm/img46.webp" alt="测试lvm工作是否正常"></p><h3 id="LV大小调整步骤"><a href="#LV大小调整步骤" class="headerlink" title="LV大小调整步骤"></a>LV大小调整步骤</h3><p>调整LV的大小实际上是想调整文件系统的大小，那么一般分为两种，扩容和缩容。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>扩容的完整步骤类似于<a href="#LVM一般操作流程">LVM的使用步骤</a>。</p><h5 id="创建PV-1"><a href="#创建PV-1" class="headerlink" title="创建PV"></a>创建PV</h5><p>可以通过<code>vgdisplay</code>命令用于查询VG的使用情况，命令<code>vgdisplay lvmvg</code>或者<code>vgdisplay /dev/lvmvg</code>。</p><p><img src="/2019/12/18/quota-raid和lvm/img47.webp" alt="查看vg状态"></p><p>如果VG有充足的剩余空间，则不需要创建新的PV用于扩容VG，可以跳过创建PV，直接进行<a href="#扩容LV">扩容LV</a>。</p><p>如果VG空间不足，则需要使用新的分区用于<a href="#创建PV">创建PV</a>。</p><h5 id="扩容VG"><a href="#扩容VG" class="headerlink" title="扩容VG"></a>扩容VG</h5><p>通过<code>vgextend</code>命令就可以完成VG扩容，命令为<code>vgextend lvmvg /dev/sdb4</code></p><p><img src="/2019/12/18/quota-raid和lvm/img48.webp" alt="扩容VG"></p><h5 id="扩容LV"><a href="#扩容LV" class="headerlink" title="扩容LV"></a><div name="扩容LV">扩容LV</div></h5><p>扩容LV使用<code>lvextend</code>命令即可。在本次示例中给firstlv扩容500M空间，命令为<code>lvextend -L +500M /dev/lvmvg/firstlv</code></p><p><img src="/2019/12/18/quota-raid和lvm/img49.webp" alt="扩容LV"></p><h5 id="调整文件系统"><a href="#调整文件系统" class="headerlink" title="调整文件系统"></a>调整文件系统</h5><p>最终的目的就是使文件系统的容量增大，目前支持LVM较好的是<strong>EXT4和XFS</strong>文件系统，更近一步说，完全支持缩放文件系统大小的是EXT4文件系统，XFS则只支持扩容操作。</p><p>XFS使用<code>xfs_growfs</code>，命令为<code>xfs_growfs /media/lvm</code></p><p><img src="/2019/12/18/quota-raid和lvm/img50.webp" alt="扩容xfs文件系统"></p><p>EXT4使用<code>resize2fs</code>扩容文件系统。用法如下:</p><pre><code class="bash">resize2fs [-f] device [size]# 参数讲解# f 强制执行# device 指定执行命令的文件系统所在的磁盘# size 指定调整之后的文件系统容量大小</code></pre><p>EXT4扩容命令为<code>lvresize -L +500M /dev/lvmvg/ext4lv &amp;&amp; e2fsck -f /dev/lvmvg/ext4lv &amp;&amp; resize2fs /dev/lvmvg/ext4lv</code>，注意e2fsck为检查文件系统命令，且不能挂载。</p><p><img src="/2019/12/18/quota-raid和lvm/img51.webp" alt="扩容EXT4文件系统"></p><h4 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h4><p>由于缩容使用较少且xfs文件系统不支持缩小文件系统容量，所以这里使用EXT4文件系统简要演示缩容的操作。</p><p>将上面扩容为1.5G的EXT4文件系统修改为1G，命令为<code>e2fsck -f /dev/lvmvg/ext4lv &amp;&amp; resize2fs -f /dev/lvmvg/ext4lv 1G &amp;&amp; lvresize -L 1G  /dev/lvmvg/ext4lv</code></p><p><img src="/2019/12/18/quota-raid和lvm/img52.webp" alt="LV缩容"></p><h3 id="LVM-thin-Volume"><a href="#LVM-thin-Volume" class="headerlink" title="LVM thin Volume"></a>LVM thin Volume</h3><p>之所以会有这个技术的原因在于LVM的动态可调整，且在短时间内使用的磁盘空间只是总量的一部分，相当于通过LVM技术许诺一个磁盘大小，就像是一张支票一样，上边的数字可以随便填写，但是能不能取出这么多钱是不一定的。</p><p>具体的操作是，首先在VG的未分配空间内创建一个thin pool(LV)，又叫磁盘容量存储池，thin pool的大小是真实占用物理磁盘的空间，而thin volume则是创建在thin pool之上，其大小是许诺的。</p><h4 id="thin-volume创建步骤"><a href="#thin-volume创建步骤" class="headerlink" title="thin volume创建步骤"></a>thin volume创建步骤</h4><p>在创建thin volume的实例中，之前我们创建的lvmvg(VG)还剩余1.4G未使用，因此我们创建1G的thin pool，并许诺一个10G的thin volume。</p><h5 id="创建thin-pool"><a href="#创建thin-pool" class="headerlink" title="创建thin pool"></a>创建thin pool</h5><p>thin volume依托在thin pool之上，所以我们需要首先创建thin pool。创建thin pool与创建普通的LV类似，但是在命令中多一个<code>T</code>参数。示例中使用命令<code>lvcreate -L 1G -T -n thinpool1 lvmvg</code></p><p><img src="/2019/12/18/quota-raid和lvm/img53.webp" alt="创建thin pool"></p><h5 id="创建thin-volume"><a href="#创建thin-volume" class="headerlink" title="创建thin volume"></a>创建thin volume</h5><p>在thin pool之上创建LV，与创建LV使用的是相同的命令，但是有较大的差别。使用<code>V</code>参数指定虚拟的容量大小，使用<code>T</code>参数指定thin pool，<code>n</code>参数指定thin volume的名称。示例中使用的命令为<code>lvcreate -V 10G -T /dev/lvmvg/thinpool1 -n thinvolume1</code>。</p><p><img src="/2019/12/18/quota-raid和lvm/img54.webp" alt="创建thin volume"></p><h4 id="测试thin-volume"><a href="#测试thin-volume" class="headerlink" title="测试thin volume"></a>测试thin volume</h4><p>由于thin volume实际分配的空间只有1G，所以测试数据不能超过1G，这里我们选择写入100M内容。将/dev/lvmvg/thinvolume1格式化并挂载，使用命令<code>dd if=/dev/urandom of=test.img bs=1M count=100</code>写入数据。</p><p><img src="/2019/12/18/quota-raid和lvm/img55.webp" alt="测试thin volume是否可用"></p><h3 id="LVM快照"><a href="#LVM快照" class="headerlink" title="LVM快照"></a>LVM快照</h3><p>LVM除了能动态调整LV的大小以外还能提供快照的功能。LVM实现快照的功能是通过快照区实现的，当有文件被改动时，就将改动前的文件移到快照区，然后再把新内容保存下来，并将这个内容排除在快照区外。</p><p><img src="/2019/12/18/quota-raid和lvm/img56.svg" alt="LVM快照原理"></p><h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><p>在创建快照之前注意查询VG是否还有空闲的空间(lvmvg还剩余26个PE未使用)，若没有空闲的空间的话，则需要扩容VG以创建快照。</p><p>使用命令<code>lvcreate -s -l 26 -n firstlvsnap /dev/lvmvg/firstlv</code></p><p><img src="/2019/12/18/quota-raid和lvm/img57.webp" alt="创建firstlv的LV快照"></p><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>首先我们将快照和firstlv同时分别挂载(注意快照区和LV有同样的uuid，因此挂载时需添加<code>-o nouuid</code>)，这时如果我们删除firstlv中的文件，并写入新文件，然后再查看快照区的文件内容。</p><p><img src="/2019/12/18/quota-raid和lvm/img58.webp" alt="利用快照区可以找回删除掉的文件"></p><p>但是快照区的空间一般不大，当有大量数据改动时，快照区空间消耗完之后就会使快照区失效。</p><h3 id="移除LVM"><a href="#移除LVM" class="headerlink" title="移除LVM"></a>移除LVM</h3><p>即将所有创建的LV、VG、PV都移除掉，并且将分区的系统标识号改回以前的号码。</p><p>首先将所有挂载的分区移除，命令<code>umount /dev/lvmvg/firstlv &amp;&amp; umount /dev/lvmvg/firstlvsnap &amp;&amp; umount /dev/lvmvg/thinvolume1</code></p><p><img src="/2019/12/18/quota-raid和lvm/img59.webp" alt="移除所有挂载的LVM"></p><p>其次移除所有的LV，注意thin pool移除前需将thin volume移除，移除LV之前应确保快照已经移除，命令<code>lvremove -f /dev/lvmvg/firstlvsnap &amp;&amp; lvremove -f /dev/lvmvg/firstlv &amp;&amp; lvremove -f /dev/lvmvg/thinvolume1 &amp;&amp; lvremove -f /dev/lvmvg/thinpool1 &amp;&amp; lvremove -f /dev/lvmvg/ext4lv</code>。</p><p><img src="/2019/12/18/quota-raid和lvm/img60.webp" alt="移除所有的LV"></p><p>接着移除VG，命令<code>vgremove -f lvmvg</code>。</p><p><img src="/2019/12/18/quota-raid和lvm/img61.webp" alt="移除VG"></p><p>然后移除所有与VG相关的PV，命令<code>pvremove -f /dev/sdb1 &amp;&amp; pvremove -f /dev/sdb2 &amp;&amp; pvremove -f /dev/sdb3 &amp;&amp; pvremove -f /dev/sdb4 &amp;&amp; pvremove -f /dev/sdb5</code></p><p><img src="/2019/12/18/quota-raid和lvm/img62.webp" alt="移除所有相关PV"></p><p>最后修改实体分区的系统标识号(gdisk)。</p><p>添加的LVM完全移除。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜第十四章:&lt; <a href="http://linux.vbird.org/linux_basic/0420quota.php&gt;" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0420quota.php&gt;</a></p><p>以及部分网络搜索的资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quota </tag>
            
            <tag> raid </tag>
            
            <tag> lvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux用户及权限管理</title>
      <link href="/2019/11/17/linux%E7%94%A8%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2019/11/17/linux%E7%94%A8%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次使用linux系统我们都需要登录，用户在登录过程中起到重要的作用。本篇博客主要讲解用户及其管理的相关内容。</p><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>用户是使用linux的前提，只有经过了linux的用户认证才能正常使用系统。那么在系统内部是怎么实现这样的机制的。</p><h3 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h3><p>对于计算机而言，只会识别0和1构成的二进制，对文字识别较差，因此如果用一个数字来表示一个用户的话会比较方便。linux系统是一个多人多任务系统，仅仅只有单个的用户显然是不合理的，多个用户也可以存在某种关系，比如说共同开发一个项目，那么这些成员应该同时属于同一个工作组，共享某些资源，因此也存在组的概念。和用户一样，用户组组也是用唯一的数字标识的。用户用UID标识，用户组使用GID标识。</p><h4 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h4><p>人和计算机存在认知的差别，计算机只对数字敏感，人对文字敏感，因此在人们使用linux系统的时候通常都是通过用户的名称来进行操作的，而在系统内部都是转化为数字，因此需要在硬盘上记录下用户名和用户标识的对应关系。linux使用<code>/etc/passwd</code>来记录。</p><p><img src="/2019/11/17/linux用户及权限管理/img1.webp" alt="/etc/passwd文件内容"></p><p>打开这个文件，里边有非常多的内容，其中就能看到熟悉的root用户和登录使用的test用户，还有一些伪用户。这些伪用户是为了方便系统管理，满足相应的系统进程对文件属主的要求 ，删除之后可能会导致严重的系统问题，不能将其删除。</p><p>在passwd文件中每一行记录一个用户的资料，每一行有7栏分别用‘:’分隔，没有内容的栏位为空。分别表示：</p><pre><code>用户名:密码(一般为x,密码单独存储在/etc/shadow):用户标识码(UID):用户组标识码(GID):用户说明:家目录:登录成功后执行的命令</code></pre><p><strong>用户名</strong>：日常使用系统登录时所使用的名字。使用’用户名’+’密码’即可登录系统。</p><p><strong>密码</strong>:目前使用的linux一般都不会将密码直接存储在<code>/etc/passwd</code>文件中，考虑到安全问题一般会存放在<code>/etc/shadow</code>文件中。这个栏位一般为’x’或‘*’。</p><p><strong>用户标识</strong>:在linux系统内部是依靠用户标识(UID)来辨识用户的，每一个用户一般会有唯一一个UID(一般UID为0的可能有多个，都是系统管理员)。并且UID分配具有一定的规律，可以查看<code>/etc/login.defs</code>文件获知，规律如下表所示:</p><table><thead><tr><th align="center">UID范围</th><th align="center">用户</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">表示系统管理员，要让其他用户具有root权限，即把该用户的UID改为0即可。一般不建议有多个系统管理员</td></tr><tr><td align="center">1~999</td><td align="center">系统用户，也就是伪用户，是系统为了使用较小的权限启动某些服务，减少root用户使用。Centos7中伪用户的范围为‘1~999’（其他的一些系统可能是1~499），一般是安装软件或者服务的时候创建。普通用户一般从1000开始，最大已经可以到（2^32-1）。(需要注意的是:1~200是系统自建系统用户的范围，用户自建系统用户一般是201~999)</td></tr><tr><td align="center">1000~60000</td><td align="center">普通用户</td></tr></tbody></table><p><strong>用户组标识</strong>:用户组的标识数字。</p><p><strong>用户说明</strong>:对账户的意义进行说明。</p><p><strong>家目录</strong>:指定家目录地址。</p><p><strong>登录成功后执行的命令</strong>：一般指定登录之后使用的shell。</p><h4 id="用户密码"><a href="#用户密码" class="headerlink" title="用户密码"></a>用户密码</h4><p>上文中说到，在较新的系统里边，密码加密之后存放在<code>/etc/shadow</code>里边。用普通的用户是无法读取该文件的，因为文件的权限为所有人<strong>都不允许</strong>读写，因此需要通过<code>su -</code>切换到root用户之后读取该文件，强烈不建议修改该文件的权限，因为修改该文件权限可能会导致系统安全问题(如用户密码泄露)。</p><p><img src="/2019/11/17/linux用户及权限管理/img2.webp" alt="/etc/shadow文件内容"></p><p><code>/etc/shadow</code>文件结构与<code>/etc/passwd</code>类似，每一行记录一个用户内容，用’:’分隔为9个栏位，分别表示:</p><pre><code>用户名:密码密文:最近密码修改日期:密码不可修改天数:密码有效天数:密码失效前警告天数:密码失效后宽限天数:用户失效日期:保留</code></pre><p><strong>密码密文</strong>:用户对应的密码加密之后的密文。在前面加入’*’或者’!’可以暂时禁止用户登录。</p><p><strong>最近密码修改日期</strong>:最近一次修改密码的日期。</p><p><strong>密码不可修改天数</strong>:密码修改之后的指定天数内不能再次修改密码。</p><p><strong>密码有效天数</strong>:据上次密码修改之后指定天数后用户需要修改密码。</p><p><strong>密码失效前警告天数</strong>:在密码需要修改前指定天数开始警告用户修改密码。</p><p><strong>密码失效后宽限天数</strong>:在密码过期后的指定天数内还可以使用该密码（宽限修改密码时间）。</p><p><strong>用户失效日期</strong>:在密码失效日期之后账户将不能再次登录使用。</p><p><strong>保留</strong>:为未来新功能保留。</p><h4 id="GID"><a href="#GID" class="headerlink" title="GID"></a>GID</h4><p>GID就是用户组标志。而用户组的基本信息放在<code>/etc/group</code>文件中。该文件中的信息也是一个用户组占一行，用’:’分隔为4栏。</p><pre><code>用户组名称:用户组密码:GID:此用户组支援账户名称</code></pre><p><strong>用户组名称</strong>:该用户组的名称。</p><p><strong>用户组密码</strong>:该用户组的密码，一般是给用户组管理员设置密码。用户组的密码不会直接记录在该栏位，密文会记录在<code>/etc/gshadow</code>中，该栏位一般记录为’x’。</p><p><strong>GID</strong>:用户组的ID。</p><p><strong>此用户组支援账户名称</strong>:加入该用户组的用户名称。</p><h4 id="用户组密码"><a href="#用户组密码" class="headerlink" title="用户组密码"></a>用户组密码</h4><p>用户组是可以通过用户组管理员进行管理的，通常会给组的管理员设置密码，那么这些内容都是存放在<code>/etc/gshadow</code>文件中的。</p><p>和存放用户密码的文件相同，该文件只有root用户可以读取，因此在读取该文件内容前应该先转化为root用户。该文件也是一行保存一个用户组资料，用’:’分隔出4个栏位，分别表示:</p><pre><code>用户组名称:密码密文:组管理员:此用户组支援账户名称</code></pre><p><strong>用户组名称</strong>:用户组的名称，与<code>/etc/group</code>中的名称相对应。</p><p><strong>密码密文</strong>:该密码是用于组管理员进行组管理的。</p><p><strong>组管理员</strong>:该用户组的管理员，现在组管理员使用较少了，一般使用<code>sudo</code>一类的指令。</p><p><strong>此用户组支援账户名称</strong>:和<code>/etc/group</code>中的字段一样。</p><h4 id="有效用户组和初始用户组"><a href="#有效用户组和初始用户组" class="headerlink" title="有效用户组和初始用户组"></a>有效用户组和初始用户组</h4><p><strong>有效用户组</strong>:就是指在创建文件或者路径时填入的所属用户组。</p><p><strong>初始用户组</strong>:就是在登录用户之后即可获得该用户组权限的用户组。也就是<code>/etc/passwd</code>文件中记录的GID所对应的用户组。</p><h5 id="查看自己所属的用户组"><a href="#查看自己所属的用户组" class="headerlink" title="查看自己所属的用户组"></a>查看自己所属的用户组</h5><p>使用<code>groups</code>命令即可查看所属的用户组，排在第一位的用户组即为<strong>有效用户组</strong>。</p><h5 id="切换有效群组"><a href="#切换有效群组" class="headerlink" title="切换有效群组"></a>切换有效群组</h5><p>使用<code>newgrp group</code>即可在新的shell环境中将<strong>有效用户组</strong>切换为指定用户组，特别需要注意的是，由于是在新环境中切换的有效用户组，在使用结束后要使用<code>exit</code>退出环境。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>新增用户主要是使用<code>useradd</code>和<code>passwd</code>两个指令。</p><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>以下为<code>useradd</code>的使用:</p><pre><code>useradd [-u UID] [-g 初始用户组] [-G 附加用户组] [-mM] [-c 用户说明] [-d 家目录绝对地址] [-s shell] 用户名解释:-g 指定该参数之后，即不会创建与用户名同名的用户组；-m 强制！要创建使用者的家目录(一般用户的预设值)；-M 强制！不要创建使用者的家目录(系统用户的预设值)；-c /etc/passwd中用户说明栏内容，可以随便填入信息，默认为空；-d 指定新建用户的家目录，一定要使用绝对路径；-s 这个就是登录成功后执行的命令，指定使用的shell；-r 指定建立一个系统用户，UID属于系统用户范围，在当前使用的系统中范围为201~999，可通过文档/etc/login.defs查看；-e 账户失效日期，日期指定格式&#39;YYYY-MM-DD&#39;；-f 账户密码有效天数，-1表示永不用修改密码。注意：系统一般会有默认的用户添加的设置，在使用&#39;useradd username&#39;命令之后，默认的设置一般为:创建一般用户,新建和用户名相同的用户组并且将此用户组作为该用户的初始用户组，默认没有附加用户组和用户说明，默认使用&#39;/home/username&#39;作为用户的家目录，使用bash作为默认shell。useradd的默认设置也可以通过&#39;useradd -D&#39;命令查看（其实就是/etc/default/useradd文件指定的）。默认操作的文件是:`/etc/passwd`、&#39;/etc/shadow&#39;、&#39;/etc/group&#39;和&#39;/home/username&#39;</code></pre><p><img src="/2019/11/17/linux用户及权限管理/img3.webp" alt="useradd命令默认设置,注意:useradd命令执行需要root权限，所以需要在root用户下执行才能查看。"></p><p>上图参数解释:<br><strong>GROUP=100</strong>表示的是在创建用户时使用的初始用户组的ID为100也就是<code>users</code>用户组，这个根据不同发行版而有不同的设置，总的来说就是两种用户组的机制不同。CentOS系统采用的是<strong>私有用户组机制</strong>:即在创建用户的时候会新建一个同名的用户作为该用户的初始用户组，且家目录的权限设置为700，除该路径的所有者外其他用户都不能使用该目录，使用这种机制不会考虑GROUP=100这个设定，较为安全。还有一种机制是<strong>公共用户组机制</strong>:即会参考GROUP=100这个设定，将<code>users</code>用户组作为新建用户的初始用户组。一般家目录预设的权限为:755，大家都可以分享家目录的内容。比如说:SuSE系统就是使用公共用户组策略。</p><p><strong>HOME=/home</strong>：这个参数指定的是创建家目录的基准目录。一般家目录与用户名同名。</p><p><strong>INACTIVE=-1</strong>：这个参数指定的是用户密码失效，0表示每次登录都要重新设定密码，-1表示密码永不失效，30表示设定的密码30天之后失效。</p><p><strong>EXPIRE</strong>:表示账户默认失效日期，为空的话表示账户永不失效。</p><p><strong>SHELL=/bin/bash</strong>:指定创建账户默认使用的SHELL。不允许用户登录系统则是使用<code>/bin/nologin</code></p><p><strong>SKEL=/etc/skel</strong>:表示新建家目录的参考基准目录，直接将目录中的内容拷贝到新目录中。<br><img src="/2019/11/17/linux用户及权限管理/img4.webp" alt="新建家目录基准目录"></p><p><strong>CREATE_MAIL_SPOOL=yes</strong>:该参数指定是否建立使用者的邮箱</p><p><strong>/etc/login.defs文件内容</strong></p><p><img src="/2019/11/17/linux用户及权限管理/img5.webp" alt="/etc/login.defs文件内容"></p><p>在文件中的参数大多数都有相应的解释，着重需要注意的几个参数就是：</p><pre><code class="bash">MAIL_DIR /var/spool/mail # 用户邮箱默认放置路径PASS_MAX_DAYS 9999 # 密码需要变更的最长时间PASS_MIN_DAYS 0    # 密码需要变更的最短时间PASS_MIN_LEN 5     # 密码的最小长度，已被pam模组取代，该参数已经失效,PAM模块相关资料:https://www.cnblogs.com/kevingrace/p/8671964.htmlPASS_WARN_AGE 7    # 密码失效前天数进行警告UID_MIN 1000       # 一般用户的起始UIDUID_MAX 60000      # 一般用户最大UIDSYS_UID_MIN 201    # 系统用户的起始UIDSYS_UID_MAX 999    # 系统用户的最大UIDGID_MIN 1000       # 用户组起始GIDGID_MAX 60000      # 用户组最大GIDSYS_GID_MIN 201    # 系统用户组其实GIDSYS_GID_MAX 999    # 系统用户组最大GIDCREATE_HOME yes    # 在不指定-m/-M时，默认创不创建家目录。UMASK 077          # 创建家目录时的umask，默认权限为700USERGROUPS_ENAB yes# 使用userdel删除用户时，删除初始用户组ENCRYPT_METHOD SHA512# 密码使用SHA512加密算法。</code></pre><p>所以使用useradd时默认会参考<code>/etc/default/useradd</code>、<code>/etc/login.defs</code>、<code>/etc/skel/*</code>这几个文件。</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>以下为<code>passwd</code>命令的使用:</p><pre><code class="bash">passwd [--stdin] [username]  # 所有用户都可以通过这样的方式修改自己的密码，当不指定用户时，默认修改自己的账号密码passwd [-l] [-u] [--stdin] [-S] [-n天数] [-x天数] [-w天数] [-i天数] 账户  # 只有root用户可用# 参数及选项# --stdin 可以透过来自前一个管线的资料# -l lock的意思，会在/etc/shadow中的密码密文前加!,封锁该用户登录# -u unlock的意思，解除用户的封锁# -S 列出密码相关参数，即/etc/shadow档案中的大部分资料# -n天数 不可修改密码天数# -x天数 密码有效天数# -w天数 密码失效前警告天数# -l天数 用户账户失效天数# -d 删除用户的密码</code></pre><p>例如如果要让<code>test1</code>用户7天修改一次密码的话，那么可以设置为:<code>passwd -x 7 test1</code>。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><h4 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h4><p>chage用法:</p><pre><code class="bash">chage -[ldEImMW] 用户名# 选项说明# -l 列出该用户的详细密码参数# -d 日期 设置/etc/passwd中修改密码的时间，一般是以1970年1月1日到想要日期的天数# -E 日期 格式为YYYY-MM-DD，账户失效日期# -I 天数 密码修改的宽限天数# -m 天数 密码不可修改的天数# -M 天数 密码有效天数# -W 天数 密码失效前天数警告</code></pre><p>假如我们希望用户在登陆的时候设置新密码，就可以这样创建用户，<code>useradd username &amp;&amp; echo ‘username’ | passwd --stdin username &amp;&amp; chage -M 0 -d 0 username</code>创建用户之后登录需要重新设置密码才能使用账户。</p><p><img src="/2019/11/17/linux用户及权限管理/img6.webp" alt="创建一个在登录时必须要重设密码的账户"></p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>当使用<code>useradd</code>命令设置了错误的参数或者遗忘了设置某种参数时，可以使用<code>usermod</code>命令，微调用户的参数。</p><pre><code class="bash">usermod [-cdegGlsuLU] username# 选项解释# -c 修改用户说明；# -m 将原家目录中的内容移到新家目录中，与-d一起使用；# -d home_path 修改用户登录后的家目录；# -e YYYYMMDD 指定用户账户失效日期；# -f 天数 用户密码失效之后宽限日期；# -g group 设置初始用户组；# -a 添加附加用户组，只能与-G选项一起用；# -G group[,group[,group[...]]] 设置账户所支援的群组；# -l username 设置用户新的用户名；# -u uid 设置用户的uid；# -o 设置非唯一的uid，与-u选项一起使用；# -p passwd 修改用户密码，不推荐这种方式修改密码，因为这种方式需要自己确保密码符合系统的密码策略；# -s shell 指定账户使用的shell# -L username 锁定用户账号# -U username 解锁用户账号</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>在linux系统中，删除用户账号使用<code>userdel</code>命令，用法如下:</p><pre><code class="bash">userdel [-fr] username# 参数解释# -f 强制删除用户，即使用户处于在线状态。同时也会删除用户的家目录和mail spool;# -r 删除账户的同时也删除家目录和mail spool.</code></pre><h3 id="用户自查"><a href="#用户自查" class="headerlink" title="用户自查"></a>用户自查</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>id</code>命令用于查询用户的uid和gid。</p><pre><code class="bash">id [选项] user# 选项解释# -</code></pre><h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h2><p>在linux的传统权限管理分为三种身份:所有者、用户组和其他。在设置限制或者允许单个用户访问文件时，存在着限制。</p><p>ACL时Access Control Lists的缩写，是Unix-Like系统的额外支援项目，主要是提供相较传统权限管理更加细粒的管理。主要是通过以下三个方面进行控制权限:</p><ol><li>使用者(user)：针对使用者进行权限限制；</li><li>群组(group):针对群组进行权限限制；</li><li>预设属性(mask):设置目录下新建使用的默认权限。</li></ol><p>在目前linux常用的分区类型(ext2/ext3/ext4/xfs等)默认acl挂载。虽然分区一般默认支持acl，但是还是需要相应的工具才能完全使用，一般使用<code>setfacl</code>和<code>getfacl</code>，如果提示找不到命令，在CentOS系统中可以在root用户下使用命令<code>yum install acl</code>安装。</p><h3 id="开启分区ACL权限"><a href="#开启分区ACL权限" class="headerlink" title="开启分区ACL权限"></a>开启分区ACL权限</h3><h4 id="临时开启分区ACL权限"><a href="#临时开启分区ACL权限" class="headerlink" title="临时开启分区ACL权限"></a>临时开启分区ACL权限</h4><p>重新挂载根分区:</p><p><code>mount -o remount,rcl /</code></p><p>临时开启acl分区在重启系统之后恢复到初始状态。</p><h4 id="永久开启分区ACL权限"><a href="#永久开启分区ACL权限" class="headerlink" title="永久开启分区ACL权限"></a>永久开启分区ACL权限</h4><p>修改<code>/etc/fstab</code>文件，在默认参数中添加acl选项。</p><p><img src="/2019/11/17/linux用户及权限管理/img7.webp" alt="添加acl选项"></p><p>保存修改后，重载分区或者重启系统生效。</p><h3 id="ACL权限设置"><a href="#ACL权限设置" class="headerlink" title="ACL权限设置"></a>ACL权限设置</h3><p>一般使用<code>getfacl</code>和<code>setfacl</code>两个工具完成ACL权限设置。</p><h4 id="setfacl"><a href="#setfacl" class="headerlink" title="setfacl"></a>setfacl</h4><pre><code class="bash">setfacl [-bkndRLPvh] [{-m|-x} acl_spec] [{-M|-X} acl_file] file# 参数与选项# -m 从命令行输入ACL条目进行更改# -M 从文件中读取ACL条目进行更改# -x 从命令行输入移除ACL条目# -X 从文件中读取ACL条目，并移除# -b 移除所有文件和目录的拓展ACL权限，仅保留所有者、群组和其他人权限设置；# -k 移除预设ACL权限；# -n 不重计算有效掩码# --mask 重计算有效掩码# -d 所有操作应用到ACL中# -R 应用到所有文件和路径# -L 按照系统逻辑，跟随符号连接# -P 按照自然逻辑，不跟随符号连接# -v 版本信息# -h help# --resotre 恢复权限备份# --test 测试模式，不修改任何权限# -- 命令模式结束标志# - 如果文件名称为‘-’，那么从标准输入读取文件列表。# ACL权限条目[d[efault]:] [u[ser]:]uid [:perms]# 设置用户权限[d[efault]:] g[roup]:gid [:perms]# 设置群组权限[d[efault]:] m[ask][:] [:perms]# 设置掩码[d[efault]:] o[ther][:] [:perms]# 设置其他人权限</code></pre><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>使用root创建test.txt文件，setfacl设置test的rw权限，代码如下：</p><p>root用户执行:</p><pre><code>touch test.txtsetfacl -mu:test:rw test.txt</code></pre><p><img src="/2019/11/17/linux用户及权限管理/img8.webp" alt="使用root用户创建文件，并且设置test用户的读写acl权限"></p><p>从上图中可以看出当设置了acl权限之后，权限部分最后变成了‘+’。</p><p><img src="/2019/11/17/linux用户及权限管理/img9.webp" alt="使用test账户测试，尝试写入以及读取test.txt文件"></p><p>设置<strong>群组、其他人</strong>的权限类似。</p><h4 id="getfacl"><a href="#getfacl" class="headerlink" title="getfacl"></a>getfacl</h4><p><code>getfacl</code>命令用于获取文件或则目录的acl权限信息。命令用法如下:</p><pre><code>getfacl path</code></pre><p><img src="/2019/11/17/linux用户及权限管理/img10.webp" alt="查看test.txt的acl信息"></p><h4 id="有效掩码"><a href="#有效掩码" class="headerlink" title="有效掩码"></a>有效掩码</h4><p>有效掩码设置方式<code>setfacl -mm:mask path</code>,有效掩码即在强制限制权限赋予范围，当赋予的权限不属于有效权限时则该权限无效。注意:<strong>默认在修改ACL权限时会重新计算有效掩码，可加入’-n’选项避免重新计算有效掩码</strong></p><p><img src="/2019/11/17/linux用户及权限管理/img11.webp" alt="有效掩码限制权限发放"></p><p>注意：权限只有所有者有权限修改(chmod)。而修改文件所有者(chown)只有root有权限修改。</p><h4 id="预设ACL权限"><a href="#预设ACL权限" class="headerlink" title="预设ACL权限"></a>预设ACL权限</h4><p>预设权限使得权限可以继承。如果一个目录设置了预设ACL权限，那么子目录下的权限都将继承预设权限。</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><p>root用户创建一个test文件夹，给test用户设置该目录预设读取权限，root在该目录下创建test.txt文件，并写入’hello world!’内容。然后退出root用户使用test用户读取该文件内容。</p><p><img src="/2019/11/17/linux用户及权限管理/img12.webp" alt="目录中的文件继承了预设ACL权限"></p><h3 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h3><p>在linux系统使用过程中，有时会使用不同的用户，就会使用到用户切换命令。</p><h4 id="切换身份的原因"><a href="#切换身份的原因" class="headerlink" title="切换身份的原因"></a>切换身份的原因</h4><ol><li>日常使用系统，使用一般用户；为了系统的安全，使用一般用户进行日常作业，当需要设定系统环境时，切换到root用户，这样操作相对安全，避免一些严重的误操作，例如<code>rm -rf /</code>。</li><li>使用较低较少的权限启动系统服务；例如系统安装apache软件，使用单独的apache用户，即使程序被攻破，系统还不至于崩溃。</li><li>软件本身的限制。在早期的talnet，程序预设是不允许root登录的，talnet会判断登录者的UID，如果登录者的UID为0，直接拒绝登入。因此只能使用一般用户登录系统。</li></ol><h4 id="一般用户切换为root用户方法"><a href="#一般用户切换为root用户方法" class="headerlink" title="一般用户切换为root用户方法"></a>一般用户切换为root用户方法</h4><ol><li><code>su -</code>，这个指令能从一般用户切换到root用户，但是需要输入root用户的密码，就是一般用户需要知道root用户的密码。</li><li><code>sudo</code>指令执行root指令，sudo使用需要事先进行设置，sudo使用的是自身账户的密码。在多人同时管理同一台linux系统时，使用<code>sudo</code>更加合适，可以有效避免root用户泄露。</li></ol><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p><code>su</code>是最简单的身份切换指令，可以进行任何身份的切换。使用方法如下:</p><pre><code class="bash">su [-lm] [-c指令] [username]# 选项和参数讲解# - 表示是以与真实登录类似的方式切换用户，清除目前的变量，重设主目录、当前shell、当前用户、登录名称、PATH变量；设置当前路径为主目录。# -l 和-类似，后面需要接欲切换的用户账号，也就是login-shell方式# -m -m和-p是类似的，表示使用目前的环境设定，不读取新用户的设定。# -c 进行一次指令执行，所以-c接上指令。# 默认情况下，su为以nologin-shell方式登录，PATH等变量都不会改变。# root用户切换到其他用户，不需要使用任何密码。</code></pre><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>sudo使用方法如下:</p><pre><code class="bash">sudo [-b] [-u新使用账号]# 选项和参数讲解# -b 将后续的指令放到背景中执行    而不会与当前的shell产生联系。# -u 后面接欲切换的用户，无指定则切换为root用户。</code></pre><p><strong>sudo执行流程</strong>：</p><ol><li>当使用sudo时，首先查询/etc/sudoers档案，查看该用户是否具有执行sudoers的权限；</li><li>当具有权限之后，让用户输入用户密码进行确认；</li><li>如果密码输入成功之后，便使用sudo执行后续指令（root使用sudo不需要输入密码）；</li><li>如果想切换的身份与执行者的身份相同时，不需要输入密码。</li></ol><h4 id="sudo设置"><a href="#sudo设置" class="headerlink" title="sudo设置"></a>sudo设置</h4><h5 id="visudo和-etc-sudoers"><a href="#visudo和-etc-sudoers" class="headerlink" title="visudo和/etc/sudoers"></a>visudo和/etc/sudoers</h5><p>是否具有sudo的权限是由/etc/sudoers文档决定的，所以要想给用户添加sudo权限就需要更改/etc/sudoers文件，由于文档有一定的语法并且设置错误会导致严重的错误，所以一般使用<code>visudo</code>进行设置。一般在退出设定时会检查文档的语法是否有错误。</p><p>visudo设置的方法有两种:</p><ol><li><p>对单一使用者设置sudo。<br>使用visudo命令打开sudo的配置文件：</p><pre><code class="bash"># 在root ALL=(ALL)ALL后一行添加如下内容:test ALL=(ALL)ALL# 参数讲解# 例如已有的: root ALL=(ALL)ALL# 用户名 登入者的来源主机名称=(可切换的身份)可下达的指令</code></pre></li><li><p>使用wheel群组和免密码功能处理visudo</p><p>使用visudo命令打开sudo的配置文件:</p><pre><code class="bash"># 将%wheel ALL=(ALL)ALL的注释去掉即可使wheel群组的用户都具有sudo权限,而新的用户只需添加到该群组就行.# 去除密码的设置如: %wheel ALL=(ALL) NOPASSWD: ALL</code></pre></li></ol><p><em>注意:</em>在指定能下达指令时,要使用绝对路径,并且多个命令使用英文逗号<code>,</code>分开.</p><h5 id="有限制的指令操作"><a href="#有限制的指令操作" class="headerlink" title="有限制的指令操作"></a>有限制的指令操作</h5><p>比如赋予了sudo能执行passwd的权限,但是如果直接给passwd命令权限则可能将root用户的密码修改导致root用户不能登录,因此需要限制用户修改root用户的密码.具体设置如下:</p><pre><code class="bash">test ALL=(root) !/usr/bin/passwd,/usr/bin/passwd [a-zA-Z]*,!/usr/bin/passwd root# !表示不能执行的指令,不能执行/usr/bin/passwd和/usr/bin/passwd root两个命令.</code></pre><h5 id="通过别名建置visudo"><a href="#通过别名建置visudo" class="headerlink" title="通过别名建置visudo"></a>通过别名建置visudo</h5><p>如果有15个用户需要添加到sudo权限中的话,除了使用用户组进行管理以外,还能通过别名建置获得sudo权限.假设需要将test1、test2、test3…test15一共15个用户添加到sudo中,并限制只能修改除root用户外用户的密码，除了使用用户组或者单个添加以外，还能使用如下设置：</p><pre><code class="bash">User_Alias TESTS=test1,test2,test3,test4,test5,test6,test7,test8,test9,test10,test11,test12,test13,test14,test15Cmnd_Alias TESTSCMD=!/usr/bin/passwd,/usr/bin/passwd [a-zA-Z]*,!/usr/bin/passwd rootTESTS ALL=(root) TESTSCMD</code></pre><p>添加之后即可使用户具有修改密码权限。</p><h5 id="sudo时间间隔"><a href="#sudo时间间隔" class="headerlink" title="sudo时间间隔"></a>sudo时间间隔</h5><p>两条sudo命令连着使用都需要输入密码，可以设置使用时间间隔不超过5分钟，不需要重新输入用户密码。设置如下:</p><pre><code class="bash"># 将默认的Defaults env_reset改为设置（5分钟为超时时间）：Defaults env_reset , timestamp_timeout=5</code></pre><h5 id="通过sudo将用户切换到root用户-非信任用户切勿使用"><a href="#通过sudo将用户切换到root用户-非信任用户切勿使用" class="headerlink" title="通过sudo将用户切换到root用户(非信任用户切勿使用)"></a>通过sudo将用户切换到root用户(非信任用户切勿使用)</h5><pre><code class="bash">User_Alias ADMINS=test1,test2ADMINS ALL=(root) /bin/su -</code></pre><h2 id="特殊的SHELL"><a href="#特殊的SHELL" class="headerlink" title="特殊的SHELL"></a>特殊的SHELL</h2><p>在安装linxu系统之时，会默认创建许多许多系统用户，例如，负责管理邮箱的mail用户等等，mail用户只是用于使用相关的资源，而不是用于登录linux系统，因此设置mail用户的密码，同时设置mail用户登录使用的shell为/sbin/nologin，这个shell为无法登录的合法shell。输入正确的账号密码登录之后会提示:</p><pre><code class="bash">This account is currently not available.</code></pre><h2 id="PAM模组"><a href="#PAM模组" class="headerlink" title="PAM模组"></a>PAM模组</h2><p>在以前，如果需要对用户进行认证，需要专门的程序判断用户和密码是否正确，那么就存在在同一个主机上存在多个不同的认证系统，可能会造成账户和密码不同步的问题，从而引入了PAM(Pluggable  Authentication Modules,可插拔认证模块)机制。PAM是一整套应用程序接口(Application Program Interface,API),提供一连串验证机制。PAM可实现使用者将验证过程的需求告知PAM，PAM即可返回相应的验证的结果。PAM既是一套验证机制，也可以提供其他软件调用验证，让账户的验证具有一致性。</p><p><img src="/2019/11/17/linux用户及权限管理/img13.webp" alt="PAM验证结构"></p><p>在系统中PAM作为API存在，需要PAM认证的程序即可调用该接口，经过一系列验证之后将结果返回，程序可以根据验证的结果做出相应的反应。PAM进行验证的信息成为模块(Modules)，每个PAM模块的功能不同。</p><h3 id="PAM模块设定语法"><a href="#PAM模块设定语法" class="headerlink" title="PAM模块设定语法"></a>PAM模块设定语法</h3><p>PAM由一个和程序名相同的设定文档确定认证流程。当执行<code>passwd</code>后，PAM运行的流程为:</p><ol><li>使用者调用passwd，并输入密码；</li><li>passwd程序调用PAM进行认证；</li><li>PAM到/etc/pam.d/中找与程序(passwd)同名的设定档；</li><li>依据/etc/pam.d/passwd文档的设定，调用相应的PAM模块进行验证；</li><li>将验证结果返回passwd程序；</li><li>passwd根据返回的结果做出相应的反应。</li></ol><p>因此，PAM中最重要的是验证的模块和/etc/pam.d/目录下的设定文档。以passwd的设定档（/etc/pam.d/passwd）为例:</p><pre><code class="bash">#%PAM-1.0   # PAM版本说明auth       include      system-auth     # 以后每一行都是一个验证的过程account    include      system-authpassword   substack     system-auth-password   optional    pam_gnome_keyring.so use_authtokpassword   substack     postlogin</code></pre><p>每一行都是一个独立的验证流程，每一行都可以分为三个部分，分别是验证类别(type)、控制标识(flag)和PAM模块和该模块的参数。</p><h4 id="验证类别-type"><a href="#验证类别-type" class="headerlink" title="验证类别(type)"></a>验证类别(type)</h4><p>验证类别主要分为4种:</p><ul><li><strong>auth</strong>:authentication的缩写，通常用于验证使用者的身份验证，通常需要使用密码来验证，所以后续接的模块一般验证使用者身份的。</li><li><strong>account</strong>:account(账户)一般是用于authorization（授权），主要用于检验使用者是否具有正确的使用权限。</li><li><strong>session</strong>:session就是会话的意思，所以session管理的是使用者在此次登入（或这个指令）期间，PAM所给予的环境设定。session一般会记录使用者登入和登出时的信息。比如，使用su命令和sudo命令可以在/var/log/secure中找到很多关于pam的说明。记录的资料都是session open和session close等。</li><li><strong>passwd</strong>:这种类别主要提供验证的修订工作，比如修改/变更密码等。</li></ul><h4 id="控制标识（control-flag"><a href="#控制标识（control-flag" class="headerlink" title="控制标识（control flag)"></a>控制标识（control flag)</h4><p>控制标志是指验证的过程中通过的标准，控制验证的放行标准，一般分为4中控制标志:</p><ul><li><strong>required</strong>:如果验证成功则带success标志，验证失败则带failure标志，无论验证成功还是验证失败都会进行后续的验证流程。由于后续的流程可以继续进行，相当于有利于资料的登录（log),这也是经常使用required的原因。</li><li><strong>requisite</strong>：如果验证失败立刻返回原程序failure标志，并且终止后续的验证流程。如果验证成功则带success标志并继续后续验证流程。</li><li><strong>sufficient</strong>:如果验证成功则立刻回传success给原程序。并终止后续验证流程：如果验证失败则带failure标志并继续后续验证流程。</li><li><strong>optional</strong>：大多数用在显示讯息，不用于验证。</li></ul><p><img src="/2019/11/17/linux用户及权限管理/img14.webp" alt="控制标志的验证流程"></p><h4 id="常用的PAM模块"><a href="#常用的PAM模块" class="headerlink" title="常用的PAM模块"></a>常用的PAM模块</h4><p>经常我们需要通过各种方式登入系统，因此看一下登入所需的PAM流程，即/etc/pam.d/login文档中的内容:</p><pre><code class="bash">#%PAM-1.0auth [user_unknown=ignore success=ok ignore=ignore default=bad] pam_securetty.soauth       substack     system-authauth       include      postloginaccount    required     pam_nologin.soaccount    include      system-authpassword   include      system-auth# pam_selinux.so close should be the first session rulesession    required     pam_selinux.so closesession    required     pam_loginuid.sosession    optional     pam_console.so# pam_selinux.so open should only be followed by sessions to be executed in the user contextsession    required     pam_selinux.so opensession    required     pam_namespace.sosession    optional     pam_keyinit.so force revokesession    include      system-authsession    include      postlogin-session   optional     pam_ck_connector.so</code></pre><p>在login文档中使用了很多次system-auth模块，此模块（/etc/pam.d/system-auth）的配置内容为：</p><pre><code class="bash">#%PAM-1.0# This file is auto-generated.# User changes will be destroyed the next time authconfig is run.auth        required      pam_env.soauth        required      pam_faildelay.so delay=2000000auth        sufficient    pam_unix.so nullok try_first_passauth        requisite     pam_succeed_if.so uid &gt;= 1000 quiet_successauth        required      pam_deny.soaccount     required      pam_unix.soaccount     sufficient    pam_localuser.soaccount     sufficient    pam_succeed_if.so uid &lt; 1000 quietaccount     required      pam_permit.sopassword    requisite     pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type=password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtokpassword    required      pam_deny.sosession     optional      pam_keyinit.so revokesession     required      pam_limits.so-session     optional      pam_systemd.sosession     [success=1 default=ignore] pam_succeed_if.so service in crond quiet use_uidsession     required      pam_unix.so</code></pre><p>详细的模块的信息在linux中都可以找到，常见的模块:</p><ul><li>每个程序的个别PAM设定档:/etc/pam.d/*;</li><li>PAM模块实际放置位置:/lib64/security/*;</li><li>其他PAM环境设定文档:/etc/security/*;</li><li>详细的PAM说明文档:/usr/share/doc/pam-*;</li></ul><p>这里列举几个常用的PAM模块：</p><ul><li><strong>pam_securetty.so</strong>:限制root用户只能从安全终端登录，而常见的安全的终端就是TTY1,TTY2等终端机装置名称。而安全的终端机设定是由/etc/securetty文档决定的。</li><li><strong>pam_nologin.so</strong>:限制一般使用者能否登入主机，当/etc/nologin这个文档存在时，则所有一般用户都不能登入系统，并且将其中的内容输出到登录的终端上。在正常的系统中不存在，但是该模块不能限制root及已经登录的用户。</li><li><strong>pam_selinux.so</strong>:SELinux是针对程序进行细部权限管理的功能，由于SELinux会影响到使用者执行程序的权限，因此我们利用PAM模块，暂时将SELinux暂时关闭，验证通过后再打开。</li><li><strong>pam_console.so</strong>:当系统出现问题或者需要通过特殊终端登陆系统时，该模块可以处理一些档案的权限问题，让使用者可以通过特殊终端登入系统。</li><li><strong>pam_loginuid.so</strong>:通过用户UID，验证一般账号和系统账号。</li><li><strong>pam_env.so</strong>:用于设定环境变量的模块，如果你有需要额外的环境变量设定，可以参考/etc/security/pam_env.conf这个档案。</li><li><strong>pam_unix.so</strong>：该模组很复杂也很重要，该模组可以用于验证阶段的认证功能，可以用在授权阶段的用户授权管理，也可以用在会话阶段的登录档记录，甚至可以用在密码更新阶段的检验。</li><li><strong>pam_pwquanlity.so</strong>：该模块用于检验密码强度。包括密码是否存在于字典中，密码输入几次失败就断掉此次连线的功能，都可以由该模块提供的。最早之前使用的是pam_cracklib.so这个模组，后改为pam_pwquanlity.so模组。但是该模组完全兼容于之前的pam_cracklib.so模组。</li><li><strong>pam_limits.so</strong>:提供ulimit功能，设定档参考/etc/security/limits.conf。</li></ul><h5 id="limits-conf"><a href="#limits-conf" class="headerlink" title="limits.conf"></a>limits.conf</h5><p>limits.conf这个文件对用户使用的资源进行限制。一般账号资源限制格式如下:</p><pre><code class="bash">test soft fsize 1000test hard fsize 9000</code></pre><p>账号限制栏分为4栏，第一栏为账号，如果是群组限制则在群组名称前加@符号；</p><p>第二栏为对限制的要求，soft为警告，hard为严格。</p><p>第三栏为限制的内容，这里使用的限制档案的容量。</p><p>第四栏为限制的值，这里使用的单位为KB。</p><p>限制test用户登录的最大连接数为1，设置为:</p><pre><code class="bash">test hard maxlogins 1</code></pre><p>因为PAM只用在验证的时候才使用，对于已经登入的用户没有作用。所以修改过的资料需要用户重新登入才能使设置生效。</p><h2 id="使用者的信息传递"><a href="#使用者的信息传递" class="headerlink" title="使用者的信息传递"></a>使用者的信息传递</h2><p>使用同一台电脑的不同用户之间的沟通，查看不同用户的信息。</p><h3 id="查询使用者，w，who，last，lastlog"><a href="#查询使用者，w，who，last，lastlog" class="headerlink" title="查询使用者，w，who，last，lastlog"></a>查询使用者，w，who，last，lastlog</h3><p>通过<code>w</code>或者<code>who</code>命令就可以查询到目前在线的用户。</p><p>想要查询到最近用户的登录的时间，可以使用<code>lastlog</code>命令，该指令是去读去/var/log/lastlog文档。</p><h3 id="使用者之间交流，write，mesg，wall"><a href="#使用者之间交流，write，mesg，wall" class="headerlink" title="使用者之间交流，write，mesg，wall"></a>使用者之间交流，write，mesg，wall</h3><p>利用<code>write</code>指令可以直接将信息传递给接受者。命令格式如下:</p><pre><code class="bash">write 用户名称 [用户所使用的终端]</code></pre><p>当在该指令中输入消息，回车之后会立马将该消息传递给指定用户，如果用户在做其他任务，突然出现的消息会将工作打乱，因此可以通过<code>mesg n</code>命令选择不接收消息。即使选择不接收消息，但是对于root用户的消息不受该选项的影响，会直接传递给用户。</p><p>广播则使用<code>wall</code>指令，命令使用的方法:</p><pre><code class="bash">wall &#39;消息内容&#39;</code></pre><h3 id="使用者的邮箱"><a href="#使用者的邮箱" class="headerlink" title="使用者的邮箱"></a>使用者的邮箱</h3><p>使用write、wall命令都需要用户在线才能接收到消息，除此以外还能通过mail传递信息到用户。使用<code>mail -s &quot;邮件标题&quot; username@localhost</code>命令即可开始编写邮件并发送邮件，编辑完邮件之后使用单独一行<code>.</code>表示邮件内容的结束。</p><p>mail常使用的命令:</p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">列出信件标头；如果要查阅40 封信件左右的信件标头，可以输入<code>h 40</code></td></tr><tr><td align="center">d</td><td align="center">删除后续接的信件号码，删除单封是<code>d10</code>，删除20~40 封则为<code>d20-40</code>。不过，这个动作要生效的话，必须要配合q 这个指令才行(参考底下说明)！</td></tr><tr><td align="center">s</td><td align="center">将信件储存成档案。例如我要将第5 封信件的内容存成~/mail.file:<code>s 5 ~/mail.file</code></td></tr><tr><td align="center">x</td><td align="center">或者输入exit 都可以。这个是’不作任何动作离开mail 程式’的意思。不论你刚刚删除了什么信件，或者读过什么，使用exit 都会直接离开mail，所以刚刚进行的删除与阅读工作都会无效。如果您只是查阅一下邮件而已的话，一般来说，建议使用这个离开啦！除非你真的要删除某些信件。</td></tr><tr><td align="center">q</td><td align="center">相对于exit 是不动作离开， q 则会实际进行你刚刚所执行的任何动作(尤其是删除！)</td></tr></tbody></table><h2 id="Centos下建立大量账号"><a href="#Centos下建立大量账号" class="headerlink" title="Centos下建立大量账号"></a>Centos下建立大量账号</h2><p>在Linux下创建大量的用户，需要检查用户创建是否存在问题，那么这个时候就需要使用工具进行辅助设置。</p><h3 id="一些用户相关的检查工具"><a href="#一些用户相关的检查工具" class="headerlink" title="一些用户相关的检查工具"></a>一些用户相关的检查工具</h3><h4 id="pwck"><a href="#pwck" class="headerlink" title="pwck"></a>pwck</h4><p>这个指令用于检查/etc/passwd文档中用户的设定信息，以及家目录实际存在等等信息。甚至还可以比对/etc/passwd、/etc/shadow中的信息是否一致，如果存在问题，则提示修改。</p><p><img src="/2019/11/17/linux用户及权限管理/img15.webp" alt="pwck指令检查结果"></p><p>以上为pwck检查结果，检查结果为系统用户存在部分错误，这些错误属于正常的错误，不用解决。对应的群组检查命令使用<code>grpck</code>命令。</p><h4 id="pwconv"><a href="#pwconv" class="headerlink" title="pwconv"></a>pwconv</h4><p>这个命令主要用于将/etc/passwd中的密码信息移动到/etc/shadow中，一般用在较旧的系统上，为了安全考虑，将密码从/etc/passwd中转移到/etc/shadow中。</p><h4 id="pwunconv"><a href="#pwunconv" class="headerlink" title="pwunconv"></a>pwunconv</h4><p>这个命令恰好相反，将/etc/shadow中的密码写回到/etc/passwd中，并且删除/etc/shadow档案。</p><h4 id="chpasswd"><a href="#chpasswd" class="headerlink" title="chpasswd"></a>chpasswd</h4><p>这个命令可以读入未加密的密码，并把这个密码写入到/etc/shadow中去，这个命令常常使用在大量建构用户的工作中去。读入资料的格式为”用户名:密码”。例如:</p><pre><code class="bash">echo &#39;test:123456&#39; | chpasswd</code></pre><h3 id="大量建置用户的办法-passwd-–stdin"><a href="#大量建置用户的办法-passwd-–stdin" class="headerlink" title="大量建置用户的办法(passwd –stdin)"></a>大量建置用户的办法(passwd –stdin)</h3><p>可以通过脚本使用<code>passwd --stdin</code>大量建置用户</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>伪用户资料:<a href="https://blog.csdn.net/Add_a_cat/article/details/97614942" target="_blank" rel="noopener">https://blog.csdn.net/Add_a_cat/article/details/97614942</a></p><p>开启分区ACL权限:<a href="https://www.cnblogs.com/ysocean/p/7801329.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/7801329.html</a></p><p>setfacl参数详解:<a href="https://www.cnblogs.com/ftl1012/p/setfacl.html" target="_blank" rel="noopener">https://www.cnblogs.com/ftl1012/p/setfacl.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 用户 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自编shell命令</title>
      <link href="/2019/11/15/%E8%87%AA%E7%BC%96shell%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/15/%E8%87%AA%E7%BC%96shell%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇博客是记录我在使用lnux时写的一些shell命令或者脚本</p><h2 id="创建一个临时的脚本文件"><a href="#创建一个临时的脚本文件" class="headerlink" title="创建一个临时的脚本文件"></a>创建一个临时的脚本文件</h2><p>举例:<code>cns script.sh</code></p><pre><code class="bash">alias cns=&#39;[ ! -e /tmp/shell ] &amp;&amp; mkdir /tmp/shell; cd /tmp/shell &amp;&amp; vim&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell_script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell中的判断式</title>
      <link href="/2019/11/14/shell%E4%B8%AD%E7%9A%84%E5%88%A4%E6%96%AD%E5%BC%8F/"/>
      <url>/2019/11/14/shell%E4%B8%AD%E7%9A%84%E5%88%A4%E6%96%AD%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在shell中不免会测试字符串是否为空、文件是否存在和文件是否为空等等。完成这些功能就需要使用到shell中的判断式。</p><h2 id="test命令进行判断"><a href="#test命令进行判断" class="headerlink" title="test命令进行判断"></a>test命令进行判断</h2><h3 id="某个路径的类型判断"><a href="#某个路径的类型判断" class="headerlink" title="某个路径的类型判断"></a>某个路径的类型判断</h3><p>举例：<code>test -e filename</code></p><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">测试该路径是否存在</td></tr><tr><td align="center">-f</td><td align="center">该路径是否存在且为文件</td></tr><tr><td align="center">-d</td><td align="center">该路径是否存在且为目录</td></tr><tr><td align="center">-b</td><td align="center">该路径是否存在且为block device</td></tr><tr><td align="center">-c</td><td align="center">该路径是否存在且为character device</td></tr><tr><td align="center">-S</td><td align="center">该路径是否存在且为Socket文件</td></tr><tr><td align="center">-p</td><td align="center">该路径是否存在且为PIPE文件</td></tr><tr><td align="center">-L</td><td align="center">该路径是否存在且为一个连结文件</td></tr></tbody></table><h3 id="路径的权限判断"><a href="#路径的权限判断" class="headerlink" title="路径的权限判断"></a>路径的权限判断</h3><p>举例:<code>test -r filename</code></p><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">判断路径是否存在且可以读</td></tr><tr><td align="center">-w</td><td align="center">判断路径是否存在且可写</td></tr><tr><td align="center">-x</td><td align="center">判断路径是否存在且可执行</td></tr><tr><td align="center">-u</td><td align="center">判断路径是否存在且具有SUID属性</td></tr><tr><td align="center">-g</td><td align="center">判断路径是否存在且具有SGID属性</td></tr><tr><td align="center">-k</td><td align="center">判断路径是否存在且具有sticky bit属性</td></tr><tr><td align="center">-s</td><td align="center">判断文档是否存在且为非空</td></tr></tbody></table><h3 id="两个文件之间比较"><a href="#两个文件之间比较" class="headerlink" title="两个文件之间比较"></a>两个文件之间比较</h3><p>举例:<code>test file1 -nt file2</code></p><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">两数值相等(不可以扩展到字符串比较)</td></tr><tr><td align="center">-ne</td><td align="center">两数值不相等</td></tr><tr><td align="center">-gt</td><td align="center">大于</td></tr><tr><td align="center">-lt</td><td align="center">小于</td></tr><tr><td align="center">-ge</td><td align="center">大于等于</td></tr><tr><td align="center">-le</td><td align="center">小于等于</td></tr></tbody></table><h3 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h3><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>test -z string</code></td><td align="center">判断字符串是否为空</td></tr><tr><td align="center"><code>test -n string</code></td><td align="center">判断字符串是否为非空</td></tr><tr><td align="center"><code>test str1 == str2</code></td><td align="center">判断两字符串是否相等</td></tr><tr><td align="center"><code>test str1 != str2</code></td><td align="center">判断两字符串是否不相等</td></tr></tbody></table><h3 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h3><p>举例:<code>test -r filename -a -x filename</code></p><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">and,两者判断成立的时候才返回true</td></tr><tr><td align="center">-o</td><td align="center">or,两者条件成立一个就返回true</td></tr><tr><td align="center">!</td><td align="center">not,相反才返回true，例如:<code>test ! -x filename</code></td></tr></tbody></table><h2 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号[]"></a>判断符号[]</h2><p>使用判断符号和使用使用<code>test</code>命令基本上是一样的，注意使用判断符号时的空格十分重要。举例<code>[▢1▢lt▢2▢]</code>（▢表示空格符号），特别注意例子中所有的分隔都是通过空格间隔的，尤其是中括号相邻的空格符号一定要注意用上。标志使用和test命令的无差别。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜:<a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php#ex_cal" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0340bashshell-scripts.php#ex_cal</a></p><p>判断符号[]补充资料来源:<a href="https://blog.csdn.net/qq_41586263/article/details/83014853" target="_blank" rel="noopener">https://blog.csdn.net/qq_41586263/article/details/83014853</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 判断式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用linux命令列表</title>
      <link href="/2019/11/12/%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/"/>
      <url>/2019/11/12/%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客中主要用于记录linux中常用到的命令.</p><h2 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h2><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">ls</td><td align="center">查看当前目录下的文件</td><td align="center"></td></tr><tr><td align="center">$(命令)</td><td align="center">小指令</td><td align="center"></td></tr><tr><td align="center">$((string))</td><td align="center">和数值运算等有关</td><td align="center"></td></tr><tr><td align="center">ip</td><td align="center">显示或管理网络相关的路由、设置等</td><td align="center"></td></tr><tr><td align="center">touch</td><td align="center">修改文件的时间戳</td><td align="center"></td></tr><tr><td align="center">declare</td><td align="center">申明shell变量(shell内建指令)</td><td align="center"></td></tr><tr><td align="center">bc</td><td align="center">命令行计算器</td><td align="center"></td></tr><tr><td align="center">test</td><td align="center">判断路径是否存在</td><td align="center"></td></tr><tr><td align="center">netstat</td><td align="center">获取网络状态</td><td align="center">netstat属于net-tools中的一个工具，如果找不到命令的话，需要安装net-tools.</td></tr><tr><td align="center">seq</td><td align="center">以指定增量从首数打印数字到尾数</td><td align="center"><code>seq [首数 [增量]] 尾数</code>可以使用shell内建机制实现:<code>{1..10}</code></td></tr><tr><td align="center">cut</td><td align="center">摘取每行指定的字符</td><td align="center"></td></tr><tr><td align="center">awk</td><td align="center"><a href="/2019/10/18/awk工具/" title="awk工具">awk工具</a></td><td align="center"></td></tr><tr><td align="center">sed</td><td align="center"><a href="/2019/10/08/sed工具/" title="sed工具">sed工具</a></td><td align="center"></td></tr></tbody></table><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ul><li><p>重启网络<code>/etc/init.d/network restart</code></p></li><li><p>停止网络<code>/etc/init.d/network stop</code></p></li><li><p>切换到root用户<code>su -</code>;切换到其他用户<code>su username -</code></p></li><li><p>重启服务<code>systemctl restart servicename</code></p></li><li><p>服务开机自启<code>systemctl enable servicename</code></p></li><li><p>查看服务状态<code>systemctl status servicename</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell script</title>
      <link href="/2019/11/11/shell-script/"/>
      <url>/2019/11/11/shell-script/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shell script是在shell中使用的一种脚本语言，是纯文本文档，通过shell去执行脚本。shell script通常可以应用在服务器自动化管理、简单资料的自动化处理、复杂命令单一化和服务器安全稳定性管理等方面。shell script可以帮助我们更好的使用linux系统，但是也存在着局限性。shell script不适合做大量数据处理和运算，shell script属于解释执行类语言，并且运行过程中调用的命令常常会有系统调用和外部库引用，导致占用资源高而执行效率低。我们使用shell script大多数是在管理计算机，对效率要求不高，所以能够成为我们熟练使用linux的有用工具之一。</p><h2 id="执行shell-script"><a href="#执行shell-script" class="headerlink" title="执行shell script"></a>执行shell script</h2><ol><li>直接执行（注意需要具有rx权限）：<ul><li>绝对路径执行:<code>/home/user/script.sh</code>；</li><li>相对路径路径执行:<code>./script.sh</code>；</li><li>PATH路径执行:脚本位于PATH路径下，<code>script.sh</code>。</li></ul></li><li>bash程序执行:<code>bash script_path</code>或者<code>sh script_path</code>。</li></ol><h2 id="shell-script中的一些默认规则"><a href="#shell-script中的一些默认规则" class="headerlink" title="shell script中的一些默认规则"></a>shell script中的一些默认规则</h2><ol><li>命令的执行是自上而下，从左到右执行的；</li><li>script中指令、参数和选项之间的多个空格会被忽略成一个空格；</li><li>Tab键被视为空白符号，空白行会被忽略；</li><li>当读到换行时会执行该行的命令，但是当使用\+Enter组合时表示该行命令未结束，表示该行的内容太多，延伸到下一行；</li><li>注释使用’#’，只能注释一行的内容。</li></ol><h2 id="编写程序应该养成较好的习惯"><a href="#编写程序应该养成较好的习惯" class="headerlink" title="编写程序应该养成较好的习惯"></a>编写程序应该养成较好的习惯</h2><p>在文档的开头应该做上相应的记录:</p><ol><li>实现的功能</li><li>版本</li><li>作者及其联系方式</li><li>版权</li><li>修改记录</li><li>较为特别的命令使用绝对路径调用</li><li>需要使用到环境变量的需要先声明和设定</li></ol><h2 id="shell-script常见的命令"><a href="#shell-script常见的命令" class="headerlink" title="shell script常见的命令"></a>shell script常见的命令</h2><table><thead><tr><th align="center">命令</th><th align="center">格式</th><th align="center">示例</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">echo string</td><td align="center">echo ‘hello world’</td><td align="center">输出一行文本</td></tr><tr><td align="center">read</td><td align="center">read -p string variable</td><td align="center">read -p ‘your name?:’ name</td><td align="center">标准输入中读入数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="脚本不同执行方式的差别"><a href="#脚本不同执行方式的差别" class="headerlink" title="脚本不同执行方式的差别"></a>脚本不同执行方式的差别</h2><ol><li>直接执行脚本：使用<code>bash script.sh</code>执行脚本，会在当前的bash中使用新的bash环境执行脚本，所有在脚本中产生的变量，会随着脚本执行完毕，bash读到文件EOF退出而消失。</li><li>使用<code>source script.sh</code>执行脚本则相反，相当该脚本由当前的bash环境执行，不需要打开新的环境，执行之后bash环境也不会退出，因此脚本中使用的变量还是存在。</li></ol><h2 id="shell-script的预设变量"><a href="#shell-script的预设变量" class="headerlink" title="shell script的预设变量"></a>shell script的预设变量</h2><pre><code class="bash">/path/to/scriptname opt1 opt2 opt3 ....               $0    $1   $2   $3   ...</code></pre><p>执行脚本档名可以用<code>$0</code>表示，第一个参数用<code>$1</code>表示、第二个参数用<code>$2</code>表示、第三个参数用<code>$3</code>表示…。</p><h3 id="变量偏移"><a href="#变量偏移" class="headerlink" title="变量偏移"></a>变量偏移</h3><p>使用<code>shift</code>命令即可将变量进行偏移。</p><h2 id="条件判断式"><a href="#条件判断式" class="headerlink" title="条件判断式"></a>条件判断式</h2><p>首先注意用到shell中的判断式：<a href="/2019/11/14/shell中的判断式/" title="shell中的判断式">shell中的判断式</a>，这里不同的是条件判断式是’if…then’这样的形式。</p><h3 id="if…then"><a href="#if…then" class="headerlink" title="if…then"></a>if…then</h3><h4 id="简单的条件判断"><a href="#简单的条件判断" class="headerlink" title="简单的条件判断"></a>简单的条件判断</h4><pre><code class="sh">    if [条件判断式]:then        条件满足执行    fi</code></pre><p>中括号之间可以使用&amp;&amp;和||连接多个条件</p><p>例如:</p><pre><code class="sh">if [条件判断式] &amp;&amp; [条件判断式] &amp;&amp; [条件判断式]:then    条件满足执行fi</code></pre><h4 id="多重复杂条件判断"><a href="#多重复杂条件判断" class="headerlink" title="多重复杂条件判断"></a>多重复杂条件判断</h4><pre><code class="sh">if [条件判断式]: then    命令else    命令fi</code></pre><p>更复杂的条件判断</p><pre><code class="sh">if [条件判断式]: then    命令elif []: then    命令else    命令fi</code></pre><h3 id="case…esac"><a href="#case…esac" class="headerlink" title="case…esac"></a>case…esac</h3><p>这种条件判断式的主要格式为：</p><pre><code class="sh">case $变量名称 in     # case式关键词    &quot;第一个变量内容&quot;)        命令        ;;    &quot;第二个变量内容&quot;)        命令        ;;    *)          # 不包含变量内容        命令        exit 1        ;;esac</code></pre><h2 id="function功能"><a href="#function功能" class="headerlink" title="function功能"></a>function功能</h2><p>函数功能使用格式</p><pre><code class="sh"># 创建函数姿势1function fname() {    命令}# 创建函数姿势2fname() {    命令}</code></pre><p>函数内建变量:在使用调用函数的时候传入参数即可使用函数的参数功能，调用形式:<code>fun par1 par2 ...</code>，在函数内使用预设变量即可获得参数的内容:<code>$1 $2 $3</code></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>当需要重复执行某个操作时可以使用循环结构实现。</p><h3 id="while-do-done-until-do-done"><a href="#while-do-done-until-do-done" class="headerlink" title="while do done, until do done"></a>while do done, until do done</h3><h4 id="while-do-done"><a href="#while-do-done" class="headerlink" title="while do done"></a>while do done</h4><p>使用方式:</p><pre><code class="sh">while [条件判断式]  # 条件成立循环do    命令done</code></pre><h4 id="until-do-done"><a href="#until-do-done" class="headerlink" title="until do done"></a>until do done</h4><p>使用方式:</p><pre><code class="sh">until [条件判断式]  # 条件不成立循环do    命令done</code></pre><h3 id="for…do…done"><a href="#for…do…done" class="headerlink" title="for…do…done"></a>for…do…done</h3><p>使用方式:</p><pre><code class="sh"># for循环姿势1for var in con1 con2 con3 ...do    命令done# for循环姿势2for ((初始值;执行条件;执行步骤)) # 和其他语言的for类似,初始值为赋初值，执行条件为判断是否满足循环要求，执行步骤为做完一次循环操作之后所要进行的步骤。do    命令done</code></pre><h2 id="script的调试和排错"><a href="#script的调试和排错" class="headerlink" title="script的调试和排错"></a>script的调试和排错</h2><pre><code class="bash">bash [-nvx] script.sh# 参数说明# -n 不执行脚本，仅检查是否有语法错误# -v 首先输出脚本内容再执行# -x 执行到哪一步将哪一步命令输出</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li><p>script的‘hello word’</p><pre><code class="sh"> #! /bin/bash # program # this program shows &#39;hello word&#39; on the screen. # name: shell.sh # history: # 2019/11/11 8315 create the script. echo &#39;hello world\n&#39; exit 0</code></pre><p> 脚本的第1行为指定脚本的执行程序；<br> 脚本的第2~6行为对该脚本的说明，方便之后对脚本进行修改；<br> 脚本的第7行为输出字符串行；<br> 脚本的第8行表示该脚本正常退出，返回值为0。<br> 运行命令<code>bash shell.sh</code>执行结果:<br> <img src="/2019/11/11/shell-script/img1.webp" alt="shell script的第一个hello world"></p></li><li><p>交互式脚本</p><pre><code class="sh"> #! /bin/bash # program # get your name and  age # name: interact.sh # history # 2019/11/12 8315 create this script echo &quot;I&#39;m glad to meet you!&quot; read -p $&#39;I\&#39;m 8315.Can I get your Name?\n&#39; name read -p $&#39;I\&#39;m 18 years old. What\&#39;s you?\n&#39; age echo &quot;${name},it&#39;s nice to meet you!&quot; exit 0</code></pre><p> 命令的前6行为该脚本的一些基本信息,便于以后修改<br> 第8行的字符串前面加’$’是为了在字符串中能使用转义字符.<br> 第10行的’${name}’表示使用name变量的内容<br> <img src="/2019/11/11/shell-script/img2.webp" alt="交互式脚本"></p></li><li><p>创建带日期的文件</p><pre><code class="sh"> #! /bin/bash # program # use date as the filename to create file.  Ps:filename_20191112 # name: createfile.sh # history: # 2019/11/12 8315 create this script echo &quot;I will use &#39;touch&#39; command to create file.&quot; read -p &#39;Please enter filename:&#39; filename  # 提示输入 # 判断文件名是否为空 if [[ -z &quot;$filename&quot; ]] then         echo &#39;empty filename!&#39;         exit 1 fi sdate=$(date +%Y%m%d) filename=${filename}&#39;_&#39;&quot;$sdate&quot; # 创建文件 touch &quot;$filename&quot; exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img3.webp" alt="创建文件名中带日期的文件"><br> 文件判断之后再讲解。</p></li><li><p>简单数值运算<br> 创建一个脚本使得两数相乘</p><pre><code class="sh"> #! /bin/bash # program # Input two integers. The program will get the product of two nums. # name: mutiply.sh # history: # 2019/11/13 8315 create this script. echo &#39;Input two integers. You will get the product of two nums.&#39; read -p &#39;the first integer:&#39; firstnum read -p &#39;the second integer:&#39; secondnum echo -e &quot;compute by \$(()):&quot; echo $((${firstnum}*${secondnum})) echo -e &quot;\ncompute by declare:&quot; declare -i result=${firstnum}*${secondnum} echo &quot;$result&quot; echo -e &quot;\ncompute by bc:&quot; echo ${firstnum}*${secondnum} | bc exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img4.webp" alt="通过三种方式计算两个整数的积"></p></li><li><p>判断路径是否存在的脚本</p><pre><code class="sh"> #! /bin/bash # program # determine whether the path exsits # name: determine,sh # history: # 2019/11/15 8315 create the script read -p &#39;please input the determined path:&#39; dpath ( [ -z ${dpath} ] &amp;&amp; echo &#39; erro:input empty string&#39; ) || ( [ -e ${dpath} ] &amp;&amp; echo &#39;path exists&#39; || echo &#39;path not exsits&#39; )</code></pre><p>​      判断式相关:<a href="/2019/11/14/shell中的判断式/" title="shell中的判断式">shell中的判断式</a></p></li><li><p>使用脚本中的预设变量</p><pre><code class="sh"> #! /bin/bash # program # use 3 preset parameter # name: presetparameter.sh # history: # 2019/11/15 8315 create this script echo &#39;this script called by:&#39;${0} echo &#39;three parameters is:&#39;${1} ${2} ${3} exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img5.webp" alt="脚本中使用预设变量"></p></li><li><p>预设变量偏移</p><pre><code class="sh"> #! /bin/bash # program # shift the preset parameters # name: shift preset parameters # history: # 2019/11/15 8315 create this script echo &quot;Total parameters num is:$#&quot; echo &quot;Your whole parameters is:$@&quot; # first shift echo &#39;first shift&#39; shift echo &quot;Total parameters num is:$#&quot; echo &quot;Your whole parameters is:$@&quot; # second shift echo &#39;second shift&#39; shift echo &quot;Total parameters num is:$#&quot; echo &quot;Your whole parameters is:$@&quot; # third shift echo &#39;third shift&#39; shift echo &quot;Total parameters num is:$#&quot; echo &quot;Your whole parameters is:$@&quot; exit 0</code></pre><p> “$#”表示预设变量总数，”$@”表示所有变量</p><p> <img src="/2019/11/11/shell-script/img6.webp" alt="预设变量偏移"></p></li><li><p>通过预设变量给函数传入参数</p><p> 函数传入多个参数，最多打印3个参数内容</p><pre><code class="sh"> #! /bin/bash # program # print parameters of function # name: funparameter.sh # history: # 2019/11/16 8315 create the script. printpara() {     case ${#} in         &quot;0&quot;)             echo &quot;no parameter!&quot;             ;;         &quot;1&quot;)             echo &quot;only one parameter:$1&quot;             ;;         &quot;2&quot;)             echo &quot;two parameters is:$1 $2&quot;             ;;         *)             echo &quot;three or more parameters, but I print the first three parameters: $1 $2 $3&quot;             ;;     esac } printpara 1 2 3 4 5 6 exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img7.webp" alt="函数参数传递"></p></li><li><p>通过/etc/passwd提取所有的用户</p><pre><code class="sh"> #! /bin/bash # program # get all users from /etc/passwd # name: getusers.sh # history: # 2019/11/16 8315 create the script. users=$(cat /etc/passwd | grep &#39;/bin/bash&#39; | cut -d &#39;:&#39; -f1)  # grep是为了过滤掉不需要的部分 # loop for printing all users echo &quot;User list:&quot; for username in ${users} do     echo ${username} done exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img8.webp" alt="获取所有的用户名称"></p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜-第十三章:&lt; <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0340bashshell-scripts.php</a> &gt;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell-script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程</title>
      <link href="/2019/10/31/%E5%8D%8E%E7%A1%95%E9%A3%9E%E8%A1%8C%E5%A0%A1%E5%9E%92fx50j%E5%8A%A0%E5%9B%BA%E6%80%81%E3%80%81%E6%B8%85%E7%81%B0%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%A1%85%E8%84%82%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/10/31/%E5%8D%8E%E7%A1%95%E9%A3%9E%E8%A1%8C%E5%A0%A1%E5%9E%92fx50j%E5%8A%A0%E5%9B%BA%E6%80%81%E3%80%81%E6%B8%85%E7%81%B0%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%A1%85%E8%84%82%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看着我2015年购入的笔记本电脑，使用差不多4年的时间了，至今没有进行过清灰和更换硅脂。最近电脑的温度偏高，估计是内部灰尘积累和硅脂已经完全干了的原因，更加坚定要拆机维护的想法。再加上最近”双十一“临近，正好看重的硬盘有优惠，萌生了给电脑进行加固态、清灰和换硅脂的想法。</p><h2 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h2><ul><li>由于这台电脑只有一个硬盘位，因此要加装固态硬盘要么使用的单个大容量固态硬盘，要么使用光驱位硬盘托架将原有的机械硬盘放到光驱位。考虑到预算，选择<strong>机械硬盘+固态硬盘</strong>的方案。原光驱接口采用的是SATA2的接口，固态硬盘在该接口下无法充分发挥性能，因此选择将机械硬盘放置到光驱位，用于电脑中存储文件等用处。</li><li>固态硬盘通过网络的多方了解，考虑到稳定第一的需求，选择了<strong>samsung 250G 860 evo</strong>。（下面会仔细分析为啥选择这款固态。）</li><li>通过度娘，了解到普通光驱位硬盘托架可能在电脑重启的时候会导致硬盘的c0值增加。c0值表示硬盘不安全掉电次数，不安全掉电可能会导致机械硬盘产生坏道，固态硬盘丢失数据甚至会损坏硬盘。考虑到机械硬盘的数据安全，选择了一款有掉电保护的硬盘托架——<strong>佳翼H95</strong>。</li><li>在选择硅脂时，在网络上了解了硅脂的选择，考虑到笔记本散热的局限性，选择了质量较好的老牌发烧友常用的<strong>猫头鹰NT-H1</strong></li><li>而拆机工具使用了目前手边有的工具以及购买时赠送的工具。</li></ul><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img1.webp" alt="大合照"></p><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img2.webp" alt="samsung 250G 860 evo"></p><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img3.webp" alt="佳翼H95光驱位硬盘托架"></p><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img4.webp" alt="猫头鹰NT-H1散热硅脂"></p><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img5.webp" alt="清灰使用的毛刷"></p><h2 id="关于固态硬盘"><a href="#关于固态硬盘" class="headerlink" title="关于固态硬盘"></a>关于固态硬盘</h2><p>在民用级固态硬盘中三星是最好用了（当然还有英特尔的固态硬盘，但是目前英特尔基本上都是企业级的固态硬盘，目前还暂时不考虑），无论是从稳定性方面以及性能方面来说都是做得比较好的。通过<a href="http://tieba.baidu.com/f?kw=固态硬盘" target="_blank" rel="noopener">固态硬盘吧</a>了解到目前比较推荐的SATA固态硬盘有三星的860evo、闪迪的utral 3d、西数的blue 3d NAND、英睿达的MX500和东芝的tr200。三星的质量和性能是最好的；闪迪的性能比较好，寿命相对要低一点；西数的蓝盘固态性能较好，寿命相对三星要差一点；英睿达的MX500相对要便宜很多，网上也有很多说这款固态掉盘的问题，吧友们比较建议京东入手较稳；东芝的tr200相对来说是最最便宜的固态，寿命和质量都相较三星有很大的差别，不适合作为系统盘。综合自己的需求，准备再使用这台电脑好几年，所以选择了三星，三星本身自带5年/150TBW官方保修，只要购买的是全新正品，不用担心售后问题。</p><h3 id="关于三星硬盘开箱应该做的事"><a href="#关于三星硬盘开箱应该做的事" class="headerlink" title="关于三星硬盘开箱应该做的事"></a>关于三星硬盘开箱应该做的事</h3><ul><li>首先查看包装，封口是否完整。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img6.webp" alt="查看硬盘包装，封口是否完整"></li><li>查看侧面的SN码<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img7.webp" alt="查看硬盘的SN码"></li><li>通过SN码查询硬盘的真伪，常用的查询方法有两种<ol><li>官网查询。访问<a href="https://www.samsung.com/cn/" target="_blank" rel="noopener">三星中国官网</a>，在通过<strong>售后服务</strong>-<strong>自助服务</strong>-<strong>产品验证服务</strong>，在验证界面输入SN信息即可验证（PS：我使用的谷歌浏览器访问该网页显示不正常，使用手机访问可以正常的显示）。在官网上可能会出现查不到SN码的情况，这时候需要通过电话进行查询。</li><li>电话查询。通过服务电话400-810-5858，转固态硬盘类客服，报SN码即可查询到该固态的信息，核对固态的信息可知是否是正品。</li></ol></li></ul><h3 id="固态硬盘开箱"><a href="#固态硬盘开箱" class="headerlink" title="固态硬盘开箱"></a>固态硬盘开箱</h3><ul><li>首先打开包装封口，打开包装。，首先看到的是固态硬盘的说明书，里面是对硬盘的使用的基本介绍和保修说明。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img8.webp" alt="硬盘说明书"></li><li>说明书下面就是固态硬盘<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img9.webp" alt="固态硬盘"></li><li>拿起固态硬盘，是手感非常好的磨砂材质，感觉非常轻，在背面也贴有固态硬盘的SN码等基本信息。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img10.webp" alt="固态硬盘背面"></li></ul><h2 id="清灰、换硅脂和加装固态全过程"><a href="#清灰、换硅脂和加装固态全过程" class="headerlink" title="清灰、换硅脂和加装固态全过程"></a>清灰、换硅脂和加装固态全过程</h2><p>拆机之前一定注意的是：<strong>找个地方分开放每个步骤拆下的螺丝，避免弄丢螺丝或者找不到螺丝</strong>。</p><ol><li>首先将笔记本翻过来，向两边推打开电池的锁，取下电池。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img11.webp" alt="拆下笔记本电池"></li><li>拧开图示两颗螺丝，往下推D壳盖板即可拆下。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img12.webp" alt="拆下D壳盖板"></li><li>将内存槽两边的铁片往两边向外掰即可弹出内存条。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img13.webp" alt="拆下内存条"><br> 这个内存条是我之前在某东上入手的金士顿骇客神条(4G ddr3l 1600)。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img14.webp" alt="金士顿骇客神条"></li><li>拧下硬盘位周围的三颗螺丝，往外推即可拆下机械硬盘。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img15.webp" alt="拆下机械硬盘"><br> 原装使用的是日立7200转的500G机械硬盘。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img16.webp" alt="原装日立机械硬盘"></li><li>拧开D壳面的螺丝，需要注意电池两边的螺丝要比其它的长一些，装机的时候要注意，不要拧错了。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img17.webp" alt="拧开D壳面螺丝"></li><li>拆开C壳卡扣。将电脑翻过来，打开笔记本盖，用指甲插入C壳和D壳的缝隙中，然后从指甲打开的缝隙中插入一张卡片，用这张卡片将C壳的三面的卡扣都打开，拆。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img18.webp" alt="用一张卡片打开C壳卡扣"></li><li>打开C壳的三面的卡扣之后可以很轻易的将C壳从正面打开，但是要注意打开的幅度不能太大，因为C壳上有排线连接到主板上，如果打开的幅度很大，有可能损坏排线。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img19.webp" alt="小心翼翼打开C壳，看到C壳下的排线"></li><li>断开C壳排线。排线接口有一个类似锁扣的结构防止排线从接口中脱落，因此要断开排线需要把排线接口上的锁扣往上掰，打开后就可以断开排线了。（在网上查了资料，这种应该叫做锁扣排线。几种排线接口的资料<a href="https://www.jb51.net/softjc/453914.html" target="_blank" rel="noopener">https://www.jb51.net/softjc/453914.html</a>）<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img20.webp" alt="断开三条锁扣排线"></li><li>小心移除C壳，可以看到整个电脑的内部结构。我们可以看到4年没拆过的电脑中有非常多的灰，两个扬声器上面掉满了灰尘。拧开图示的螺丝，准备拆下光驱。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img21.webp" alt="fx50j内部结构"></li><li>往外推即可拆下光驱。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img22.webp" alt="外推拆下光驱"></li><li>拆下光驱的固定铁片，拧下上面的两颗螺丝。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img23.webp" alt="拆下固定挡片"></li><li>将拆下的贴片固定到光驱位硬盘托架上，使用之前固定的螺丝固定即可。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img24.webp" alt="贴片固定的位置"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img25.webp" alt="固定好的样子"></li><li>为了测试光驱位硬盘支架，准备先将机械硬盘装到光驱位测试开机。首先找到固定机械硬盘的4螺丝（圈起来的螺丝一边两颗），拧掉即可将机械硬盘从硬盘支架上拆下。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img26.webp" alt="拆下机械硬盘"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img27.webp" alt="硬盘位托架，之后用于固定固态硬盘"></li><li>使用硬盘托架赠送的软胶塞塞入四个固定孔位，防止在装入硬盘后硬盘在托盘内晃动。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img28.webp" alt="在螺丝孔内塞入固定胶塞"></li><li>将硬盘装入光驱硬盘托架。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img29.webp" alt="硬盘装入托架，并且使用后固定胶塞将硬盘固定在托架内"></li><li>将光驱硬盘托架装入光驱位，拧上固定螺丝。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img30.webp" alt="将托架推入光驱位，使用螺丝固定"></li><li>接上开机排线，连接外接电源，尝试开机。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img31.webp" alt="测试光驱托架正常开机"></li><li>能正常开机后，把原光驱的挡板拆下，装到光驱托架上。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img32.webp" alt="拆下光驱挡板"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img33.webp" alt="挡板装到托架的侧面"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img34.webp" alt="给光驱硬盘托架装上挡板"></li><li>将固态硬盘装到硬盘支架上，拧上固定螺丝。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img35.webp" alt="将固态硬盘放入硬盘位"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img36.webp" alt="将两侧的固定螺丝拧上"></li><li>弄完硬盘之后，进行清灰和更换硅脂。首先拆下无线网卡的天线，这里的话是一黑一白两根天线，接着拧下无线网卡的固定螺丝，即可取下无线网卡。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img37.webp" alt="拆下天线和网卡固定螺丝"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img38.webp" alt="取下无线网卡"></li><li>拧下固定主板的螺丝，注意散热器和主板是固定在一起的，所以要把固定散热器的两个螺丝也拧掉，同时取掉usb小板的排线。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img39.webp" alt="拧下主板和散热风扇的固定螺丝，取下usb小板的排线"></li><li>拆下主板可以看到在D壳里面已经积累的很多的灰尘。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img40.webp" alt="D壳"></li><li>使用软毛刷去除D壳内的灰尘。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img41.webp" alt="毛刷清除D壳的灰尘"></li><li>在处理主板之前，应该取下主板背面的电池。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img42.webp" alt="取下主板电池"></li><li>拆掉散热器的固定螺丝。取下散热器。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img43.webp" alt="拆下散热器固定螺丝"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img44.webp" alt="拆下散热器"></li><li>使用软毛刷去除主板两面上积累的灰尘。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img45.webp" alt="刷去主板上的灰尘"></li><li>使用软毛刷清理风扇里的灰尘。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img46.webp" alt="刷去风扇上的灰尘"></li><li>使用吹风机吹掉残余的灰尘。</li><li>去掉散热器上残留的硅脂。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img47.webp" alt="去掉散热器上的硅脂"></li><li>去掉CPU和GPU核心上残留的硅脂，如果硅脂完全硬化了，不建议强行清除，强行清除可能会损坏核心，可以使用沾有无水酒精的棉球进行擦除。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img48.webp" alt="去除CPU和GPU核心的硅脂"></li><li>给CPU和GPU核心涂上硅脂。在核心上挤上一小点硅脂，能够在核心上薄薄覆盖上一层硅脂即可（尽可能薄）。<em>忘记拍照了，网上有涂硅脂的教程</em></li><li>按照拆机的步骤将散热器装回，注意，散热器要尽量对准孔位再装上去，避免散热器移动导致硅脂不均匀。</li><li>装上主板电池之后，接上电源接口、屏线和光驱硬盘托架测试是否能正常开机。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img49.webp" alt="装上主板电池"></li><li>测试正常开机之后，按照之前的拆机步骤装好主板，连接好电源接口、扬声器接口、屏线、无线网卡和usb小板排线，注意安装usb小板的排线不要被主板压住了。</li><li>按照拆机步骤装好光驱，连接好C壳排线，扣上C壳卡扣。</li><li>拧上D壳上螺丝，装好固态硬盘和内存条。</li><li>安装好电池和D壳盖板。</li><li>测试开机是否正常。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img50.webp" alt="开机成功"></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然中间拆了好几次电脑，但是最后电脑维护完美结束。维护过程中最重要的是要细心一些，拆不下来不要使用暴力拆解。一定要注意在接触主板电路之前，释放一下人体的静电（通过接触接地的金属物品释放），避免静电击穿电路。</p><p>装机的时候一定要仔细一点，不要遗忘了安装某些东西。我最后忘记接上usb小板的排线导致又拆了一次电脑的教训。</p><p>最重要最重要的是把拆机的螺丝分步骤分开放，不然装机的时候将是噩梦。会发现找不到合适的螺丝或者装完机后还剩余螺丝。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>拆机参考资料:&lt; <a href="https://post.smzdm.com/p/395720/" target="_blank" rel="noopener">https://post.smzdm.com/p/395720/</a> &gt;<br>拆机参考资料:&lt; <a href="http://tieba.baidu.com/p/5717515872" target="_blank" rel="noopener">http://tieba.baidu.com/p/5717515872</a> &gt;<br>固态部分参考资料:&lt; <a href="http://tieba.baidu.com/p/6169820508" target="_blank" rel="noopener">http://tieba.baidu.com/p/6169820508</a> &gt;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PC </tag>
            
            <tag> 维护 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>档案对比工具</title>
      <link href="/2019/10/30/%E6%A1%A3%E6%A1%88%E5%AF%B9%E6%AF%94%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/10/30/%E6%A1%A3%E6%A1%88%E5%AF%B9%E6%AF%94%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>档案对比工具一般是对ASCII纯文字文档进行对比，也可以对非纯文字文档进行对比。linux中常用的档案对比工具有diff、cmp和patch等。diff是对比ASCII纯文字文档，cmp可以对比非纯文字文档，</p><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>diff工具一般用在纯文本文档中，以行为单位。</p><p>diff的基本语法如下：</p><pre><code class="bash">diff [-bBi] from-file to-file选项与参数:-b:忽略一行中多个空格的差异，例如&#39;about me&#39;和&#39;about  me&#39;，有一个空格和两个空格，但是&#39;b&#39;选项将两个字符串判定为相同的字符串;-B:忽略空白行的差别;-i:忽略大小写的差别。from-file:文档名，对比的参考文件;to-file:文档名，目标对比文件;</code></pre><p>这里，我们使用一个例子来进行diff的演示。</p><ol><li>使用<code>mkdir /tmp/passwdt &amp;&amp; cd /tmp/passwdt &amp;&amp; cat /etc/passwd | tee passwd.old | sed -e &#39;4d&#39; &gt; passwd.new</code>创建路径/tmp/passwdt并设置当前路径为/tmp/passwdt并将原本的passwd内容制作两份文档。<br><img src="/2019/10/30/档案对比工具/img1.webp" alt="passwd.old文档内容"><br><img src="/2019/10/30/档案对比工具/img2.webp" alt="passwd.new文档内容"></li><li>比较两份文档的区别，<code>diff /tmp/passwdt/passwd.old /tmp/passwdt/passwd.new</code>结果如下图:<br><img src="/2019/10/30/档案对比工具/img3.webp" alt="用diff比较passwd.old和passwd.new的区别"><br>其中<strong>4d3</strong>表示参考文档的第四行被删除，对比的是目标对比文件的第三行。后面紧跟着的一行是被删除的内容。</li></ol><p>diff工具除了能比较纯文本文件以外还能对目录等进行比较。</p><h2 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h2><p>cmp用于比较两个文档字节的差别，与diff的行比较不同，cmp是以字节为单位进行比较，也可以比较二进制文档。下面以对比passwd.new和passwd.old两个文档，执行结果如下:</p><p><img src="/2019/10/30/档案对比工具/img4.webp" alt="cmp对比结果"></p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>patch和diff有一定的联系，在diff中得到两个文件的差异，而在patch中则是构建前后两个文档通过差异建立联系，也就是补丁档，可以一个文件通过补丁档得到另外一个文件。示例如下：</p><ol><li><p>创建补丁档<br>命令<code>diff -Naur passwd.old passwd.new &gt; passwd.patch</code><br><img src="/2019/10/30/档案对比工具/img5.webp" alt="diff创建补丁"></p></li><li><p>使用patch打补丁</p><pre><code class="bash"># patch用法讲解patch -pN &lt; patch_file #更新文件，将旧文件更新为新文件# -p 后面的数字表示取消几层目录patch -R &lt; patch_file #还原文件，将新文件还原为之前的文件# -R 表示将新档案还原成就档案</code></pre><p>命令<code>patch -p0 &lt; passwd.patch</code>即可将旧文件更新为新文件内容;<br>命令<code>patch -R &lt; passwd.patch</code>即可将新文件还原为旧文件内容;</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜-第十一章:&lt;  <a href="http://linux.vbird.org/linux_basic/0330regularex.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0330regularex.php</a> &gt;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> diff </tag>
            
            <tag> cmp </tag>
            
            <tag> patch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk工具</title>
      <link href="/2019/10/18/awk%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/10/18/awk%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="命令形式"><a href="#命令形式" class="headerlink" title="命令形式"></a>命令形式</h2><pre><code>awk &#39;条件类型1{动作1}条件类型2{动作2}...&#39; filename</code></pre><p>awk主要是处理每一行的栏位内的资料，预设的分隔符号为空格或者制表符。</p><p><strong>例子</strong>:列出ssh最后五条登陆记录，并用awk只显示登陆用户名、登陆时间和登陆ip。命令<code>last -n 5 | egrep -v &quot;reboot|^$|wtmp&quot; | awk &#39;{print $1 &quot;\t&quot; $5&quot; &quot;$6&quot; &quot;$7 &quot;\t&quot; $3}&#39;</code><br><img src="/2019/10/18/awk工具/img1.webp" alt="提取最后5条登陆信息中的登陆用户名、登陆时间和登陆ip"></p><h2 id="awk一般处理流程"><a href="#awk一般处理流程" class="headerlink" title="awk一般处理流程"></a>awk一般处理流程</h2><p>一般awk的处理流程如下：</p><ol><li>读入一行，并根据分隔符进行分割，一次用$1、$2……表示（<em>注意</em>:$0表示的该行完整内容）；</li><li>根据条件类型，决定后面紧跟的动作是否进行；</li><li>完成所用的条件判断及符合条件的动作执行；</li><li>如果后续还有内容则选择下一行继续进行1处理</li></ol><h2 id="awk内建变量"><a href="#awk内建变量" class="headerlink" title="awk内建变量"></a>awk内建变量</h2><p>以下为常用的内建变量名称，详细的内建变量名称可以通过<code>man awk</code>查询。</p><table><thead><tr><th align="center">内建变量名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">NF</td><td align="center">每一行分割之后的栏位个数</td></tr><tr><td align="center">NR</td><td align="center">目前处理字符串的行数</td></tr><tr><td align="center">FS</td><td align="center">目前的分隔字符</td></tr></tbody></table><h2 id="awk逻辑运算符"><a href="#awk逻辑运算符" class="headerlink" title="awk逻辑运算符"></a>awk逻辑运算符</h2><p>逻辑运算符使用在条件类型中，用于判断条件，是否执行后边的动作命令。</p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">==</td><td align="center">等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr></tbody></table><h2 id="使用的注意事项"><a href="#使用的注意事项" class="headerlink" title="使用的注意事项"></a>使用的注意事项</h2><p>awk指令的间隔：所用的awk命令都用’{}’括起来，如果在一个动作中使用多个命令，则使用’;’间隔，或者使用回车换行间隔。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜:&lt; <a href="http://linux.vbird.org/" target="_blank" rel="noopener">http://linux.vbird.org/</a> &gt;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed工具</title>
      <link href="/2019/10/08/sed%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/10/08/sed%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客中，主要是讲linux系统常用的工具sed。sed是一个管线命令可以对输入进行替换、删除、增加和检索特定行。</p><h2 id="常用的参数"><a href="#常用的参数" class="headerlink" title="常用的参数"></a>常用的参数</h2><pre><code class="bash">sed [-nefr] [动作]选项:-n: 使用静默模式，默认情况下，sed会将所有的stdin都输出到屏幕上，使用-n参数之后仅仅显示处理那一行；-e: 使用指令列模式进行sed动作编辑；-f: sed的动作来源于一个文档，一般为`-f filename`，则执行filename文件内的sed动作；-r: 表示sed支持拓展正则表达式语法；-i: 直接修改文档，不输出到屏幕。动作说明: [n1[,n2]]functionn1,n2 不一定会存在，一般表示进行动作的行数，处理10行到20行一般表示为`10,20`function一般是以下选项：a: 新增 `a 字符串`表示在当前行后面添一行，内容为字符串内容；c: 取代 `c 字符串`，表示字符串取代n1,n2表示行的内容；d: 删除 后不接内容；i: 插入 `i 字符串`,在目前行的前面新加一行，内容为字符串；p: 列印 将选择的内容打印出来，一般配合`sed -n`使用；s: 取代，直接进行取代工作，一般s配合正则表达式使用。注意，在命令后边下达的指令要用两个单引号括起来，例如操作，sed &#39;2,5d&#39;。</code></pre><p>其他更加详细的使用方法通过<code>man sed</code>指令查询。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li><p>将/etc/passwd中的的3到5行删除。命令<code>cat -n /etc/passwd | sed &#39;3,5d&#39;</code><br><img src="/2019/10/08/sed工具/img1.webp" alt="删除/etc/passwd的3到5行输出"><br>当需要删除第二行时，使用命令<code>sed &#39;2d&#39;</code>;<br>当要删除第二行到最后一行时，使用命令<code>sed &#39;2,$d&#39;</code></p></li><li><p>在/etc/passwd中的第3行前添加’add by sed’。命令<code>cat -n /etc/passwd | sed &#39;3iadd by sed&#39;</code></p></li></ol><p><img src="/2019/10/08/sed工具/img2.webp" alt="在/etc/passwd的第三行前面添加特定内容"><br>3. 在/etc/passwd中的第3行后添加’add by sed’。命令<code>cat -n /etc/passwd | sed &#39;3aadd by sed&#39;</code><br><img src="/2019/10/08/sed工具/img3.webp" alt="在/etc/passwd的第三行后面添加特定内容"></p><ol start="4"><li><p>将/etc/passwd的第二行取代为’this line is replaced by sed’，命令<code>cat -n /etc/passwd | sed &#39;2cthis line is replaced by sed&#39;</code><br><img src="/2019/10/08/sed工具/img4.webp" alt="将/etc/passwd的第二行替换"></p></li><li><p>替换行的部分数据，命令格式<code>sed &#39;s/被替换的字符串/新的字符串/g&#39;</code>，将/etc/passwd中的test替换为tt，执行命令<code>cat -n /etc/passwd | sed &#39;s/test/tt/g&#39;</code><br><img src="/2019/10/08/sed工具/img5.webp" alt="使用sed工具检索并替换"></p></li><li><p>sed可以直接修改文档内容，可以直接在命令后面接文档名称就可以直接修改文档名称，例如我们将文件中的所有’,’修改为’.’，那么命令为<code>sed &#39;s/,/\./g&#39; filename</code>。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜:&lt; <a href="http://linux.vbird.org/" target="_blank" rel="noopener">http://linux.vbird.org/</a> &gt;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/10/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/10/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正则表达式是一个优秀的文字处理方式，可以通过简单的匹配实现字符串的检索、替换或者删除处理，在信息提取、运营维护方面有重要的应用。</p><h2 id="具有特殊含义的符号"><a href="#具有特殊含义的符号" class="headerlink" title="具有特殊含义的符号"></a>具有特殊含义的符号</h2><table><thead><tr><th align="center">符号</th><th align="center">作用</th><th align="center">示例</th><th align="center">示例解释</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">表示数字和大小写英文字母</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:alpha:]</td><td align="center">表示大小写英文字母</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:blank:]</td><td align="center">表示空格和制表符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:cntrl:]</td><td align="center">表示键盘的控制按键，包括CR、LF、Tab，Del等等</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:digit:]</td><td align="center">表示数字</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:graph:]</td><td align="center">除空格和制表符之外的其他按键，不包括控制符号</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:lower:]</td><td align="center">表示小写字母</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:upper:]</td><td align="center">表示大写字母</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:print:]</td><td align="center">表示可以打印的符号</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:punct:]</td><td align="center">表示标点符号，如,.’”等等</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:space:]</td><td align="center">表示任何的空白字符，包括空格，制表符和控制符号</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:xdigit:]</td><td align="center">表示16进制数，匹配0-9,AF和af</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[]</td><td align="center">表示中括号中任何一个字符匹配，可以使用范围表示字符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[^]</td><td align="center">而中括号中加上’^’符号，表示不包含这个括号中的任何一个字符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">^$</td><td align="center">当’^’和’$’分开出现的时候，分表表示起始和结束</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">\</td><td align="center">后接特殊字符表示本来的字符，无特殊意义</td><td align="center">\.\+</td><td align="center"></td></tr><tr><td align="center">.</td><td align="center">表示任何一个字符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">*</td><td align="center">表示重复匹配前面的字符0次或多次</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">\{n,m\}</td><td align="center">括号中填写数字n,m表示匹配前一字符n到m次</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">\{n\}</td><td align="center">括号中填写数字n表示匹配前一字符n次</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="拓展正则表达式"><a href="#拓展正则表达式" class="headerlink" title="拓展正则表达式"></a>拓展正则表达式</h2><p>grep默认参数仅支持基础正则表达式，可以使用<code>grep -E</code>或者<code>egrep</code>开启使用扩展正则表达式。拓展正则表达式如下表所示:</p><table><thead><tr><th align="left">RE符号</th><th align="center">意义</th><th align="center">示例</th><th align="center">示例解释</th></tr></thead><tbody><tr><td align="left">+</td><td align="center">重复一个或者以上</td><td align="center">go+d</td><td align="center">匹配god、good、goood等等</td></tr><tr><td align="left">?</td><td align="center">匹配0个或者1个</td><td align="center">go?d</td><td align="center">匹配gd和god</td></tr><tr><td align="left">|</td><td align="center">或</td><td align="center">good|glad</td><td align="center">匹配good或者glad</td></tr><tr><td align="left">()</td><td align="center">表示多个字符的字串</td><td align="center">g(oo|la)d</td><td align="center">匹配good或者glad</td></tr><tr><td align="left">()+</td><td align="center">将()内匹配的字符串匹配1次及更多</td><td align="center">a(bc)+d</td><td align="center">匹配abc…d字符串</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟哥的linux私房菜第十一章:&lt; <a href="http://linux.vbird.org/linux_basic/0330regularex.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0330regularex.php</a> &gt;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习中一些概念的东西</title>
      <link href="/2019/09/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
      <url>/2019/09/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在本篇博客中主要是用于记录深度学习中一些概念性的词语。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><table><thead><tr><th align="center">专业术语</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">超平面</td><td align="center">n维欧式空间中余维度等于1的子空间。即n维空间中的超平面是n-1维的子空间。</td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/超平面" target="_blank" rel="noopener">超平面-来源:维基百科</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书_第四章</title>
      <link href="/2019/08/30/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2019/08/30/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本章中主要学习决策树的构建，决策树就是使用“分而治之”的思想对样本进行处理。决策树学习的目标是为了产生一棵泛化能力强的模型。</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="算法结束"><a href="#算法结束" class="headerlink" title="算法结束"></a>算法结束</h3><p>决策算法使用递归方式构建模型，有三种情况会导致递归返回：</p><ol><li>当前节点包含的样本全部属于同一类别，无需划分；</li><li>当前属性集为空，或时所有样本在属性上取值相同，无法划分；</li><li>当前节点包含的样本集合为空，不能划分。</li></ol><h3 id="属性划分原则"><a href="#属性划分原则" class="headerlink" title="属性划分原则"></a>属性划分原则</h3><p>决策树中，如何选择最优的划分属性？在划分过程中，希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的“纯度”（purity）越高越好。</p><h3 id="信息增益——ID3决策树算法"><a href="#信息增益——ID3决策树算法" class="headerlink" title="信息增益——ID3决策树算法"></a>信息增益——ID3决策树算法</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>信息熵</strong>是衡量样本集合纯度最常用的一种指标。假定当前样本集合D中，第k类样本所占比例为p<sub>k</sub>,(k=1,2…,|y|),则信息熵的定义为：<br>$$<br>Ent(D)=-\sum^{|y|}_{k=1}p_k\log p_k<br>$$<br>Ent(D)的值越小，D的纯度越高，不确定性越小，决策树往熵减的方向划分。</p><p>说到信息熵不得不说到<strong>信息</strong><a href="https://blog.csdn.net/qq280929090/article/details/78135417" target="_blank" rel="noopener">（参考来源）</a>，衡量不确定性，衡量方式：$-log(x)$。</p><p><strong>信息增益(Indormation Gain)</strong>描述的是划分前后信息熵的变化。假定属性a有V个值${a^1,a^2,\ldots,a^v}$，第v个分支表示属性a取值为a<sup>v</sup>的全部样本D<sup>v</sup>,表达式如下：<br>$$<br>Gain(D,a)=Ent(D)-\sum^{V}_{v=1}\frac{|D^v|}{|D|}Ent(D^v)<br>$$</p><p><strong>ID3决策树算法使用信息增益选择划分属性。</strong></p><h3 id="增益率——C4-5决策树算法"><a href="#增益率——C4-5决策树算法" class="headerlink" title="增益率——C4.5决策树算法"></a>增益率——C4.5决策树算法</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>增益率表达如下:<br>$$<br>Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}<br>$$</p><p>其中IV(a)为属性a的固有值，计算方式如下：<br>$$<br>IV(a)=-\sum^V_{v=1}\frac{|D^v|}{|D|}\log^{\frac{|D^v|}{|D|}}_{2}<br>$$</p><h3 id="基尼指数——CART决策树算法"><a href="#基尼指数——CART决策树算法" class="headerlink" title="基尼指数——CART决策树算法"></a>基尼指数——CART决策树算法</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><strong>基尼值</strong>：</p><p>$$<br>\begin{align}<br>Gini(D) &amp;=\sum^{|y|}_{k=1}\sum_{k\neq k’}p_kp_{k’}\\<br>&amp;=1-\sum^{|y|}_{k=1}p^2_k<br>\end{align}<br>$$</p><p>其中k为样本类型。Gini(D)越小，D的纯度越高。</p><p><strong>基尼指数</strong>：<br>$$<br>Gini\_index(D,a)=\sum^V_{v=1}\frac{|D^v|}{|D|}Gini(D^v)<br>$$</p><h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>剪枝是为了防止决策树算法过拟合的方法。</p><h3 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对每个节点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能的提升，则停止划分并将当前节点标记为叶结点。经过预剪枝的决策树不易造成过拟合，并且可以减少训练时间和开销，但是有欠拟合的风险。</p><h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>先从训练集中生成一棵完整的决策树，然后自底向上考察非叶结点，如果将该子树替换为叶结点能带来决策树泛化性能提高，则将该子树他替换为叶结点。后剪枝欠拟合风险小，泛化性能优于预剪枝，但是训练时间和开销较大。</p><h2 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h2><p>即连续值离散化处理</p><p>对连续属性a，可考察包含n-1个元素的候选划分点集合。</p><p>$$<br>T_a=\{\frac{a^i+a^{i+1}}{2}|1 \leqslant i \leqslant n-1\}<br>$$</p><p>逐个对划分点进行考察，选择最佳划分点：</p><p>$$<br>\begin{align}<br>Gain(D,a)&amp;=Gain(D,a,t)\\<br>&amp;=\max_{t\in T_a}Ent(D)-\sum_{\lambda\in\{-,+\}}\frac{|D^\lambda_t|}{|D|}Ent(D^\lambda_t)<br>\end{align}<br>$$</p><p>计算出来的信息熵增益值可以离散属性相比较。</p><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>在实际中存在不完整样本，即样本的某些属性缺失。</p><p>假设数据集为$D$，属性值完整的样本构成$\widetilde D$,并且每个样本赋予一个权重$\omega_x$,则：</p><p><strong>未缺失属性样本比例：</strong><br>$$<br>\rho=\frac{\sum_{x\in\widetilde D}\omega_x}{\sum_{x\in D}\omega_x}<br>$$</p><p><strong>未缺失属性样本中k标签的比例：</strong><br>$$<br>\widetilde p_k=\frac{\sum_{x\in\widetilde D_k}\omega_x}{\sum_{x\in {\widetilde D}}\omega_x},(1\leqslant k\leqslant|y|)<br>$$</p><p><strong>无缺失样本中a取值v的比例：</strong></p><p>$$<br>\widetilde r_v=\frac{\sum_{x\in\widetilde D^v}\omega_x}{\sum_{x\in {\widetilde D}}\omega_x},(1\leqslant v\leqslant V)<br>$$</p><h3 id="插值信息增益"><a href="#插值信息增益" class="headerlink" title="插值信息增益"></a>插值信息增益</h3><p>$$<br>\begin{align}<br>Gain(D,a)&amp;=\rho×Gain(\widetilde D,a)\\<br>&amp;=\rho×(Ent(\widetilde D)-\sum^V_{v=1}\widetilde r_vEnt(\widetilde D^v))<br>\end{align}<br>$$</p><p>其中，</p><p>$$<br>Ent(\widetilde D)=-\sum^{|y|}_{k=1}\widetilde p_k \log^{\widetilde p_k}_2<br>$$</p><p>若属性已知则$\omega_x$不变，若为未知，则将x同时划入所有节点中，且样本中的权值调整为：$\widetilde r_v·\omega_x$</p><h2 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h2><p>多变量决策树的主要作用在于简化决策树结构</p><p>在非叶结点中，不是对单个属性进行判断，而是对属性的线性组合进行判断。</p><p>主要算法：OC1</p><h2 id="增量学习"><a href="#增量学习" class="headerlink" title="增量学习"></a>增量学习</h2><p>用于收到新样本之后调整模型。</p><p>算法：ID4、ID5R、ITI</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>后验概率</strong>：先知道结果，由结果估计原因的概率分布，P(交通方式|交通时间)–先知道花费的时间，估算使用交通工具的概率。</p><p><strong>先验概率</strong>：先于结果，估计原因的概率分布。</p><p><strong>似然估计</strong>： 先确定原因，根据原因估计结果的概率估计。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》作者：周志华</a>；</p><p><a href="https://blog.csdn.net/qq280929090/article/details/78135417" target="_blank" rel="noopener">详解信息熵</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 西瓜书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西瓜书 </tag>
            
            <tag> 读书 </tag>
            
            <tag> 第四章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中设置网卡bond</title>
      <link href="/2019/08/25/linux%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%8D%A1bond/"/>
      <url>/2019/08/25/linux%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%8D%A1bond/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇博客文章主要介绍linux系统中的网卡bond设置。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>本篇文章中使用ubuntu作为实现平台，在虚拟机下安装ubuntu 16.04版本，并添加了两张网卡设备。</p><h2 id="获取网卡设备名称"><a href="#获取网卡设备名称" class="headerlink" title="获取网卡设备名称"></a>获取网卡设备名称</h2><p>打开系统终端，运行指令<code>ifconfig -a</code><br><img src="/2019/08/25/linux中设置网卡bond/img1.webp" alt="获取网卡名称"><br>在本系统中网卡的名称为<strong>ens33</strong> 和<strong>ens38</strong> 。另外的lo为虚拟的网络接口，用于网络回环。</p><h2 id="获取网络网关"><a href="#获取网络网关" class="headerlink" title="获取网络网关"></a>获取网络网关</h2><p>在终端中运行指令<code>netstat -r</code><br><img src="/2019/08/25/linux中设置网卡bond/img2.webp" alt="从路由表中获取网关信息"><br>系统的网关地址为：192.168.59.2</p><h2 id="设置1模式的bond备份"><a href="#设置1模式的bond备份" class="headerlink" title="设置1模式的bond备份"></a>设置1模式的bond备份</h2><p>编辑/etc/network/interfaces文件，设置网卡配置如下：</p><pre><code>auto loiface lo inet loopbackauto ens33iface ens33 inet manualbond-master bond0auto ens38iface ens38 inet manualbond-master bond0auto bond0iface bond0 inet staticaddress 192.168.59.133netmask 255.255.255.0gateway 192.168.59.2dns-nameservers: 114.114.114.114bond-slaves ens33 ens38bond-lacp-rate 1bond-mode 1bond-miimon 100</code></pre><h2 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a>配置生效</h2><p>重启系统，在终端中运行<code>ifconfig</code>查看设置是否生效：<br><img src="/2019/08/25/linux中设置网卡bond/img3.webp" alt="查看bond是否成功"><br>执行命令之后，看到出现了新的虚拟网络设备bond0，设置已经生效。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>linux公社:<a href="https://www.linuxidc.com/Linux/2017-09/147164.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-09/147164.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 设置 </tag>
            
            <tag> 网卡 </tag>
            
            <tag> bond </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基本概念</title>
      <link href="/2019/08/21/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/08/21/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>##　前言</p><p>在本篇博客中主要介绍一些基础的网络知识，对网络有基本的认识及设置。</p><h2 id="网络的概念"><a href="#网络的概念" class="headerlink" title="网络的概念"></a>网络的概念</h2><p><strong>网络</strong>的广义概念是指由若干节点和节点之间的链路组成，表示之间的相互联系。<sup>来源:<a href="https://baike.baidu.com/item/网络/143243" target="_blank" rel="noopener">百度百科</a></sup>比如电网、自来水网、路网、天然气网以及互联网（Internet）。而网络的狭义概念特指的是互联网。</p><p><strong>互联网</strong>指的是21世纪初网络与网络之间相互连接形成的超大型网络。</p><h2 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h2><p><img src="/2019/08/21/网络基本概念/img1.webp" alt="网络的结构"></p><p>从上图中可以看到网络的结构，最顶层为广域网，其下包括我们熟知的互联网、平时接触不到的大型跨地区企业内部网络等等也属于广域网。广域网是连接不同地区局域网的远程网，强调的是物理范围。而因特网仅仅指的是国际互联网，即全球计算机互联的网络，是广域网中的一种。</p><p>而互联网是由不同的网络连接形成的国际性网络，而这些不同的网络即是城域网。城域网指的是城市范围内的网络。</p><p>城域网连接的是一个个的局域网。这些局域网包括学校、公司以及家庭自建的无线局域网络等。</p><p>而在局域网下边还有个人局域网，包括各种蓝牙以及红外等连接。</p><h2 id="网络的基础设置"><a href="#网络的基础设置" class="headerlink" title="网络的基础设置"></a>网络的基础设置</h2><p>我们日常所能接触到的网络属于是局域网，掌握局域网的基本设置可以让我们获得更好的上网体验以及网络故障时做出相应的排查修复。</p><p>目前网络主要使用的是基于IPV4（32位二进制数字标签）的TCP/IP协议，由于IPV4（128位二进制数字标签）地址数量已经不能满足日益发展的网络，因此目前正在向IPV6过渡。IP地址是分配给用户上网使用的网际协议的设备的数字标签，即通过这个IP地址我们可以找到这台设备（Ps：在局域网中使用局域网地址即可找到，在广域网中使用唯一IP地址即可找到）。在局域网中常常需要设置的几个参数是：IP地址、子网掩码、默认网关、DNS服务器地址、DHCP服务。</p><p>首先说明IP地址，这里的IP地址填写的一个在网络(局域网或广域网)中唯一标志主机的地址。其作用就是能找到这台计算机。</p><p>子网掩码，指定网络号和主机号，掩码二进制位为1的部分为网络号，为0的部分为主机号。例如，IP地址为:192.168.1.10（11000000,10101000,00000001,00001010），子网掩码为:255.255.255.0（11111111,11111111,11111111,00000000），那么192.168.1是网络号，10是主机号。网络号作用是识别主机所在的网络，根据TCP/IP协议的规定，处于不同网络的计算机不能直接互相通信需要通过路由连接不同的局域网。主机号用于识别该网络中的主机。</p><p>网关就是一个网络通向另外网络的IP地址，当需要访问其他网络（如：另一个局域网或者广域网），需要通过网关来处理相应的数据，所以网关类似于一个关卡的作用，当你访问因特网或者其他网络的资源的时候都需要通过网关来实现，因此常常可以在网关上设置防火墙可以有效保证内部网络的安全。而默认网关就是当计算机找不到可用的网关时，将数据包发给默认指定的网关。</p><p>DNS服务器存在的意义在于方便人们去找到对应的计算机。如果网络资源都是通过IP来指定，那么记忆这些IP具有较大的困难。而记忆一个较短的字符串相对较为容易，那么使用一个字符串去查询一个IP地址，然后通过获取到的IP地址去访问主机相对于直接使用IP地址来说是更加合理的。这里通过一个字符串查询到一个IP地址的服务就是DNS服务，而提供这种服务的计算机就称为DNS服务器。</p><p>DHCP（全称为Dynamic Host Configuration Protocol，中文名称为动态主机配置协议）服务作用有两个，给内部的网络自动配置IP地址和管理员统一管理内部计算机。简单使用方法为：当一台计算机接入局域网中，回广播一条信息说明自己加入了这个网络，当DHCP接受到这个信息之后会私聊这台主机，并告诉这台主机的网络配置（包括IP地址，默认网关等等）。当然DHCP也可以为计算机指定固定的IP也可以不适用DHCP手动自己设置相应的网络配置。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote><p>百度百科:<a href="https://baike.baidu.com" target="_blank" rel="noopener">https://baike.baidu.com</a><br>CSDN博客:<a href="https://blog.csdn.net/huangyimo/article/details/82887367" target="_blank" rel="noopener">https://blog.csdn.net/huangyimo/article/details/82887367</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 基础概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秀米使用学习教程</title>
      <link href="/2019/08/18/%E7%A7%80%E7%B1%B3%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"/>
      <url>/2019/08/18/%E7%A7%80%E7%B1%B3%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客文章中主要介绍图文排版工具<strong>秀米</strong>&trade;的使用，将分别从基本工具说明和示例两个部分进行叙述。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>进入<a href="https://xiumi.us" target="_blank" rel="noopener">秀米官网</a>，登录账号(第一次使用需要注册)，选择<em>我的秀米<em>，单击</em>添加新的图文<em>进入图文排版编辑器。Ps：</em>以下的操作都是在编辑器下完成。</em></p><h2 id="基本工具说明"><a href="#基本工具说明" class="headerlink" title="基本工具说明"></a>基本工具说明</h2><ol><li><p>主要工具介绍<br><img src="/2019/08/18/秀米使用学习教程/img1.webp" alt="编辑器页面"><br>在秀米中进行图文排版十分的简单，右侧菜单主要是撤销和重做功能；上侧菜单主要是预览、保存、复制到公众号等功能；左侧菜单栏为主要的排版工作栏，其中最常用的是图文模板。其中图文模板主要分为标题、卡片、图片、布局、引导、组件等几类模板。</p><ul><li><em>标题</em>主要是用于文章中的标题部分，单击选中的标题即可添加标题到文章中，单击标题即可对标题的内容及其格式进行编辑设置。<br><img src="/2019/08/18/秀米使用学习教程/img2.webp" alt="添加并设置标题"></li><li><em>卡片</em>为文章的矩形元素，可以将文章的内容进行划分，同时加强内部的联系，可以使得文章逻辑清晰、美观。同样可以单击卡片对象即可对卡片进行编辑。<br><img src="/2019/08/18/秀米使用学习教程/img3.webp" alt="添加并设置卡片对象"></li><li><em>图片<em>可以向文章中插入图片，丰富文章内容。操作与标题类似，单击添加元素，单击即可设置自己的图片(</em>Ps:添加的图片需导入才能使用</em>)。<br><img src="/2019/08/18/秀米使用学习教程/img4.webp" alt="添加图片"></li><li><em>布局</em>是将多个元素组合之后的模板 。使用方式与标题相同。<br><img src="/2019/08/18/秀米使用学习教程/img5.webp" alt="添加布局"></li><li><em>引导</em>在文章中主要作用是引导读者的注意力的转移和集中。使用方法与标题相同。<br><img src="/2019/08/18/秀米使用学习教程/img6.webp" alt="添加引导"></li><li><em>组件</em>主要是一些小的部件，包括序号以及装饰部件等。使用方式与标题相同。<br><img src="/2019/08/18/秀米使用学习教程/img7.webp" alt="添加组件"></li></ul></li><li><p>修改文章标题和摘要。<br><img src="/2019/08/18/秀米使用学习教程/img8.webp" alt="修改标题和摘要"></p></li><li><p>点击上侧菜单栏的<em>预览</em>，预览文章。<br><img src="/2019/08/18/秀米使用学习教程/img9.webp" alt="预览"></p></li><li><p>点击上侧菜单栏的<em>保存</em>，保存文章到网站。<br><img src="/2019/08/18/秀米使用学习教程/img10.webp" alt="保存"></p></li><li><p>点击上侧菜单栏的<em>复制到微信公众号</em>按钮，按下<em>Ctrl+C</em>复制全文，将内容粘贴到微信公众平台编辑器，填入标题和摘要即可发布文章（同时也可以将多次编辑的内容粘贴到同一篇微信公众号文章中）<br><img src="/2019/08/18/秀米使用学习教程/img11.webp" alt="&quot;复制到公众号&quot;按钮"><br><img src="/2019/08/18/秀米使用学习教程/img12.webp" alt="&quot;Ctrl+C&quot;复制文章内容"><br><img src="/2019/08/18/秀米使用学习教程/img13.webp" alt="发布文章到微信公众号_图片来源于&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDE0MDA1Mw==&amp;mid=2650712096&amp;idx=1&amp;sn=7af2ea6e871f3e9679f2411fd5add5de&amp;chksm=be8652da89f1dbcc9fd1537311e5a23cb647c21a0ada716ba5ebb75e3c224f28cefec7fe6ba3#rd&quot;&gt;微信公众平台&lt;/a&gt;"></p></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2019/08/18/秀米使用学习教程/img14.webp" alt="演示示例"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>秀米官方帮助文档:<a href="https://r.xiumi.us/board/v5/2a5va/6103144" target="_blank" rel="noopener">https://r.xiumi.us/board/v5/2a5va/6103144</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 秀米 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> H5 </tag>
            
            <tag> 秀米 </tag>
            
            <tag> 图文排版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>易企秀使用学习教程</title>
      <link href="/2019/08/17/%E6%98%93%E4%BC%81%E7%A7%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"/>
      <url>/2019/08/17/%E6%98%93%E4%BC%81%E7%A7%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客文章中以易企秀&trade;H5应用作为示例，介绍H5应用使用的基本方法。主要分成两个部分进行学习：基本工具介绍和实际H5例子。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>在<a href="http://www.eqxiu.com" target="_blank" rel="noopener">易企秀官网</a>注册账号。在登录界面可使用已经注册好的账号密码直接登录。也可以选择第三方账号登陆（微信、QQ、微博、钉钉、企业微信），第一次登录时会验证手机号，通过手机号验证之后即可完成注册，第二次及以后可直接登录。也可以直接在注册账号界面注册，登录账号。<br><img src="/2019/08/17/易企秀使用学习教程/img1.webp" alt="易企秀登录界面"></li></ol><h2 id="基本工具介绍"><a href="#基本工具介绍" class="headerlink" title="基本工具介绍"></a>基本工具介绍</h2><ol><li><p>打开H5编辑界面：点击左侧菜单栏”创意模板”，选择空白模板即可进入H5编辑器。<br><img src="/2019/08/17/易企秀使用学习教程/img2.webp" alt="易企秀 创意模板"></p></li><li><p>右侧菜单栏为基本设置菜单栏，包括页面属性、图层管理和页面管理。</p><ul><li><em>页面属性</em>可以设置页面背景、页面音乐、页面滤镜以及翻页设置。<br><img src="/2019/08/17/易企秀使用学习教程/img3.webp" alt="页面属性"></li><li><em>图层管理</em>可以查看当前页面的元素以及可以对元素进行分组等操作。<br><img src="/2019/08/17/易企秀使用学习教程/img4.webp" alt="图层管理"></li><li><em>页面管理</em>可以调整页面顺序，可以删除和添加页面。<br><img src="/2019/08/17/易企秀使用学习教程/img5.webp" alt="页面管理"></li></ul></li><li><p>上侧菜单栏为组件菜单栏，包含文本、图片、背景、音乐、形状、组件、表单和特效。</p><ul><li><em>文本</em>主要是向页面中添加文本，可通过组件设置设置属性。</li><li><em>图片</em>向页面中添加一个图片并设置样式（功能设置、边框、阴影、尺寸和位置等等）、动画（给图片添加动画效果）和触发（设置触发功能）属性。</li><li><em>背景</em>可直接设置页面背景。</li><li><em>音乐</em>可直接设置页面背景音乐。</li><li><em>形状</em>可直接在页面中插入形状。</li><li><em>组件</em>在页面中插入如视频、外链视频等等。</li><li><em>表单</em>可向页面中插入表单。</li><li><em>特效</em>向页面中插入特效。<br><img src="/2019/08/17/易企秀使用学习教程/img6.webp" alt="组件菜单"></li></ul></li><li><p>左侧菜单栏为模板菜单，包含元素模板、功能模板和单页模板。</p><ul><li><em>元素模板</em>。编辑器中的元素模板主要包括了文本（标题以及正文部分文字）、艺术字、图片和图文4个部分。所有的元素模板都可以通过<strong>单击</strong>即可添加页面中，选中元素之后即可使用鼠标拖动调整到合适的位置。右边是模板设置，可以对选中的元素模板的属性进行设置，比如说设置文本内容、字体大小，颜色、图片、边框等等。<br><img src="/2019/08/17/易企秀使用学习教程/img7.webp" alt="元素模板 模板设置"></li><li><em>功能模板</em>。主要是使用整个页面完成一些如分享二维码，收集一些报名信息等功能。操作方法与元素模板类似，可以在模板设置中完成相应的设置。<br><img src="/2019/08/17/易企秀使用学习教程/img8.webp" alt="功能模板 模板设置"></li><li><em>单页模板</em>。主要是一些比较好的单页模板，如节日单页模板等等，选中模板中的元素可以对其进行修改。<br><img src="/2019/08/17/易企秀使用学习教程/img9.webp" alt="功能模板 模板设置"></li></ul></li><li><p>预览和设置<br>点击右上角的预览和设置，可以预览到实际效果。在该界面可以设置应用的标题、描述以及其他的设置。<br><img src="/2019/08/17/易企秀使用学习教程/img10.webp" alt="预览和设置"></p></li><li><p>保存和发布<br> 点击右上角的保存，再点击发布即可发布应用。可以通过二维码扫描、网页链接、也可以直接分享到微博、QQ和QQ空间。<br> <img src="/2019/08/17/易企秀使用学习教程/img11.webp" alt="发布"></p></li></ol><h2 id="实际应用例子"><a href="#实际应用例子" class="headerlink" title="实际应用例子"></a>实际应用例子</h2><p>链接地址:<a href="https://a.eqxiu.com/s/13ggMHc7" target="_blank" rel="noopener">https://a.eqxiu.com/s/13ggMHc7</a><br>链接二维码:<br><img src="/2019/08/17/易企秀使用学习教程/img12.webp" alt="易企秀示例应用"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote><p>易企秀官方帮助文档:<a href="http://www.eqxiu.com/c/help.html" target="_blank" rel="noopener">易企秀官方帮助文档</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 易企秀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> H5 </tag>
            
            <tag> 易企秀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书_第三章</title>
      <link href="/2019/07/29/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2019/07/29/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本章中详细讲解了线性模型，包括线性回归、对数几率回归等等。线性模型形式简单、易于建模，但是蕴含着机器学习中的一些重要的基本思想，并且许多重要的非线性模型也可以在线性模型的基础上引入层级结构或者高维映射得到。此外，线性模型还具有可解释性(comprehensibility,也称为可理解性understandability)。</p><p>基本形式：给定示例x=(x<sub>1</sub>;x<sub>2</sub>;…;x<sub>d</sub>)，x<sub>i</sub>表示x的第i个属性，线性模型即通过各个属性的线性组合进行预测函数：<br>$$<br>f(x)=w_1x_1+w_2x_2+…+w_dx_d+b<br>$$</p><p>向量形式：<br>$$<br>f(x)=\boldsymbol{w}^T\boldsymbol{x}+b\\<br>\boldsymbol{w}=(w_1;w_2;..;w_d)<br>$$</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>给定数据集$D={(x_1,y_1),(x_2,y_2),…,(x_m,y_m)}$，其中$x_i=(x_{i1};x_{i2};….;x_{id}),y_i\in{\mathbb{R}}$，线性代数试图学得:<br>$$<br>f(x_i)=wx_i+b\quad 使得f(x_i)\simeq y_i<br>$$</p><p>求解该模型需要解得$w$和$b$，需要衡量$y_i$和$f(x_i)$之间的差距，一般采用均方误差（又称为平方损失(square loss)）：<br>$$<br>(w^*,b^*)=\mathop{\arg\min}\limits_{(w,b)}\sum_{i=1}^{m}(f(x_i)-y_i)^2\\<br>=\mathop{\arg\min}\limits_{(w,b)}\sum_{i=1}^{m}(y_i-wx_i-b)^2<br>$$</p><p>均方误差具有较好的几何意义，对应常用的欧几里得距离（欧氏距离）。基于均方误差最小化进行模型求解的方法称为最小二乘法（least square method）。求解$w$和$b$使得$E_{(w,b)}=\sum_{i=1}^{m}(y_i-wx_i+b)^2$最小化的过程称为线性回归模型的最小二乘“参数估计”。线性回归模型求解过程如下：</p><ol><li>对$E_{(w,b)}$分别对$w$和$b$求偏导<br>$$<br>\frac{\partial E_{(w,b)}}{\partial w} = 2(w\sum_{i=1}^mx_i^2-\sum_{i=1}^m(y_i-b)x_i),\\<br>\frac{\partial E_{(w,b)}}{\partial w} = 2(mb-\sum_{i=1}^m(y_i-wx_i)),<br>$$</li><li>令偏导值为零可求解出$w$和$b$最优解的闭式解:<br>$$<br>w = \frac{\sum\limits_{i=1}^my_i(x_i-\overline{x})}{\sum\limits_{i=1}^mx_i^2-\frac{1}{m}(\sum\limits_{i=1}^mx_i)^2}\\<br>b = \frac{1}{m}\sum\limits_{i=1}^m(y_i-wx_i),\\<br>其中\overline x=\frac{1}{m}\sum\limits_{i=1}^mx_i<br>$$</li></ol><p>针对更一般的数据集情况，每个样本由$d$个属性组成，则为多元线性回归（又称为多变量线性回归）：<br>$$<br>f(\boldsymbol{x}_i)=\boldsymbol{w}^T\boldsymbol{x}_i+b\quad使得f(\boldsymbol{x}_i)\simeq{y}_i<br>$$<br>便于表达，将$w$和$b$吸收进向量形式$\hat{w}=(w;b)$，相应的需要将数据集表示为m×(d+1)大小的矩阵$\boldsymbol{X}$<br>$$<br>\boldsymbol{X}=\begin{pmatrix}<br>x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1d} &amp; 1 \\<br>x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2d} &amp; 1 \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\<br>x_{m1} &amp; x_{m2} &amp; \ldots &amp; x_{md} &amp; 1 \\<br>\end{pmatrix}<br>$$</p><p>同时将标记写为向量形式$\boldsymbol{y}=(y_1;y_2;\ldots;y_m)$则最佳的$w$为：<br>$$<br>\hat{w}^*=\arg\min\limits_{\hat w}(\boldsymbol{y}-\boldsymbol{X}\hat{w})^T(\boldsymbol{y}-\boldsymbol{X}\hat{wz})<br>$$</p><p>令$E_{\hat{w}}=(\boldsymbol{y}-\boldsymbol{X}\hat{w})^T(\boldsymbol{y}-\boldsymbol{X}\hat{w})$，对$\hat{w}$求导得:<br>$$<br>\frac{\partial E_{\hat{w}}}{\partial\hat{w}}=2\boldsymbol{X}^T{\boldsymbol{X}\hat{w}-y}<br>$$<br>当$\boldsymbol{X}^T\boldsymbol{X}$为满秩矩阵或者正定矩阵，令$\hat{w}$偏导值为零可得：<br>$$<br>\hat{w}^*=(\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T\boldsymbol{y}<br>$$</p><p>其中$(\boldsymbol{X}^T\boldsymbol{X})^{-1}$为$(\boldsymbol{X}^T\boldsymbol{X})$的逆矩阵。令$\hat{x_i}=(x_i;1)$最终学得多元线性回归模型：<br>$$<br>f(\hat{\boldsymbol{x}}_i)=(\boldsymbol X^T\boldsymbol X)^{-1}\boldsymbol X^T\boldsymbol y<br>$$</p><p>然而，$\boldsymbol {X}^T\boldsymbol{X}$往往不是满秩矩阵，例如在许多任务中，样本的变量数目大于样本数，会导致$\boldsymbol{X}$的列数大于行数，$\boldsymbol{X}^T\boldsymbol{X}$显然不是满秩矩阵可以解出多个$\hat{\boldsymbol{w}}$，这时需要对解有所偏好决定，常见的解决方法是引入正则化方法。</p><h2 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h2><p>线性判别分析（Linear Discriminant Analysis，LDA）给定训练样例集，设法将样例投影到一条直线上，使得同类的样例的投影点尽可能接近、异类样例的投影点尽可能远离。算法如下图所示：<br><img src="/2019/07/29/西瓜书-第三章/img1.webp" alt="LDA算法作用"><br>要实现算法，就需要使得类内的协方差尽可能小，类间距离尽可能大。<br>假设数据集为$D=\{(\boldsymbol{x}_i,y_i)\}^m_{i=1},y_i\in\{0,1\}$,令$\boldsymbol X_i、\boldsymbol{\mu}_i、\boldsymbol{\Sigma}_i$分别表示第$i\in\{0,1\}$类示例的集合、均值向量和协方差矩阵。<br>类间最大化目标为:<br>$$<br>\begin{align}<br>J &amp;= \frac{\Vert \boldsymbol{\omega^T\mu_0-\omega^T\mu_1} \Vert^2_2}{\boldsymbol{\omega^T\Sigma_0\omega}+\boldsymbol{\omega^T\Sigma_1\omega}}\\<br>&amp;= \frac{\boldsymbol{\omega^T(\mu_0-\mu_1)(\mu_0-\mu_1)^T\omega}}{\boldsymbol{\omega^T(\Sigma_0+\Sigma_1)\omega}}<br>\end{align}<br>$$</p><p>假定类内散度矩阵为：</p><p>$$<br>\begin{align}<br>\boldsymbol S_\omega &amp;=\boldsymbol{\Sigma_0+\Sigma_1}\\<br>&amp;=\sum_{\boldsymbol x\in\boldsymbol X_0}\boldsymbol{(x-\mu_0){x-\mu_0}^T+\sum_{\boldsymbol x\in\boldsymbol X_1}\boldsymbol{(x-\mu_1)(x-\mu_1)^T}}<br>\end{align}<br>$$<br>类间散度矩阵为：<br>$$<br>\boldsymbol S_b=\boldsymbol{(\mu_0-\mu_1)(\mu_0-\mu_1)^T}<br>$$<br>可将$\boldsymbol J$重写为：<br>$$<br>\boldsymbol J=\boldsymbol{\frac{\omega^TS_b\omega}{\omega^TS_\omega\omega}}<br>$$<br>因为分子分母都有$\boldsymbol\omega$，因此$\boldsymbol J$的解只与$\boldsymbol\omega$的方向有关，与长度无关。可令$\boldsymbol{\frac{\omega^TS_b\omega}{\omega^TS_\omega\omega}}=1$<br>等价于：<br>$$<br>\begin{align}<br>&amp; \min\limits_{\boldsymbol\omega}\ -\boldsymbol{\omega^TS_b\omega}\\<br>&amp; \boldsymbol{s.t.}\ \boldsymbol{\omega^TS_\omega\omega}=1<br>\end{align}<br>$$<br>由拉格朗日乘子法，等价于:<br>$$<br>\boldsymbol{S_b\omega}=\lambda\boldsymbol{S_\omega\omega}<br>$$<br>其中λ拉格朗日乘子，$\boldsymbol{S_b\omega}$方向恒为$\mu_0-\mu_1$，令：<br>$$<br>\boldsymbol{S_b\omega}=\lambda(\mu_0-\mu_1)<br>$$<br>可得:<br>$$<br>\boldsymbol \omega=\boldsymbol{S_\omega^{-1}(\mu_0-\mu_1)}<br>$$<br>为了确保解值的稳定性，在实践中对$\boldsymbol{S_\omega}$进行奇异值分解，即$\boldsymbol{S_\omega}=\boldsymbol U\Sigma\boldsymbol V^T$,$\Sigma$为实对角矩阵对角线上的元素为$\boldsymbol S_\omega$的奇异值，再由$\boldsymbol S^{-1}_\omega=\boldsymbol{V\Sigma^{-1}U^{T}}$得到$\boldsymbol S^{-1}_\omega$得到$\boldsymbol S_\omega$。</p><p>也可以将LDA扩展到多分类任务中。<br>全局散度矩阵:<br>$$<br>\begin{align}<br>\boldsymbol S_t&amp;=\boldsymbol S_b+\boldsymbol S_\omega\\<br>&amp;=\sum^m_{i=1}(\boldsymbol{x_i-\mu})(\boldsymbol{x_i-\mu})^T<br>\end{align}<br>$$<br>其中$\boldsymbol\mu$是所有示例的均值向量，将类内散度矩阵$\boldsymbol S_\omega$重定义为每个类别的散度矩阵之和，即:<br>$$<br>\boldsymbol S_\omega=\sum^N_{i=1}\boldsymbol S_{\omega_i}<br>$$<br>其中$\boldsymbol S_{\omega_i}$为：<br>$$<br>\boldsymbol S_{\omega_i}=\sum_{\boldsymbol x\in X_i}(\boldsymbol x-\boldsymbol\mu_i)(\boldsymbol x-\boldsymbol\mu_i)^T<br>$$<br>可得：<br>$$<br>\begin{align}<br>\boldsymbol S_b&amp;=\boldsymbol S_t-\boldsymbol S_\omega\\<br>&amp;=\sum^N_{i=1}m_i(\boldsymbol\mu_i-\boldsymbol\mu)(\boldsymbol\mu_i-\boldsymbol\mu)^T<br>\end{align}<br>$$<br>多分类LDA可以使用多种实现方法，使用$\boldsymbol S_b,\boldsymbol S_\omega,\boldsymbol S_t$中的两个即可。常见的一种实现是采用优化目标：<br>$$<br>\max_{\boldsymbol W}\frac{tr(\boldsymbol W^T\boldsymbol S_b\boldsymbol W)}{tr(\boldsymbol W^T\boldsymbol S_\omega\boldsymbol W)}<br>$$<br>其中$\boldsymbol W\in\mathbb R^{dx(N-1)}$,tr(·)表示矩阵的迹，可通过$\boldsymbol S_b\boldsymbol W=\lambda\boldsymbol S_\omega\boldsymbol W$求解。</p><h2 id="多分类学习"><a href="#多分类学习" class="headerlink" title="多分类学习"></a>多分类学习</h2><p>拆解法：将多分类任务拆分为若干个二分类任务求解。</p><p>拆分策略：</p><ol><li>One Vs. One,将N类两两组合，使用N(N-1)/2个分类器，投票得出结果</li><li>One Vs. Rest,将N类分为N个1类和（N-1）类分类器分类，根据预测置信进行最终结果判断。</li><li>Many Vs. Many，正类和反类需要特殊设计，OVO和OVR都是MVM的特殊例子。最常用的是ECOC(Error Correcting Output Codes,纠错输出码)</li></ol><h3 id="ECOC算法过程"><a href="#ECOC算法过程" class="headerlink" title="ECOC算法过程"></a>ECOC算法过程</h3><p>ECOC过程分为两步：编码和解码。</p><h4 id="ECOC编码"><a href="#ECOC编码" class="headerlink" title="ECOC编码"></a>ECOC编码</h4><p>对N类进行M次划分，将一部分划为正类，一部分划分为反类，共产生M个数据集，可训练M个二分类器</p><h4 id="ECOC解码"><a href="#ECOC解码" class="headerlink" title="ECOC解码"></a>ECOC解码</h4><p>M个分类器对样本进行预测，这些预测的标记组成一个编码，将这个编码于各自的编码进行比较，返回其中距离最小的类作为最终的预测结果。</p><h4 id="ECOC编码的优点"><a href="#ECOC编码的优点" class="headerlink" title="ECOC编码的优点"></a>ECOC编码的优点</h4><p>ECOC具有一定的容错能力。</p><h3 id="类别不平衡"><a href="#类别不平衡" class="headerlink" title="类别不平衡"></a>类别不平衡</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>类别不平衡（class-imbalance):在分类任务中，不同的类别训练样例数目差别较大的情况。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在二分类中常使用$y=\omega^Tx+b$，常使用y&gt;0.5判断为正例，y&lt;0.5判断为反例，因此决策的规则为$\frac{y}{1-y}&gt;1$时为正例。当正反例数不同时，m<sup>+</sup>表示正例数，m<sup>-</sup>表示反例数，观测几率为$\frac{m^+}{m^-}$因此可以将判断规则调整为$\frac{y}{1-y}&gt;\frac{m^+}{m^-}$为正例。通过“再缩放”调整类间不平衡，$\frac{y’}{1-y’}=\frac{y}{1-y}×\frac{m^-}{m^+}$。</p><p>“再缩放”前提在于无偏采样，但是在实际情概况中是不成立的，因此需采取其他方法：</p><ol><li>对反例进行欠采样(undersampling),欠采样若是简单丢弃样本，可能会丢失一些重要的信息。代表算法：Easy-Ensemble:利用集成学习机制，将反例划分成若干不同的集合共学习器使用。</li><li>对正例进行过采样（upsampling），欠采样不能简单的重复采样，会导致严重的过拟合，应该采用相应的算法：代表SMOTE，在正例中插值产生额外正例。</li><li>使用再缩放的方法，”阈值移动“，同时也是代价敏感学习。</li></ol><p>Many Vs. Many 也可以通过DAG(Direct Acyclic Graph)折分法，将分类划分成树状结构，每个节点对应一个分类器。</p><h4 id="无偏采样"><a href="#无偏采样" class="headerlink" title="无偏采样"></a>无偏采样</h4><p>真实样本中的类别比例在训练集中得以保持。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》作者：周志华</a>；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 西瓜书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西瓜书 </tag>
            
            <tag> 读书 </tag>
            
            <tag> 第三章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成年人看的动漫-《哪吒之魔童降世》</title>
      <link href="/2019/07/29/%E6%88%90%E5%B9%B4%E4%BA%BA%E7%9C%8B%E7%9A%84%E5%8A%A8%E6%BC%AB-%E3%80%8A%E5%93%AA%E5%90%92%E4%B9%8B%E9%AD%94%E7%AB%A5%E9%99%8D%E4%B8%96%E3%80%8B/"/>
      <url>/2019/07/29/%E6%88%90%E5%B9%B4%E4%BA%BA%E7%9C%8B%E7%9A%84%E5%8A%A8%E6%BC%AB-%E3%80%8A%E5%93%AA%E5%90%92%E4%B9%8B%E9%AD%94%E7%AB%A5%E9%99%8D%E4%B8%96%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img1.webp" alt></p><p>昨天打卡了国产动漫–《哪吒之魔童降世》，不愧是国产动漫的良心之作，从剧情到布景，从配乐到人物，可以处处看出制作公司的用心。</p><hr><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>从剧情上来说，既有继承部分，也有创新部分。剧情依托于古代神话传说人物，开始部分补充了哪吒出生前的细节–来源于混元珠的魔丸，同时为故事主体高潮部分埋下伏笔，必会与有同样出生的混元珠的灵珠敖丙有一段纠葛。到高潮部分，命中注定的天劫咒来临，哪吒与敖丙不再是相互厮杀，而是创新的将其设计为携手合作共同度过这一难关。至此，哪吒也完成了人物的转变。总的来说，剧情跌宕起伏，结构完整紧凑，在国产动画中属于佳作。</p><h2 id="布景"><a href="#布景" class="headerlink" title="布景"></a>布景</h2><p>整部动画的布景完整。尤其是在山河社稷图中景色优美精致，体现了国内漫画制作的最高水平，电影院(小厅，非IMAX)第一排的位置能深深体会到3D动画的震撼，尤其配合气味散发器，可以闻到荷花的芬芳、青草的清香、美酒的醇香，让人身临其境。<br><img src="/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img2.webp" alt="山河社稷图剧照（图片来源：&lt;a href=&quot;https://img3.doubanio.com/view/photo/l/public/p2563537631.webp&quot; target=&quot;_blank&quot;&gt;豆瓣电影&lt;/a&gt;)"></p><h2 id="配乐"><a href="#配乐" class="headerlink" title="配乐"></a>配乐</h2><p>配乐部分，主题曲可以说是优秀的。无论是从歌词和配乐方面都是较好的，在电影中播放出来极具感染力，毫无违和感。以下为主题曲原音乐(来源：网易云音乐)。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1378085345&auto=0&height=66"></iframe><h2 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h2><p>人物设计上，最丑的哪吒与最帅的哪吒一体。一出场应该是主角的哪吒却给了一副魔王的外表，总给人一种失落的感觉，但是当看到哪吒的真正的面目的时候，才知道这也是最帅的哪吒。人物的性格设计上，主要角色性格丰满，哪吒自带魔属性，内心渴望被人认可，但是频频被认为是妖怪之后便破罐子破摔；李靖是一个爱子的父亲角色，希望能让虽出身魔丸的哪吒能走上斩妖除魔的正途，甚至不惜牺牲自己也要帮助哪吒度过天劫咒的完美父亲形象。<br><img src="/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img3.webp" alt="最丑哪吒(图片来源：&lt;a href=&quot;https://img3.doubanio.com/view/photo/l/public/p2545645815.webp&quot; target=&quot;_blank&quot;&gt;豆瓣电影&lt;/a&gt;)"><br><img src="/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img4.webp" alt="最帅哪吒(图片来源:(图片来源：&lt;a href=&quot;https://img3.doubanio.com/view/photo/l/public/p2563815623.webp&quot;  target=&quot;_blank&quot;&gt;豆瓣电影&lt;/a&gt;)"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：这是一部成年人的动漫，宣扬着“我命由己不由天”的正面思想，鼓励当代青年，不论出身如何，命运都是由自己掌控的努力奋斗的精神。同时也给国漫带来了一剂强心针，相对《大圣归来》，《哪吒》引入了中国家的概念，刻画了中国家长的形象，并在影片结束时预告了《姜子牙》等一系列封神榜作品，有成为和漫威齐名的封神榜的期望。最后最后，希望国漫越来越好，制作出和国外优质电影相当的动画。</p><p>剧中一首打油诗:<br>“<em>我是小妖怪 逍遥又自在<br>杀人不眨眼 吃人不放盐<br>一口七八个 肚子要撑破<br>茅房去拉屎 想起忘带纸</em>”</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 观影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观影 </tag>
            
            <tag> 动漫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的一些插件</title>
      <link href="/2019/07/25/Hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/07/25/Hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在Hexo中,我们可以方便的写出我们的博客并生成网站，但是一些其他的功能需要使用Hexo的插件。</p><h2 id="Hexo中常用的一些插件"><a href="#Hexo中常用的一些插件" class="headerlink" title="Hexo中常用的一些插件"></a>Hexo中常用的一些插件</h2><ol><li><p>Hexo的Git发布插件(hexo-deployer-git)<br> 1.1. 在博客文件夹根目录下(之后使用Git Bash都默认在此路径下)打开Git Bash执行指令<code>npm install hexo-deployer-git --save</code>安装自动部署插件<br> 1.2. 修改博客文件夹下博客的配置文件，完成配置之后使用<code>hexo deploy</code>或者<code>hexo d</code>发布内容到Git。</p><pre><code> # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy:     type: git     repository: git代码仓库地址     branch: master</code></pre></li><li><p>Hexo的MathJax渲染插件(hexo-math)<br>2.1. Git Bash执行<code>npm install hexo-math --save</code><br>2.2. 设置主题配置文件</p><pre><code># MathJax 数学公式支持mathjax:   on: true #是否启用   per_page: false # 若只渲染单个页面，此选项设为false，页面内加入 mathjax: true</code></pre></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://yelog.org/2017/07/05/3-hexo-mathjax/" target="_blank" rel="noopener">MathJax配置</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书_第二章</title>
      <link href="/2019/07/23/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2019/07/23/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>西瓜书(<em>《机器学习》作者：周志华</em>)第二章为<em>模型评估与选择</em>，主要是讲解模型评价的指标及其概念。</p><h5 id="经验误差"><a href="#经验误差" class="headerlink" title="经验误差"></a>经验误差</h5><p><em>错误率</em>：分类错误的样本数占样本总数的比例。</p><p><em>精度</em>：1-错误率。</p><p><em>误差</em>：学习器的实际预测输出与样本真实输出之间的差异</p><p><em>训练误差</em>：学习器在训练集上的误差。</p><p><em>泛化误差</em>：学习器在新样本上的误差。</p><h5 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h5><p><em>过拟合</em>：学习器将训练样本本身的一些特点当作了所有潜在样本都会具有的一般性质，也称为过配。过拟合的原因主要是学习器学习能力过于强大。</p><p>欠拟合：学习器未将训练样本的一般性质学好，也称为欠配。欠拟合的主要原因是学习器学习能力低下。</p><h5 id="评估模型的方法"><a href="#评估模型的方法" class="headerlink" title="评估模型的方法"></a>评估模型的方法</h5><p>一般评估模型的指标包括泛化能力、时间开销、存储开销和可解释性等方面。在西瓜书中主要考虑模型的泛化能力这个指标。</p><p><em>测试集</em>：用于测试学习器对新样本的判别能力，近似于泛化误差。（我们的假设：<em>测试样本是从样本的真实分布中独立同分布的——在采样的时候也要保证独立同分布</em>）。</p><h5 id="划分测试集和训练集的方法"><a href="#划分测试集和训练集的方法" class="headerlink" title="划分测试集和训练集的方法"></a>划分测试集和训练集的方法</h5><ol><li>留出法:将数据集D划分为两个互斥的集合，分别作为训练集、测试集。注意在划分过程中尽量保持数据一致性，通常使用“分层采样”的方式划分。单次划分的结果不准确，一般采用若干次随机划分，重复实验之后取平均值作为评估结果，同时也可以得到估计结果的标准差。</li><li>交叉验证法：将数据集划分为k个大小相似的互斥子集，子集通过分层采样的方式产生，然后k-1个子集作为训练集，剩下的1个子集作为测试集，可以产生k组测试集/训练集，进行k次训练测试，最终结果为k组的平均值。交叉验证法的稳定性和保真性受k值影响较大。通常将这种方法称为k折交叉验证。同时，子集存在不同的划分方式，一般需要采取多次k折交叉验证随机划分子集，常见的为”10次10折交叉验证“。当k为样本数量时为交叉验证的特例，留一法（<em>Leave-One-Out，简称LOO</em>）。留一法往往实际被评估的模型与期望评估的用D训练出来的模型接近，但是当数据量较大时，计算的开销可能是无法接受的。</li><li>自助法(bootstrapping)：采用自助采样(bootstrapping)为基础，在数据集D基础上，使用自助采样（<em>从数据集中有放回的采样</em>），重复m次，产生m个样本的D’数据集。在数据集中某一样本是可能不被采样的，不被采样的概率为(1-1/m)<sup>m</sup>,取极限可得：<br>$$<br>\lim_\limits{m \to +{\infty}}(1- \frac{1}{m}) = \frac{1}{e} \approx 0.368<br>$$<br>自助法主要用在数据集较小，难以划分训练/测试集时有用，产生的多个数据集也对集成学习有好处，但是由于自助法改变了初始数据的分布，可能会引入估计偏差。</li></ol><h5 id="机器学习参数"><a href="#机器学习参数" class="headerlink" title="机器学习参数"></a>机器学习参数</h5><p>机器学习涉及两类参数:算法的参数(<em>也称作超参数,,数量较少</em>)和模型的参数(<em>数量可能较多</em>)。</p><p>需要注意,通常将学得模型在实际应用中可能遇到的数据称为测试数据，而训练过程中评估测试模型的数据称为验证集。</p><h5 id="模型训练度量"><a href="#模型训练度量" class="headerlink" title="模型训练度量"></a>模型训练度量</h5><ol><li><p>均方误差(<em>mean squared error</em>)：<br>$$<br>E(f;D)=\frac{1}{m}\sum_{i=1}^{m}(f(x_i)-y_i)^2<br>$$<br>对于更一般的数据分布$\mit D$和概率密度函数$p(·)$，均方误差可表示为：<br>$$<br>E(f;\mit D)=\int_{x \sim \mit D}(f(x)-y)^2p(x)dx<br>$$</p></li><li><p>错误率：<br>$$<br>E(f;D) = \frac{1}{m}\sum_{i=1}^m Ⅱ(f(x_i)\neq y_i)<br>$$<br>对于一般情况，数据分布$D$和概率密度函数$p(·)$，错误率为：<br>$$<br>E(f;D)=\int_{x\sim D}Ⅱ(x \neq y)p(x)dx<br>$$</p></li><li><p>精度：<br>$$<br>acc(f;D)=\frac{1}{m}\sum_{i=1}^m Ⅱ(f(x_i)= y_i)\\<br>=1-E(f;D)<br>$$<br>对于一般情况，数据分布$D$和概率密度函数$p(·)$，精度为：<br>$$<br>acc(f;D)=\int_{x\sim D}Ⅱ(f(x)=y)p(x)dx\\<br>=1-E(f;D)<br>$$</p></li></ol><h5 id="查准率、查全率和F1"><a href="#查准率、查全率和F1" class="headerlink" title="查准率、查全率和F1"></a>查准率、查全率和F1</h5><p>对于二分类问题，样本根据真实类别和学习器预测类别分为真正例(true positive,TP)、假正例(false positive,FP)、真反例(true negative,TN)和假反例(false negative,FN)。以下为分类结果混淆矩阵：</p><table>  <tr>    <th rowspan="2">真实情况</th>    <th colspan="2">预测结果</th>  </tr>  <tr>    <td>正例</td>    <td>反例</td>  </tr>  <tr>    <td>正例</td>    <td>TP</td>    <td>FN</td>  </tr>  <tr>    <td>反例</td>    <td>FP</td>    <td>TN</td>  </tr></table><p>查准率P:<br>$$<br>P=\frac{TP}{TP+FP}<br>$$<br>查全率R:<br>$$<br>R=\frac{TP}{TP+FN}<br>$$<br>P-R曲线:查准率-查全率曲线</p><p><img src="/2019/07/23/西瓜书-第二章/img1.jpg" alt="查全率-查全率曲线示意图"></p><p>当一条P-R曲线B包住另外一条曲线C时，说明B曲线的模型性能较另外一个C模型好，当如A，B两条曲线时，比较其平衡点(BEP,查准率=查全率)，A的平衡点值较大，说明A的性能较好。除了BEP之外，还常用F1度量：<br>$$<br>F1=\frac{2×P×R}{P+R}=\frac{2×TP}{样例总数+TP-TN}<br>$$<br>实际上F1是查全率和查准率的调和平均:<br>$$<br>\frac{1}{F1}=\frac{1}{2}·(\frac{1}{P}+\frac{1}{R})<br>$$<br>F1度量更一般的F<sub>β</sub>度量:<br>$$<br>F_\beta=\frac{(1+\beta^2)×P×R}{(\beta^2×P)+R}<br>$$<br>实际上F<sub>β</sub>是查全率和查准率的加权调和平均:<br>$$<br>\frac{1}{F_\beta} = \frac{1}{1+β^2}·(\frac{1}{P}+\frac{β^2}{R})<br>$$<br>F<sub>β</sub>中当β&gt;0时度量查全率对查准率的相对重要性，β=1时为F1。β&gt;1时，查全率有更大影响；β&lt;1时，查准率有更大影响。</p><p>当有多个结果混淆矩阵时，可以先计算各自的查准率和查全率，再计算平均值得到”宏查全率”(macro-R)、”宏查准率”(macro-P)以及”宏F1”(macro-F1):<br>$$<br>macro\text{-}R = \frac{1}{n}\sum_{i=1}^{n}R_i\\<br>macro\text{-}P = \frac{1}{n}\sum_{i=1}^{n}P_i\\<br>macro\text{-}F1 = \frac{2×macro\text{-}P×macro\text{-}R}{macro\text{-}P+macro\text{-}R}<br>$$</p><p>也可以将混淆矩阵先平均再计算平均值，$\overline{TP}$、$\overline{FP}$、$\overline{TN}$、$\overline{FN}$，计算出”微查全率”(micro-R)、”微查准率”(micro-P)以及”微F1”(micro-F1):<br>$$<br>micro\text-R=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}\\<br>micro\text-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}\\<br>micro\text-F1=\frac{2×micro\text{-}P×micro\text{-}R}{micro\text{-}P+micro\text{-}R}<br>$$</p><h5 id="ROC和AUC"><a href="#ROC和AUC" class="headerlink" title="ROC和AUC"></a>ROC和AUC</h5><p>ROC(Receiver Operating Characteristic)：“受试者工作特征”曲线。ROC曲线图的纵轴为”真正例率”(True Positive Rate,TPR),横轴为”假正例率”(False Positive Rate,FPR),定义如下:<br>$$<br>TPR=\frac{TP}{TP+FN}\\<br>FPR=\frac{FP}{TN+FP}<br>$$<br>当ROC的曲线被包住时，说明后者的性能较好。当交叉时，由AUC(Area Under ROC Curve，ROC曲线下面积)决定。当ROC曲线由点{(x<sub>1</sub>,y<sub>1</sub>),(x<sub>2</sub>,y<sub>2</sub>),…,(x<sub>m</sub>,y<sub>m</sub>)}形成时，AUC为:<br>$$<br>AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_i)·(y_i+y_{i+1})<br>$$</p><h5 id="代价敏感错误与代价曲线"><a href="#代价敏感错误与代价曲线" class="headerlink" title="代价敏感错误与代价曲线"></a>代价敏感错误与代价曲线</h5><p>非均等代价（unequal cost）:为权衡不同类型错误所造成的不同损失。<br>在二分类任务中，可以设定”代价矩阵”(cost matrix)</p><table>  <tr>    <th rowspan="2">真实类别</th>    <th colspan="2">预测类别</th>  </tr>  <tr>    <td>第0类</td>    <td>第1类</td>  </tr>  <tr>    <td>第0类</td>    <td>0</td>    <td>cost<sub>01</sub></td>  </tr>  <tr>    <td>第1类</td>    <td>cost<sub>10</sub></td>    <td>0</td>  </tr></table><p><em>Ps:</em>一般情况下，重要的是代价的比值而不是绝对值，cost<sub>01</sub>=100,cost<sub>10</sub>=50与cost<sub>01</sub>=2,cost<sub>10</sub>=1效果是等价的。</p><p>“代价敏感”(cost-sensitive)错误率为：<br>$$<br>E(f;D;cost)=\frac{1}{m}(\sum_{x_i\in D^+}Ⅱ(f(x_i)\neq y_i)×cost_{01}+\sum_{x_i\in D^-}Ⅱ(f(x_i)\neq y_i)×cost_{10})<br>$$<br>在非均等代价之下，ROC不能准确表示总体代价，需要以”代价曲线”(cost curve)衡量总体代价。代价曲线的横轴是取值为[0,1]的正概率代价：<br>$$<br>P(+)cost=\frac{p×cost_{01}}{p×cost_{01}+(1-p)×cost_{10}}<br>$$<br>其中p是样例为正类的概率；纵轴为取值[0,1]的归一化代价<br>$$<br>cost_{norm}=\frac{FNR×p×cost_{01}+FPR×(1-p)×cost_{10}}{p×cost_{01}+(1-p)×cost_{10}}<br>$$<br>总体代价为围成的面积，代价曲线如下:</p><p><img src="/2019/07/23/西瓜书-第二章/img2.jpg" alt="代价曲线与期望总体代价"></p><p>规范化(normalization):将不同变化范围的值映射到相同的固定范围中，常见的为[0,1]，此时称为”归一化”。</p><h5 id="比较检验"><a href="#比较检验" class="headerlink" title="比较检验"></a>比较检验</h5><p>在现实中，我们使用测试误差$\hat{\epsilon}$假设为模型的泛化误差$\epsilon$。因此，泛化误差为$\epsilon$的模型测得测试误差为$\hat\epsilon$的概率为:<br>$$<br>P(\hat\epsilon;\epsilon)={m \choose \hat\epsilon×m}\epsilon^{\hat\epsilon×m}(1-\epsilon)^{m-\hat\epsilon×m}<br>$$<br><em>以下内容为略读</em></p><p>交叉验证t检验：</p><p>McNemar检验:</p><p>Friedman检验和Nemenyi后续检验:</p><h5 id="偏置和方差-略"><a href="#偏置和方差-略" class="headerlink" title="偏置和方差(略)"></a>偏置和方差(略)</h5><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><blockquote><p><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》作者：周志华</a>；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 西瓜书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西瓜书 </tag>
            
            <tag> 读书 </tag>
            
            <tag> 第二章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo结合MathJax编辑公式</title>
      <link href="/2019/07/22/Hexo%E7%BB%93%E5%90%88MathJax%E7%BC%96%E8%BE%91%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/07/22/Hexo%E7%BB%93%E5%90%88MathJax%E7%BC%96%E8%BE%91%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Hexo默认使用marked渲染引擎(hexo-renderer-marked)，该引擎因为会将<code>_内容_</code>首先转化为Html的em标签，导致MathJax公式显示错误。因此，在写MathJax公式时，需要对符号进行转义。以下为需要转义的符号</p><table><thead><tr><th align="center">MathJax</th><th align="center">Markdown</th></tr></thead><tbody><tr><td align="center"><code>_</code></td><td align="center"><code>\_</code></td></tr><tr><td align="center"><code>\\</code></td><td align="center"><code>\\\\</code></td></tr></tbody></table><p>示例代码：</p><pre><code>$$f(n) = \\begin{cases}n\_2,  &amp; \text{if $n$ is even} \\\\n\_1, &amp; \text{if $n$ is odd}\\end{cases}$$</code></pre><p>$$<br>f(n) =<br>\begin{cases}<br>n_2,  &amp; \text{if $n$ is even} \\<br>n_1, &amp; \text{if $n$ is odd}<br>\end{cases}<br>$$</p><p>如果以后有更好的解决方式，则将Markdown文件代码进行替换就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> 新手 </tag>
            
            <tag> 公式编辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书_符号表</title>
      <link href="/2019/07/22/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%A6%E5%8F%B7%E8%A1%A8/"/>
      <url>/2019/07/22/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="主要符号表"><a href="#主要符号表" class="headerlink" title="主要符号表"></a>主要符号表</h5><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">$x$</td><td align="center"><em>标量</em></td></tr><tr><td align="center">$\boldsymbol x$</td><td align="center"><em>向量</em></td></tr><tr><td align="center">x</td><td align="center"><em>变量集</em></td></tr><tr><td align="center">$A$</td><td align="center"><em>矩阵</em></td></tr><tr><td align="center">$I$</td><td align="center"><em>单位阵</em></td></tr><tr><td align="center">$\chi$</td><td align="center"><em>样本空间或状态空间</em></td></tr><tr><td align="center">$D$</td><td align="center"><em>概率分布</em></td></tr><tr><td align="center">D</td><td align="center"><em>数据样本（数据集）</em></td></tr><tr><td align="center">$H$</td><td align="center"><em>假设空间</em></td></tr><tr><td align="center">H</td><td align="center"><em>假设集</em></td></tr><tr><td align="center">$\xi$</td><td align="center"><em>学习算法</em></td></tr><tr><td align="center">$(·,·,·)$</td><td align="center"><em>行向量</em></td></tr><tr><td align="center">$(·;·;·)$</td><td align="center"><em>列向量</em></td></tr><tr><td align="center">$(·)^T$</td><td align="center"><em>向量或矩阵的转置</em></td></tr><tr><td align="center">$\{···\}$</td><td align="center"><em>集合</em></td></tr><tr><td align="center">$P(·),P(·|·)$</td><td align="center"><em>概率质量函数，条件概率质量函数</em></td></tr><tr><td align="center">$p(·),p(·|·)$</td><td align="center"><em>概率密度函数，条件概率密度函数</em></td></tr><tr><td align="center">$\mathbb{E}_{·\sim D}[f(·)]$</td><td align="center"><em>函数$f(·)$对·在分布$D$下的数学期望;意义明确时将省略$D$和(或)$.$</em></td></tr><tr><td align="center">$sup(·)$</td><td align="center"><em>上确界</em></td></tr><tr><td align="center">$\Bbb{Ⅱ}(·)$</td><td align="center"><em>指示函数，在$·$为真和假时分别取值为1,0</em></td></tr><tr><td align="center">$sign(·)$</td><td align="center"><em>符号函数，在$·\lt{0},\ = 0, \gt 0$时分别取值为-1,0,1</em></td></tr></tbody></table><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><blockquote><p><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》作者：周志华</a>；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 西瓜书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西瓜书 </tag>
            
            <tag> 符号表 </tag>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github Pages开启你的个人博客</title>
      <link href="/2019/07/21/hexo-github-pages%E5%BC%80%E5%90%AF%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/07/21/hexo-github-pages%E5%BC%80%E5%90%AF%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>作为一名技术肥宅，记录下辛辛苦苦捣鼓一天的成果，具有重要的意义。博客，就是这样一个记录下肥宅们修炼过程的工具。根据初级肥宅们的实际情况，提出Hexo+Github Pages的博客方案，具有<em>成本低（免费）、免维护和使用方便</em>等优点，深受大家的追捧和喜欢。</p><p>下面就让我们开启个人博客的大门吧。</p><h5 id="提前做好的工作"><a href="#提前做好的工作" class="headerlink" title="提前做好的工作"></a>提前做好的工作</h5><ul><li>Github账号;</li><li>Git工具;</li><li>NodeJS安装包（<a href="https://nodejs.org" target="_blank" rel="noopener">NodeJS官网</a>下载对应版本的安装包）;</li><li>Markdown编辑软件（<strong><em>非必须</em></strong>，作者使用<a href="https://www.typora.io" target="_blank" rel="noopener">Typora</a>进行Markdown文档编辑）。</li></ul><h5 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h5><ol><li>访问NodeJS官网，下载对应版本的安装包。</li></ol><p>作者在电脑上安装了Windows平台的NodeJS，版本为<code>v10.15.3</code>。</p><h5 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h5><ol><li>执行<code>node -v</code>和<code>npm -v</code>命令，正常运行则NodeJS环境正常。</li><li>打开Git Bash工具。</li><li>执行命令<code>npm install hexo-cli -g</code>，等待执行完成，Hexo成功安装。</li></ol><h5 id="开启GIthub-Pages"><a href="#开启GIthub-Pages" class="headerlink" title="开启GIthub Pages"></a>开启GIthub Pages</h5><p>在Github上新建一个名为<code>Git账号用户名.github.io</code>的代码仓库，一般情况下等待10至30分钟就可以通过访问<a href="https://用户名.github.io" target="_blank" rel="noopener">https://用户名.github.io</a>访问到你新建的Github Pages网页。若超过30分钟检查代码仓库的名称是否正确，中间步骤是否操作正确。</p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img1.jpg" alt="使用Github账户创建新的代码仓库，确保名称为&#39;用户名.github.io&#39;"></p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img2.jpg" alt="打开新建代码仓库的设置页面"></p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img3.jpg" alt="找到Github Pages设置项，选择&#39;Choose a theme&#39;"></p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img4.jpg" alt="选择一个主题，确认"></p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img5.jpg" alt="确认index.md内容，提交修改，完成Github Pages的初始化"></p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img6.jpg" alt="查看设置页面的Github Pages项，发现可以通过&#39;https://用户名.github.io&#39;地址访问，Github Pages成功开启"></p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img7.jpg" alt="访问链接后，可以看到Github Pages的效果"></p><h5 id="本地新建博客"><a href="#本地新建博客" class="headerlink" title="本地新建博客"></a>本地新建博客</h5><ol><li><p>打开Git Bash（本文之后未提到打开的路径则默认在博客文件夹处打开并执行相关的命令）；</p></li><li><p>执行命令<code>hexo init 博客文件夹名称</code>；</p></li><li><p>执行命令<code>cd 博客文件夹</code>；</p></li><li><p>运行<code>hexo server</code>或者<code>hexo s</code>；</p></li><li><p>浏览器访问”<a href="http://127.0.0.1:4000&quot;" target="_blank" rel="noopener">http://127.0.0.1:4000&quot;</a> 或者 “<a href="http://localhost:4000&quot;可以看到新建的博客。" target="_blank" rel="noopener">http://localhost:4000&quot;可以看到新建的博客。</a></p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img8.jpg" alt="新建博客页面"></p></li></ol><h5 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h5><ol><li>在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题网站</a>上选择喜欢的主题，找到对应的Github地址，执行命令<code>git clone Github地址 themes/主题名</code>;</li><li>修改并保存博客文件夹的_config.yml中的主题选项：<pre><code>theme: 主题名</code></pre></li><li>修改主题文件夹下的_config.yml，修改并保存主题配置;</li><li>成功更换主题。</li></ol><h5 id="编辑文章"><a href="#编辑文章" class="headerlink" title="编辑文章"></a>编辑文章</h5><ol><li>新建博客：通过<code>hexo new &quot;文章标题&quot;</code>命令新建文章，文章路径为<code>博客文件夹/source/_post/文章标题.md</code>;</li><li>编辑博客： 使用MarkDown工具编辑保存，作者使用<a href="https://www.typora.io" target="_blank" rel="noopener">Typora</a>进行编辑。</li></ol><h5 id="本地博客同步到Github-Pages"><a href="#本地博客同步到Github-Pages" class="headerlink" title="本地博客同步到Github Pages"></a>本地博客同步到Github Pages</h5><ol><li><p>打开Git Bash；</p></li><li><p>安装部署工具，运行<code>npm install hexo-deployer-git --save</code>,完成即已安装部署工具；</p></li><li><p>编辑博客根目录下的配置文件–”_config.yml”,修改同步配置地址;</p><p><img src="/2019/07/21/hexo-github-pages开启你的个人博客/img9.jpg" alt="填入部署信息，保存配置文件"></p></li><li><p>运行<code>hexo deploy</code>或者<code>hexo d</code>即可将博客同步到Github Pages(Ps:<em>若修改了博客内容，需要通过<code>hexo generate</code>或者<code>hexo g</code>命令重新构建博客之后运行同步命令</em>)。</p></li></ol><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><blockquote><p>使用hexo+github搭建免费个人博客详细教程：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#搭建github博客" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#搭建github博客</a>；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git实现博客和主题的备份和同步</title>
      <link href="/2019/07/21/git%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5/"/>
      <url>/2019/07/21/git%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E5%92%8C%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>当各位小伙伴们通过Github 或者其他方式开通了个人的博客的时候，心中肯定有个问题：如何保证我们辛辛苦苦写的博客的安全以及不同设备上的同步。本文通过使用GitHub实现博客和主题的备份和同步。</p><h5 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h5><blockquote><p>GitHub账号一个</p><p>Git 2.18.0 windows </p><p>Hexo博客</p></blockquote><h5 id="备份与同步博客和主题"><a href="#备份与同步博客和主题" class="headerlink" title="备份与同步博客和主题"></a>备份与同步博客和主题</h5><ol><li><p>找到喜欢的主题，并在作者的Github主页fork出代码仓库，配置合适的主题，并同步上传。</p><p>  在代码主页使用fork功能同步作者的代码。</p><p> <img src="/2019/07/21/git实现博客和主题的备份和同步/img1.jpg" alt="fork主题代码仓库"></p><p> 使用<code>git clone fork仓库地址</code>获取代码,修改作者的主题代码以满足个人博客的需要，使用<code>git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push</code>命令同步修改到Github。</p><p> 至此，完成主题代码的备份。以后可以使用git的merge功能将作者更新的代码合并，<em>而不需要重新配置主题</em>。</p></li><li><p>新建一个代码仓库，用于同步博客开发内容。</p></li><li><p>将博客与远程仓库建立联系。</p><p> 使用<code>git init</code>命令将Hexo博客文件夹初始化为本地代码仓库。</p><p> <img src="/2019/07/21/git实现博客和主题的备份和同步/img2.jpg" alt="初始化本地代码仓库"></p><p> 使用<code>git remote add origin 远程代码仓库地址</code>等命令将本地代码仓库与远程代码仓库建立联系，并且同步博客内容到Github。</p><p> <img src="/2019/07/21/git实现博客和主题的备份和同步/img3.jpg" alt="本地代码仓库与远程代码仓库建立联系"></p></li><li><p>将主题作为博客的子模块添加到Hexo</p><p> 使用<code>git submodule add 主题远程代码仓库地址 themes/3-hexo</code>命令使用git的子模块将博客和主题建立联系。</p><p> <img src="/2019/07/21/git实现博客和主题的备份和同步/img4.jpg" alt="博客添加主题子模块"></p><p> 最后将博客的修改内容同步到Github，完成博客的备份和同步的功能。</p></li></ol><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><blockquote><p> Hexo使用子模块来管理theme:<a href="https://xiongyingqi.com/2019/02/01/use-git-submodules" target="_blank" rel="noopener">https://xiongyingqi.com/2019/02/01/use-git-submodules</a></p><p>将本地仓库与远程仓库建立联系:<a href="https://blog.csdn.net/wet5649/article/details/82869831" target="_blank" rel="noopener">https://blog.csdn.net/wet5649/article/details/82869831</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书_第一章</title>
      <link href="/2019/07/19/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2019/07/19/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>西瓜书是人工智能的入门书籍。在书中讲解了机器学习的常用方法及其解释。</p><p>第一章 绪论主要讲解一些基础的概念性的东西。</p><h5 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h5><ol><li><p>按照学习任务划分：</p><ul><li>分类<ul><li>多分类<ul><li>二分类<ul><li>正类</li><li>反类</li></ul></li><li>多分类</li></ul></li></ul></li><li>回归</li></ul></li><li><p>按照训练数据是否有标记信息划分：</p><ul><li>监督学习（有导师学习）</li><li>无监督学习（无导师学习）</li></ul></li></ol><h5 id="归纳与演绎"><a href="#归纳与演绎" class="headerlink" title="归纳与演绎"></a>归纳与演绎</h5><p>科学推理的两大基本手段：归纳、演绎</p><p><em>归纳</em>:从具体事实归结出一般性规律。</p><p><em>演绎</em>:从基础原理推演出具体状况。</p><h5 id="奥卡姆剃刀"><a href="#奥卡姆剃刀" class="headerlink" title="奥卡姆剃刀"></a>奥卡姆剃刀</h5><p>奥卡姆剃刀:若有多个假设与观察的一致，则选用最简单的那个。</p><h5 id="NFL定理"><a href="#NFL定理" class="headerlink" title="NFL定理"></a>NFL定理</h5><p>”没有免费的午餐“定理：（<em>No Free Lunch Theorem, 简称NFL定理</em>）:无论学习算法ξ<sub>α</sub>聪明或者笨拙，他们的期望性都是相同的。</p><p>因此NFL定理说明，脱离具体问题，空泛的谈论哪种学习算法更好是没有意义的。</p><h5 id="流动推销员问题"><a href="#流动推销员问题" class="headerlink" title="流动推销员问题"></a>流动推销员问题</h5><p>已知一个由n个城市(节点)组成的网络，任意两个城市V<sub>i</sub>到V<sub>j</sub>的距离为D<sub>ij</sub>(<em>一般D<sub>ij</sub>≠D<sub>ji</sub></em>)，一个推销员从V<sub>1</sub>开始访问每一个城市一次且仅一次，最后返回V<sub>1</sub>。这个推销员应该如何选择线路使得行程最短？<em>(Ps:该问题中涉及到NP问题)</em></p><h5 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h5><p>NP问题：指存在多项式算法能够验证的非决定性问题。</p><h5 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h5><p>数据挖掘就是从海量的数据中发掘知识。数据库领域的研究为数据挖掘提供数据管理技术。而机器学习和统计学的研究为数据挖掘提供数据分析技术。</p><p>数据挖掘使得搜索引擎成为人们心有灵犀的工具，美国《新闻周刊》曾对谷歌有一句话的评论：”它使任何人离任何问题的答案间的就变得只有点击以下鼠标这么远“。</p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><blockquote><p><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》作者：周志华</a>；</p><p>参考部分网络文献资料。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 西瓜书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西瓜书 </tag>
            
            <tag> 读书 </tag>
            
            <tag> 第一章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown入门</title>
      <link href="/2019/07/18/markdown%E5%85%A5%E9%97%A8/"/>
      <url>/2019/07/18/markdown%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>Markdown源码如下:</strong></p><pre><code class="markdown">展示的是一级标题==============展示的是二级标题-------------------------# 这也是一级标题## 这是二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题七级标题是不可能七级的展示的是一级标题==============展示的是二级标题------------# 这也是一级标题## 这是二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题RUN flow me  *斜体文本*_斜体文本_**粗体文本*****斜粗体文本***___斜粗体文本___分割线---***___- - -* * *_ _ _~~这个是删除线~~&lt;u&gt;这个是下划线&lt;/u&gt;菜鸟教程[^RUNOOB]真的好用* 第一项  + 第二项- 第三项1. 第一项2. 第二项3. 第三项###### 以下是列表嵌套1. 第一项    - 第一小点    - 第二小点2. 第二项    - 第一小点区块&gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想&gt; 最外层&gt; &gt; 第一层&gt; &gt;&gt; &gt; &gt; 第二层区块中使用列表&gt; 1. 1&gt; 2. 2&gt; * 第一&gt; * 第二* 列表中使用区块    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想`print()`函数```php    &lt;?php    echo &#39;RUNOOB&#39;;    function test() {        echo &#39;test&#39;;    }``````python​import numpy as np​from keras.models import load_model​​if __name__ == &quot;__main__&quot;:​print(123)```这是一个链接[百度一下，你就知道](https://www.baidu.com)&lt;https://www.baidu.com&gt;高级链接**链接可以用变量代替，文档末附带变量地址**这个链接使用1作为网址变量 [Baidu][1]使用百度代替网址变量[百度][百度]__图片语法__![百度][2]![图片 百度](https://www.baidu.com/favicon.ico&quot;百度logo&quot;)**可使用img标签指定图片宽度**&lt;img src=&quot;https://www.baidu.com/favicon.ico&quot; width=&quot;50%&quot;&gt;| 表头 | 表头|| :---: | :---:|| 单元格 | 单元格 || 单元格 | 单元格 |[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！[1]: https://www.baidu.com[百度]: https://www.baidu.com[2]: https://www.baidu.com/favicon.ico</code></pre><p><strong>Markdown展现效果如下:</strong></p><h1 id="展示的是一级标题"><a href="#展示的是一级标题" class="headerlink" title="展示的是一级标题"></a>展示的是一级标题</h1><h2 id="展示的是二级标题"><a href="#展示的是二级标题" class="headerlink" title="展示的是二级标题"></a>展示的是二级标题</h2><h1 id="这也是一级标题"><a href="#这也是一级标题" class="headerlink" title="这也是一级标题"></a>这也是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>七级标题是不可能七级的</p><p>RUN flow me  </p><p><em>斜体文本</em></p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><strong><em>斜粗体文本</em></strong></p><p><strong><em>斜粗体文本</em></strong></p><p>分割线</p><hr><hr><hr><hr><hr><hr><p><del>这个是删除线</del></p><p><u>这个是下划线</u></p><p>菜鸟教程[^RUNOOB]真的好用</p><ul><li>第一项  </li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h6 id="以下是列表嵌套"><a href="#以下是列表嵌套" class="headerlink" title="以下是列表嵌套"></a>以下是列表嵌套</h6><ol><li>第一项<ul><li>第一小点</li><li>第二小点</li></ul></li><li>第二项<ul><li>第一小点</li></ul></li></ol><p>区块</p><blockquote><p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote><blockquote><p>最外层</p><blockquote><p>第一层</p><blockquote><p>第二层</p></blockquote></blockquote></blockquote><p>区块中使用列表</p><blockquote><ol><li>1</li><li>2</li></ol><ul><li>第一</li><li>第二</li></ul></blockquote><ul><li>列表中使用区块<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li></ul><p><code>print()</code>函数</p><pre><code class="php+HTML">&lt;?phpecho &#39;RUNOOB&#39;;function test() {    echo &#39;test&#39;;}</code></pre><pre><code class="python">import numpy as npfrom keras.models import load_modelif __name__ == &quot;__main__&quot;:    print(123)print(&#39;this is python language.&#39;)</code></pre><p>这是一个链接<a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下，你就知道</a></p><p><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p><p>高级链接<br><strong>链接可以用变量代替，文档末附带变量地址</strong><br>这个链接使用1作为网址变量 [Baidu][1]<br>使用百度代替网址变量[百度][百度]</p><p><strong>图片语法</strong><br>![百度][2]<br><img src="https://www.baidu.com/favicon.ico" alt="图片 百度" title="log"></p><p><strong>可使用img标签指定图片宽度</strong><br><img src="https://www.baidu.com/favicon.ico" width="50%"></p><table><thead><tr><th align="center">表头</th><th align="center">表头</th></tr></thead><tbody><tr><td align="center">单元格</td><td align="center">单元格</td></tr><tr><td align="center">单元格</td><td align="center">单元格</td></tr></tbody></table><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！<br>[1]: <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a><br>[百度]: <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a><br>[2]: <a href="https://www.baidu.com/favicon.ico" target="_blank" rel="noopener">https://www.baidu.com/favicon.ico</a></p><p><em>Ps:本文参考<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 标签 </tag>
            
            <tag> 语法 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
