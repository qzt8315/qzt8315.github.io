<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>8315的博客</title>
  
  <subtitle>每天就是发现困难，克服困难</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qzt8315.github.io/"/>
  <updated>2019-12-18T06:11:07.187Z</updated>
  <id>http://qzt8315.github.io/</id>
  
  <author>
    <name>捌叁壹伍</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux用户及权限管理</title>
    <link href="http://qzt8315.github.io/2019/11/17/linux%E7%94%A8%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://qzt8315.github.io/2019/11/17/linux用户及权限管理/</id>
    <published>2019-11-17T03:58:41.000Z</published>
    <updated>2019-12-18T06:11:07.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次使用linux系统我们都需要登录，用户在登录过程中起到重要的作用。本篇博客主要讲解用户及其管理的相关内容。</p><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>用户是使用linux的前提，只有经过了linux的用户认证才能正常使用系统。那么在系统内部是怎么实现这样的机制的。</p><h3 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h3><p>对于计算机而言，只会识别0和1构成的二进制，对文字识别较差，因此如果用一个数字来表示一个用户的话会比较方便。linux系统是一个多人多任务系统，仅仅只有单个的用户显然是不合理的，多个用户也可以存在某种关系，比如说共同开发一个项目，那么这些成员应该同时属于同一个工作组，共享某些资源，因此也存在组的概念。和用户一样，用户组组也是用唯一的数字标识的。用户用UID标识，用户组使用GID标识。</p><h4 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h4><p>人和计算机存在认知的差别，计算机只对数字敏感，人对文字敏感，因此在人们使用linux系统的时候通常都是通过用户的名称来进行操作的，而在系统内部都是转化为数字，因此需要在硬盘上记录下用户名和用户标识的对应关系。linux使用<code>/etc/passwd</code>来记录。</p><p><img src="/2019/11/17/linux用户及权限管理/img1.webp" alt="/etc/passwd文件内容"></p><p>打开这个文件，里边有非常多的内容，其中就能看到熟悉的root用户和登录使用的test用户，还有一些伪用户。这些伪用户是为了方便系统管理，满足相应的系统进程对文件属主的要求 ，删除之后可能会导致严重的系统问题，不能将其删除。</p><p>在passwd文件中每一行记录一个用户的资料，每一行有7栏分别用‘:’分隔，没有内容的栏位为空。分别表示：</p><pre><code>用户名:密码(一般为x,密码单独存储在/etc/shadow):用户标识码(UID):用户组标识码(GID):用户说明:家目录:登录成功后执行的命令</code></pre><p><strong>用户名</strong>：日常使用系统登录时所使用的名字。使用’用户名’+’密码’即可登录系统。</p><p><strong>密码</strong>:目前使用的linux一般都不会将密码直接存储在<code>/etc/passwd</code>文件中，考虑到安全问题一般会存放在<code>/etc/shadow</code>文件中。这个栏位一般为’x’或‘*’。</p><p><strong>用户标识</strong>:在linux系统内部是依靠用户标识(UID)来辨识用户的，每一个用户一般会有唯一一个UID(一般UID为0的可能有多个，都是系统管理员)。并且UID分配具有一定的规律，可以查看<code>/etc/login.defs</code>文件获知，规律如下表所示:</p><table><thead><tr><th align="center">UID范围</th><th align="center">用户</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">表示系统管理员，要让其他用户具有root权限，即把该用户的UID改为0即可。一般不建议有多个系统管理员</td></tr><tr><td align="center">1~999</td><td align="center">系统用户，也就是伪用户，是系统为了使用较小的权限启动某些服务，减少root用户使用。Centos7中伪用户的范围为‘1~999’（其他的一些系统可能是1~499），一般是安装软件或者服务的时候创建。普通用户一般从1000开始，最大已经可以到（2^32-1）。(需要注意的是:1~200是系统自建系统用户的范围，用户自建系统用户一般是201~999)</td></tr><tr><td align="center">1000~60000</td><td align="center">普通用户</td></tr></tbody></table><p><strong>用户组标识</strong>:用户组的标识数字。</p><p><strong>用户说明</strong>:对账户的意义进行说明。</p><p><strong>家目录</strong>:指定家目录地址。</p><p><strong>登录成功后执行的命令</strong>：一般指定登录之后使用的shell。</p><h4 id="用户密码"><a href="#用户密码" class="headerlink" title="用户密码"></a>用户密码</h4><p>上文中说到，在较新的系统里边，密码加密之后存放在<code>/etc/shadow</code>里边。用普通的用户是无法读取该文件的，因为文件的权限为所有人<strong>都不允许</strong>读写，因此需要通过<code>su -</code>切换到root用户之后读取该文件，强烈不建议修改该文件的权限，因为修改该文件权限可能会导致系统安全问题(如用户密码泄露)。</p><p><img src="/2019/11/17/linux用户及权限管理/img2.webp" alt="/etc/shadow文件内容"></p><p><code>/etc/shadow</code>文件结构与<code>/etc/passwd</code>类似，每一行记录一个用户内容，用’:’分隔为9个栏位，分别表示:</p><pre><code>用户名:密码密文:最近密码修改日期:密码不可修改天数:密码有效天数:密码失效前警告天数:密码失效后宽限天数:用户失效日期:保留</code></pre><p><strong>密码密文</strong>:用户对应的密码加密之后的密文。在前面加入’*’或者’!’可以暂时禁止用户登录。</p><p><strong>最近密码修改日期</strong>:最近一次修改密码的日期。</p><p><strong>密码不可修改天数</strong>:密码修改之后的指定天数内不能再次修改密码。</p><p><strong>密码有效天数</strong>:据上次密码修改之后指定天数后用户需要修改密码。</p><p><strong>密码失效前警告天数</strong>:在密码需要修改前指定天数开始警告用户修改密码。</p><p><strong>密码失效后宽限天数</strong>:在密码过期后的指定天数内还可以使用该密码（宽限修改密码时间）。</p><p><strong>用户失效日期</strong>:在密码失效日期之后账户将不能再次登录使用。</p><p><strong>保留</strong>:为未来新功能保留。</p><h4 id="GID"><a href="#GID" class="headerlink" title="GID"></a>GID</h4><p>GID就是用户组标志。而用户组的基本信息放在<code>/etc/group</code>文件中。该文件中的信息也是一个用户组占一行，用’:’分隔为4栏。</p><pre><code>用户组名称:用户组密码:GID:此用户组支援账户名称</code></pre><p><strong>用户组名称</strong>:该用户组的名称。</p><p><strong>用户组密码</strong>:该用户组的密码，一般是给用户组管理员设置密码。用户组的密码不会直接记录在该栏位，密文会记录在<code>/etc/gshadow</code>中，该栏位一般记录为’x’。</p><p><strong>GID</strong>:用户组的ID。</p><p><strong>此用户组支援账户名称</strong>:加入该用户组的用户名称。</p><h4 id="用户组密码"><a href="#用户组密码" class="headerlink" title="用户组密码"></a>用户组密码</h4><p>用户组是可以通过用户组管理员进行管理的，通常会给组的管理员设置密码，那么这些内容都是存放在<code>/etc/gshadow</code>文件中的。</p><p>和存放用户密码的文件相同，该文件只有root用户可以读取，因此在读取该文件内容前应该先转化为root用户。该文件也是一行保存一个用户组资料，用’:’分隔出4个栏位，分别表示:</p><pre><code>用户组名称:密码密文:组管理员:此用户组支援账户名称</code></pre><p><strong>用户组名称</strong>:用户组的名称，与<code>/etc/group</code>中的名称相对应。</p><p><strong>密码密文</strong>:该密码是用于组管理员进行组管理的。</p><p><strong>组管理员</strong>:该用户组的管理员，现在组管理员使用较少了，一般使用<code>sudo</code>一类的指令。</p><p><strong>此用户组支援账户名称</strong>:和<code>/etc/group</code>中的字段一样。</p><h4 id="有效用户组和初始用户组"><a href="#有效用户组和初始用户组" class="headerlink" title="有效用户组和初始用户组"></a>有效用户组和初始用户组</h4><p><strong>有效用户组</strong>:就是指在创建文件或者路径时填入的所属用户组。</p><p><strong>初始用户组</strong>:就是在登录用户之后即可获得该用户组权限的用户组。也就是<code>/etc/passwd</code>文件中记录的GID所对应的用户组。</p><h5 id="查看自己所属的用户组"><a href="#查看自己所属的用户组" class="headerlink" title="查看自己所属的用户组"></a>查看自己所属的用户组</h5><p>使用<code>groups</code>命令即可查看所属的用户组，排在第一位的用户组即为<strong>有效用户组</strong>。</p><h5 id="切换有效群组"><a href="#切换有效群组" class="headerlink" title="切换有效群组"></a>切换有效群组</h5><p>使用<code>newgrp group</code>即可在新的shell环境中将<strong>有效用户组</strong>切换为指定用户组，特别需要注意的是，由于是在新环境中切换的有效用户组，在使用结束后要使用<code>exit</code>退出环境。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>新增用户主要是使用<code>useradd</code>和<code>passwd</code>两个指令。</p><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>以下为<code>useradd</code>的使用:</p><pre><code>useradd [-u UID] [-g 初始用户组] [-G 附加用户组] [-mM] [-c 用户说明] [-d 家目录绝对地址] [-s shell] 用户名解释:-g 指定该参数之后，即不会创建与用户名同名的用户组；-m 强制！要创建使用者的家目录(一般用户的预设值)；-M 强制！不要创建使用者的家目录(系统用户的预设值)；-c /etc/passwd中用户说明栏内容，可以随便填入信息，默认为空；-d 指定新建用户的家目录，一定要使用绝对路径；-s 这个就是登录成功后执行的命令，指定使用的shell；-r 指定建立一个系统用户，UID属于系统用户范围，在当前使用的系统中范围为201~999，可通过文档/etc/login.defs查看；-e 账户失效日期，日期指定格式&#39;YYYY-MM-DD&#39;；-f 账户密码有效天数，-1表示永不用修改密码。注意：系统一般会有默认的用户添加的设置，在使用&#39;useradd username&#39;命令之后，默认的设置一般为:创建一般用户,新建和用户名相同的用户组并且将此用户组作为该用户的初始用户组，默认没有附加用户组和用户说明，默认使用&#39;/home/username&#39;作为用户的家目录，使用bash作为默认shell。useradd的默认设置也可以通过&#39;useradd -D&#39;命令查看（其实就是/etc/default/useradd文件指定的）。默认操作的文件是:`/etc/passwd`、&#39;/etc/shadow&#39;、&#39;/etc/group&#39;和&#39;/home/username&#39;</code></pre><p><img src="/2019/11/17/linux用户及权限管理/img3.webp" alt="useradd命令默认设置,注意:useradd命令执行需要root权限，所以需要在root用户下执行才能查看。"></p><p>上图参数解释:<br><strong>GROUP=100</strong>表示的是在创建用户时使用的初始用户组的ID为100也就是<code>users</code>用户组，这个根据不同发行版而有不同的设置，总的来说就是两种用户组的机制不同。CentOS系统采用的是<strong>私有用户组机制</strong>:即在创建用户的时候会新建一个同名的用户作为该用户的初始用户组，且家目录的权限设置为700，除该路径的所有者外其他用户都不能使用该目录，使用这种机制不会考虑GROUP=100这个设定，较为安全。还有一种机制是<strong>公共用户组机制</strong>:即会参考GROUP=100这个设定，将<code>users</code>用户组作为新建用户的初始用户组。一般家目录预设的权限为:755，大家都可以分享家目录的内容。比如说:SuSE系统就是使用公共用户组策略。</p><p><strong>HOME=/home</strong>：这个参数指定的是创建家目录的基准目录。一般家目录与用户名同名。</p><p><strong>INACTIVE=-1</strong>：这个参数指定的是用户密码失效，0表示每次登录都要重新设定密码，-1表示密码永不失效，30表示设定的密码30天之后失效。</p><p><strong>EXPIRE</strong>:表示账户默认失效日期，为空的话表示账户永不失效。</p><p><strong>SHELL=/bin/bash</strong>:指定创建账户默认使用的SHELL。不允许用户登录系统则是使用<code>/bin/nologin</code></p><p><strong>SKEL=/etc/skel</strong>:表示新建家目录的参考基准目录，直接将目录中的内容拷贝到新目录中。<br><img src="/2019/11/17/linux用户及权限管理/img4.webp" alt="新建家目录基准目录"></p><p><strong>CREATE_MAIL_SPOOL=yes</strong>:该参数指定是否建立使用者的邮箱</p><p><strong>/etc/login.defs文件内容</strong></p><p><img src="/2019/11/17/linux用户及权限管理/img5.webp" alt="/etc/login.defs文件内容"></p><p>在文件中的参数大多数都有相应的解释，着重需要注意的几个参数就是：</p><pre><code class="bash">MAIL_DIR /var/spool/mail # 用户邮箱默认放置路径PASS_MAX_DAYS 9999 # 密码需要变更的最长时间PASS_MIN_DAYS 0    # 密码需要变更的最短时间PASS_MIN_LEN 5     # 密码的最小长度，已被pam模组取代，该参数已经失效,PAM模块相关资料:https://www.cnblogs.com/kevingrace/p/8671964.htmlPASS_WARN_AGE 7    # 密码失效前天数进行警告UID_MIN 1000       # 一般用户的起始UIDUID_MAX 60000      # 一般用户最大UIDSYS_UID_MIN 201    # 系统用户的起始UIDSYS_UID_MAX 999    # 系统用户的最大UIDGID_MIN 1000       # 用户组起始GIDGID_MAX 60000      # 用户组最大GIDSYS_GID_MIN 201    # 系统用户组其实GIDSYS_GID_MAX 999    # 系统用户组最大GIDCREATE_HOME yes    # 在不指定-m/-M时，默认创不创建家目录。UMASK 077          # 创建家目录时的umask，默认权限为700USERGROUPS_ENAB yes# 使用userdel删除用户时，删除初始用户组ENCRYPT_METHOD SHA512# 密码使用SHA512加密算法。</code></pre><p>所以使用useradd时默认会参考<code>/etc/default/useradd</code>、<code>/etc/login.defs</code>、<code>/etc/skel/*</code>这几个文件。</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>以下为<code>passwd</code>命令的使用:</p><pre><code class="bash">passwd [--stdin] [username]  # 所有用户都可以通过这样的方式修改自己的密码，当不指定用户时，默认修改自己的账号密码passwd [-l] [-u] [--stdin] [-S] [-n天数] [-x天数] [-w天数] [-i天数] 账户  # 只有root用户可用# 参数及选项# --stdin 可以透过来自前一个管线的资料# -l lock的意思，会在/etc/shadow中的密码密文前加!,封锁该用户登录# -u unlock的意思，解除用户的封锁# -S 列出密码相关参数，即/etc/shadow档案中的大部分资料# -n天数 不可修改密码天数# -x天数 密码有效天数# -w天数 密码失效前警告天数# -l天数 用户账户失效天数# -d 删除用户的密码</code></pre><p>例如如果要让<code>test1</code>用户7天修改一次密码的话，那么可以设置为:<code>passwd -x 7 test1</code>。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><h4 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h4><p>chage用法:</p><pre><code class="bash">chage -[ldEImMW] 用户名# 选项说明# -l 列出该用户的详细密码参数# -d 日期 设置/etc/passwd中修改密码的时间，一般是以1970年1月1日到想要日期的天数# -E 日期 格式为YYYY-MM-DD，账户失效日期# -I 天数 密码修改的宽限天数# -m 天数 密码不可修改的天数# -M 天数 密码有效天数# -W 天数 密码失效前天数警告</code></pre><p>假如我们希望用户在登陆的时候设置新密码，就可以这样创建用户，<code>useradd username &amp;&amp; echo ‘username’ | passwd --stdin username &amp;&amp; chage -M 0 -d 0 username</code>创建用户之后登录需要重新设置密码才能使用账户。</p><p><img src="/2019/11/17/linux用户及权限管理/img6.webp" alt="创建一个在登录时必须要重设密码的账户"></p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>当使用<code>useradd</code>命令设置了错误的参数或者遗忘了设置某种参数时，可以使用<code>usermod</code>命令，微调用户的参数。</p><pre><code class="bash">usermod [-cdegGlsuLU] username# 选项解释# -c 修改用户说明；# -m 将原家目录中的内容移到新家目录中，与-d一起使用；# -d home_path 修改用户登录后的家目录；# -e YYYYMMDD 指定用户账户失效日期；# -f 天数 用户密码失效之后宽限日期；# -g group 设置初始用户组；# -a 添加附加用户组，只能与-G选项一起用；# -G group[,group[,group[...]]] 设置账户所支援的群组；# -l username 设置用户新的用户名；# -u uid 设置用户的uid；# -o 设置非唯一的uid，与-u选项一起使用；# -p passwd 修改用户密码，不推荐这种方式修改密码，因为这种方式需要自己确保密码符合系统的密码策略；# -s shell 指定账户使用的shell# -L username 锁定用户账号# -U username 解锁用户账号</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>在linux系统中，删除用户账号使用<code>userdel</code>命令，用法如下:</p><pre><code class="bash">userdel [-fr] username# 参数解释# -f 强制删除用户，即使用户处于在线状态。同时也会删除用户的家目录和mail spool;# -r 删除账户的同时也删除家目录和mail spool.</code></pre><h3 id="用户自查"><a href="#用户自查" class="headerlink" title="用户自查"></a>用户自查</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>id</code>命令用于查询用户的uid和gid。</p><pre><code class="bash">id [选项] user# 选项解释# -</code></pre><h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h2><p>在linux的传统权限管理分为三种身份:所有者、用户组和其他。在设置限制或者允许单个用户访问文件时，存在着限制。</p><p>ACL时Access Control Lists的缩写，是Unix-Like系统的额外支援项目，主要是提供相较传统权限管理更加细粒的管理。主要是通过以下三个方面进行控制权限:</p><ol><li>使用者(user)：针对使用者进行权限限制；</li><li>群组(group):针对群组进行权限限制；</li><li>预设属性(mask):设置目录下新建使用的默认权限。</li></ol><p>在目前linux常用的分区类型(ext2/ext3/ext4/xfs等)默认acl挂载。虽然分区一般默认支持acl，但是还是需要相应的工具才能完全使用，一般使用<code>setfacl</code>和<code>getfacl</code>，如果提示找不到命令，在CentOS系统中可以在root用户下使用命令<code>yum install acl</code>安装。</p><h3 id="开启分区ACL权限"><a href="#开启分区ACL权限" class="headerlink" title="开启分区ACL权限"></a>开启分区ACL权限</h3><h4 id="临时开启分区ACL权限"><a href="#临时开启分区ACL权限" class="headerlink" title="临时开启分区ACL权限"></a>临时开启分区ACL权限</h4><p>重新挂载根分区:</p><p><code>mount -o remount,rcl /</code></p><p>临时开启acl分区在重启系统之后恢复到初始状态。</p><h4 id="永久开启分区ACL权限"><a href="#永久开启分区ACL权限" class="headerlink" title="永久开启分区ACL权限"></a>永久开启分区ACL权限</h4><p>修改<code>/etc/fstab</code>文件，在默认参数中添加acl选项。</p><p><img src="/2019/11/17/linux用户及权限管理/img7.webp" alt="添加acl选项"></p><p>保存修改后，重载分区或者重启系统生效。</p><h3 id="ACL权限设置"><a href="#ACL权限设置" class="headerlink" title="ACL权限设置"></a>ACL权限设置</h3><p>一般使用<code>getfacl</code>和<code>setfacl</code>两个工具完成ACL权限设置。</p><h4 id="setfacl"><a href="#setfacl" class="headerlink" title="setfacl"></a>setfacl</h4><pre><code class="bash">setfacl [-bkndRLPvh] [{-m|-x} acl_spec] [{-M|-X} acl_file] file# 参数与选项# -m 从命令行输入ACL条目进行更改# -M 从文件中读取ACL条目进行更改# -x 从命令行输入移除ACL条目# -X 从文件中读取ACL条目，并移除# -b 移除所有文件和目录的拓展ACL权限，仅保留所有者、群组和其他人权限设置；# -k 移除预设ACL权限；# -n 不重计算有效掩码# --mask 重计算有效掩码# -d 所有操作应用到ACL中# -R 应用到所有文件和路径# -L 按照系统逻辑，跟随符号连接# -P 按照自然逻辑，不跟随符号连接# -v 版本信息# -h help# --resotre 恢复权限备份# --test 测试模式，不修改任何权限# -- 命令模式结束标志# - 如果文件名称为‘-’，那么从标准输入读取文件列表。# ACL权限条目[d[efault]:] [u[ser]:]uid [:perms]# 设置用户权限[d[efault]:] g[roup]:gid [:perms]# 设置群组权限[d[efault]:] m[ask][:] [:perms]# 设置掩码[d[efault]:] o[ther][:] [:perms]# 设置其他人权限</code></pre><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>使用root创建test.txt文件，setfacl设置test的rw权限，代码如下：</p><p>root用户执行:</p><pre><code>touch test.txtsetfacl -mu:test:rw test.txt</code></pre><p><img src="/2019/11/17/linux用户及权限管理/img8.webp" alt="使用root用户创建文件，并且设置test用户的读写acl权限"></p><p>从上图中可以看出当设置了acl权限之后，权限部分最后变成了‘+’。</p><p><img src="/2019/11/17/linux用户及权限管理/img9.webp" alt="使用test账户测试，尝试写入以及读取test.txt文件"></p><p>设置<strong>群组、其他人</strong>的权限类似。</p><h4 id="getfacl"><a href="#getfacl" class="headerlink" title="getfacl"></a>getfacl</h4><p><code>getfacl</code>命令用于获取文件或则目录的acl权限信息。命令用法如下:</p><pre><code>getfacl path</code></pre><p><img src="/2019/11/17/linux用户及权限管理/img10.webp" alt="查看test.txt的acl信息"></p><h4 id="有效掩码"><a href="#有效掩码" class="headerlink" title="有效掩码"></a>有效掩码</h4><p>有效掩码设置方式<code>setfacl -mm:mask path</code>,有效掩码即在强制限制权限赋予范围，当赋予的权限不属于有效权限时则该权限无效。注意:<strong>默认在修改ACL权限时会重新计算有效掩码，可加入’-n’选项避免重新计算有效掩码</strong></p><p><img src="/2019/11/17/linux用户及权限管理/img11.webp" alt="有效掩码限制权限发放"></p><p>注意：权限只有所有者有权限修改(chmod)。而修改文件所有者(chown)只有root有权限修改。</p><h4 id="预设ACL权限"><a href="#预设ACL权限" class="headerlink" title="预设ACL权限"></a>预设ACL权限</h4><p>预设权限使得权限可以继承。如果一个目录设置了预设ACL权限，那么子目录下的权限都将继承预设权限。</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><p>root用户创建一个test文件夹，给test用户设置该目录预设读取权限，root在该目录下创建test.txt文件，并写入’hello world!’内容。然后退出root用户使用test用户读取该文件内容。</p><p><img src="/2019/11/17/linux用户及权限管理/img12.webp" alt="目录中的文件继承了预设ACL权限"></p><h3 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h3><p>在linux系统使用过程中，有时会使用不同的用户，就会使用到用户切换命令。</p><h4 id="切换身份的原因"><a href="#切换身份的原因" class="headerlink" title="切换身份的原因"></a>切换身份的原因</h4><ol><li>日常使用系统，使用一般用户；为了系统的安全，使用一般用户进行日常作业，当需要设定系统环境时，切换到root用户，这样操作相对安全，避免一些严重的误操作，例如<code>rm -rf /</code>。</li><li>使用较低较少的权限启动系统服务；例如系统安装apache软件，使用单独的apache用户，即使程序被攻破，系统还不至于崩溃。</li><li>软件本身的限制。在早期的talnet，程序预设是不允许root登录的，talnet会判断登录者的UID，如果登录者的UID为0，直接拒绝登入。因此只能使用一般用户登录系统。</li></ol><h4 id="一般用户切换为root用户方法"><a href="#一般用户切换为root用户方法" class="headerlink" title="一般用户切换为root用户方法"></a>一般用户切换为root用户方法</h4><ol><li><code>su -</code>，这个指令能从一般用户切换到root用户，但是需要输入root用户的密码，就是一般用户需要知道root用户的密码。</li><li><code>sudo</code>指令执行root指令，sudo使用需要事先进行设置，sudo使用的是自身账户的密码。在多人同时管理同一台linux系统时，使用<code>sudo</code>更加合适，可以有效避免root用户泄露。</li></ol><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p><code>su</code>是最简单的身份切换指令，可以进行任何身份的切换。使用方法如下:</p><pre><code class="bash">su [-lm] [-c指令] [username]# 选项和参数讲解# - 表示是以与真实登录类似的方式切换用户，清除目前的变量，重设主目录、当前shell、当前用户、登录名称、PATH变量；设置当前路径为主目录。# -l 和-类似，后面需要接欲切换的用户账号，也就是login-shell方式# -m -m和-p是类似的，表示使用目前的环境设定，不读取新用户的设定。# -c 进行一次指令执行，所以-c接上指令。# 默认情况下，su为以nologin-shell方式登录，PATH等变量都不会改变。# root用户切换到其他用户，不需要使用任何密码。</code></pre><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>sudo使用方法如下:</p><pre><code class="bash">sudo [-b] [-u新使用账号]# 选项和参数讲解# -b 将后续的指令放到背景中执行    而不会与当前的shell产生联系。# -u 后面接欲切换的用户，无指定则切换为root用户。</code></pre><p><strong>sudo执行流程</strong>：</p><ol><li>当使用sudo时，首先查询/etc/sudoers档案，查看该用户是否具有执行sudoers的权限；</li><li>当具有权限之后，让用户输入用户密码进行确认；</li><li>如果密码输入成功之后，便使用sudo执行后续指令（root使用sudo不需要输入密码）；</li><li>如果想切换的身份与执行者的身份相同时，不需要输入密码。</li></ol><h4 id="sudo设置"><a href="#sudo设置" class="headerlink" title="sudo设置"></a>sudo设置</h4><h5 id="visudo和-etc-sudoers"><a href="#visudo和-etc-sudoers" class="headerlink" title="visudo和/etc/sudoers"></a>visudo和/etc/sudoers</h5><p>是否具有sudo的权限是由/etc/sudoers文档决定的，所以要想给用户添加sudo权限就需要更改/etc/sudoers文件，由于文档有一定的语法并且设置错误会导致严重的错误，所以一般使用<code>visudo</code>进行设置。一般在退出设定时会检查文档的语法是否有错误。</p><p>visudo设置的方法有两种:</p><ol><li><p>对单一使用者设置sudo。<br>使用visudo命令打开sudo的配置文件：</p><pre><code class="bash"># 在root ALL=(ALL)ALL后一行添加如下内容:test ALL=(ALL)ALL# 参数讲解# 例如已有的: root ALL=(ALL)ALL# 用户名 登入者的来源主机名称=(可切换的身份)可下达的指令</code></pre></li><li><p>使用wheel群组和免密码功能处理visudo</p><p>使用visudo命令打开sudo的配置文件:</p><pre><code class="bash"># 将%wheel ALL=(ALL)ALL的注释去掉即可使wheel群组的用户都具有sudo权限,而新的用户只需添加到该群组就行.# 去除密码的设置如: %wheel ALL=(ALL) NOPASSWD: ALL</code></pre></li></ol><p><em>注意:</em>在指定能下达指令时,要使用绝对路径,并且多个命令使用英文逗号<code>,</code>分开.</p><h5 id="有限制的指令操作"><a href="#有限制的指令操作" class="headerlink" title="有限制的指令操作"></a>有限制的指令操作</h5><p>比如赋予了sudo能执行passwd的权限,但是如果直接给passwd命令权限则可能将root用户的密码修改导致root用户不能登录,因此需要限制用户修改root用户的密码.具体设置如下:</p><pre><code class="bash">test ALL=(root) !/usr/bin/passwd,/usr/bin/passwd [a-zA-Z]*,!/usr/bin/passwd root# !表示不能执行的指令,不能执行/usr/bin/passwd和/usr/bin/passwd root两个命令.</code></pre><h5 id="通过别名建置visudo"><a href="#通过别名建置visudo" class="headerlink" title="通过别名建置visudo"></a>通过别名建置visudo</h5><p>如果有15个用户需要添加到sudo权限中的话,除了使用用户组进行管理以外,还能通过别名建置获得sudo权限.假设需要将test1、test2、test3…test15一共15个用户添加到sudo中,并限制只能修改除root用户外用户的密码，除了使用用户组或者单个添加以外，还能使用如下设置：</p><pre><code class="bash">User_Alias TESTS=test1,test2,test3,test4,test5,test6,test7,test8,test9,test10,test11,test12,test13,test14,test15Cmnd_Alias TESTSCMD=!/usr/bin/passwd,/usr/bin/passwd [a-zA-Z]*,!/usr/bin/passwd rootTESTS ALL=(root) TESTSCMD</code></pre><p>添加之后即可使用户具有修改密码权限。</p><h5 id="sudo时间间隔"><a href="#sudo时间间隔" class="headerlink" title="sudo时间间隔"></a>sudo时间间隔</h5><p>两条sudo命令连着使用都需要输入密码，可以设置使用时间间隔不超过5分钟，不需要重新输入用户密码。设置如下:</p><pre><code class="bash"># 将默认的Defaults env_reset改为设置（5分钟为超时时间）：Defaults env_reset , timestamp_timeout=5</code></pre><h5 id="通过sudo将用户切换到root用户-非信任用户切勿使用"><a href="#通过sudo将用户切换到root用户-非信任用户切勿使用" class="headerlink" title="通过sudo将用户切换到root用户(非信任用户切勿使用)"></a>通过sudo将用户切换到root用户(非信任用户切勿使用)</h5><pre><code class="bash">User_Alias ADMINS=test1,test2ADMINS ALL=(root) /bin/su -</code></pre><h2 id="特殊的SHELL"><a href="#特殊的SHELL" class="headerlink" title="特殊的SHELL"></a>特殊的SHELL</h2><p>在安装linxu系统之时，会默认创建许多许多系统用户，例如，负责管理邮箱的mail用户等等，mail用户只是用于使用相关的资源，而不是用于登录linux系统，因此设置mail用户的密码，同时设置mail用户登录使用的shell为/sbin/nologin，这个shell为无法登录的合法shell。输入正确的账号密码登录之后会提示:</p><pre><code class="bash">This account is currently not available.</code></pre><h2 id="PAM模组"><a href="#PAM模组" class="headerlink" title="PAM模组"></a>PAM模组</h2><p>在以前，如果需要对用户进行认证，需要专门的程序判断用户和密码是否正确，那么就存在在同一个主机上存在多个不同的认证系统，可能会造成账户和密码不同步的问题，从而引入了PAM(Pluggable  Authentication Modules,可插拔认证模块)机制。PAM是一整套应用程序接口(Application Program Interface,API),提供一连串验证机制。PAM可实现使用者将验证过程的需求告知PAM，PAM即可返回相应的验证的结果。PAM既是一套验证机制，也可以提供其他软件调用验证，让账户的验证具有一致性。</p><p><img src="/2019/11/17/linux用户及权限管理/img13.webp" alt="PAM验证结构"></p><p>在系统中PAM作为API存在，需要PAM认证的程序即可调用该接口，经过一系列验证之后将结果返回，程序可以根据验证的结果做出相应的反应。PAM进行验证的信息成为模块(Modules)，每个PAM模块的功能不同。</p><h3 id="PAM模块设定语法"><a href="#PAM模块设定语法" class="headerlink" title="PAM模块设定语法"></a>PAM模块设定语法</h3><p>PAM由一个和程序名相同的设定文档确定认证流程。当执行<code>passwd</code>后，PAM运行的流程为:</p><ol><li>使用者调用passwd，并输入密码；</li><li>passwd程序调用PAM进行认证；</li><li>PAM到/etc/pam.d/中找与程序(passwd)同名的设定档；</li><li>依据/etc/pam.d/passwd文档的设定，调用相应的PAM模块进行验证；</li><li>将验证结果返回passwd程序；</li><li>passwd根据返回的结果做出相应的反应。</li></ol><p>因此，PAM中最重要的是验证的模块和/etc/pam.d/目录下的设定文档。以passwd的设定档（/etc/pam.d/passwd）为例:</p><pre><code class="bash">#%PAM-1.0   # PAM版本说明auth       include      system-auth     # 以后每一行都是一个验证的过程account    include      system-authpassword   substack     system-auth-password   optional    pam_gnome_keyring.so use_authtokpassword   substack     postlogin</code></pre><p>每一行都是一个独立的验证流程，每一行都可以分为三个部分，分别是验证类别(type)、控制标识(flag)和PAM模块和该模块的参数。</p><h4 id="验证类别-type"><a href="#验证类别-type" class="headerlink" title="验证类别(type)"></a>验证类别(type)</h4><p>验证类别主要分为4种:</p><ul><li><strong>auth</strong>:authentication的缩写，通常用于验证使用者的身份验证，通常需要使用密码来验证，所以后续接的模块一般验证使用者身份的。</li><li><strong>account</strong>:account(账户)一般是用于authorization（授权），主要用于检验使用者是否具有正确的使用权限。</li><li><strong>session</strong>:session就是会话的意思，所以session管理的是使用者在此次登入（或这个指令）期间，PAM所给予的环境设定。session一般会记录使用者登入和登出时的信息。比如，使用su命令和sudo命令可以在/var/log/secure中找到很多关于pam的说明。记录的资料都是session open和session close等。</li><li><strong>passwd</strong>:这种类别主要提供验证的修订工作，比如修改/变更密码等。</li></ul><h4 id="控制标识（control-flag"><a href="#控制标识（control-flag" class="headerlink" title="控制标识（control flag)"></a>控制标识（control flag)</h4><p>控制标志是指验证的过程中通过的标准，控制验证的放行标准，一般分为4中控制标志:</p><ul><li><strong>required</strong>:如果验证成功则带success标志，验证失败则带failure标志，无论验证成功还是验证失败都会进行后续的验证流程。由于后续的流程可以继续进行，相当于有利于资料的登录（log),这也是经常使用required的原因。</li><li><strong>requisite</strong>：如果验证失败立刻返回原程序failure标志，并且终止后续的验证流程。如果验证成功则带success标志并继续后续验证流程。</li><li><strong>sufficient</strong>:如果验证成功则立刻回传success给原程序。并终止后续验证流程：如果验证失败则带failure标志并继续后续验证流程。</li><li><strong>optional</strong>：大多数用在显示讯息，不用于验证。</li></ul><p><img src="/2019/11/17/linux用户及权限管理/img14.webp" alt="控制标志的验证流程"></p><h4 id="常用的PAM模块"><a href="#常用的PAM模块" class="headerlink" title="常用的PAM模块"></a>常用的PAM模块</h4><p>经常我们需要通过各种方式登入系统，因此看一下登入所需的PAM流程，即/etc/pam.d/login文档中的内容:</p><pre><code class="bash">#%PAM-1.0auth [user_unknown=ignore success=ok ignore=ignore default=bad] pam_securetty.soauth       substack     system-authauth       include      postloginaccount    required     pam_nologin.soaccount    include      system-authpassword   include      system-auth# pam_selinux.so close should be the first session rulesession    required     pam_selinux.so closesession    required     pam_loginuid.sosession    optional     pam_console.so# pam_selinux.so open should only be followed by sessions to be executed in the user contextsession    required     pam_selinux.so opensession    required     pam_namespace.sosession    optional     pam_keyinit.so force revokesession    include      system-authsession    include      postlogin-session   optional     pam_ck_connector.so</code></pre><p>在login文档中使用了很多次system-auth模块，此模块（/etc/pam.d/system-auth）的配置内容为：</p><pre><code class="bash">#%PAM-1.0# This file is auto-generated.# User changes will be destroyed the next time authconfig is run.auth        required      pam_env.soauth        required      pam_faildelay.so delay=2000000auth        sufficient    pam_unix.so nullok try_first_passauth        requisite     pam_succeed_if.so uid &gt;= 1000 quiet_successauth        required      pam_deny.soaccount     required      pam_unix.soaccount     sufficient    pam_localuser.soaccount     sufficient    pam_succeed_if.so uid &lt; 1000 quietaccount     required      pam_permit.sopassword    requisite     pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type=password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtokpassword    required      pam_deny.sosession     optional      pam_keyinit.so revokesession     required      pam_limits.so-session     optional      pam_systemd.sosession     [success=1 default=ignore] pam_succeed_if.so service in crond quiet use_uidsession     required      pam_unix.so</code></pre><p>详细的模块的信息在linux中都可以找到，常见的模块:</p><ul><li>每个程序的个别PAM设定档:/etc/pam.d/*;</li><li>PAM模块实际放置位置:/lib64/security/*;</li><li>其他PAM环境设定文档:/etc/security/*;</li><li>详细的PAM说明文档:/usr/share/doc/pam-*;</li></ul><p>这里列举几个常用的PAM模块：</p><ul><li><strong>pam_securetty.so</strong>:限制root用户只能从安全终端登录，而常见的安全的终端就是TTY1,TTY2等终端机装置名称。而安全的终端机设定是由/etc/securetty文档决定的。</li><li><strong>pam_nologin.so</strong>:限制一般使用者能否登入主机，当/etc/nologin这个文档存在时，则所有一般用户都不能登入系统，并且将其中的内容输出到登录的终端上。在正常的系统中不存在，但是该模块不能限制root及已经登录的用户。</li><li><strong>pam_selinux.so</strong>:SELinux是针对程序进行细部权限管理的功能，由于SELinux会影响到使用者执行程序的权限，因此我们利用PAM模块，暂时将SELinux暂时关闭，验证通过后再打开。</li><li><strong>pam_console.so</strong>:当系统出现问题或者需要通过特殊终端登陆系统时，该模块可以处理一些档案的权限问题，让使用者可以通过特殊终端登入系统。</li><li><strong>pam_loginuid.so</strong>:通过用户UID，验证一般账号和系统账号。</li><li><strong>pam_env.so</strong>:用于设定环境变量的模块，如果你有需要额外的环境变量设定，可以参考/etc/security/pam_env.conf这个档案。</li><li><strong>pam_unix.so</strong>：该模组很复杂也很重要，该模组可以用于验证阶段的认证功能，可以用在授权阶段的用户授权管理，也可以用在会话阶段的登录档记录，甚至可以用在密码更新阶段的检验。</li><li><strong>pam_pwquanlity.so</strong>：该模块用于检验密码强度。包括密码是否存在于字典中，密码输入几次失败就断掉此次连线的功能，都可以由该模块提供的。最早之前使用的是pam_cracklib.so这个模组，后改为pam_pwquanlity.so模组。但是该模组完全兼容于之前的pam_cracklib.so模组。</li><li><strong>pam_limits.so</strong>:提供ulimit功能，设定档参考/etc/security/limits.conf。</li></ul><h5 id="limits-conf"><a href="#limits-conf" class="headerlink" title="limits.conf"></a>limits.conf</h5><p>limits.conf这个文件对用户使用的资源进行限制。一般账号资源限制格式如下:</p><pre><code class="bash">test soft fsize 1000test hard fsize 9000</code></pre><p>账号限制栏分为4栏，第一栏为账号，如果是群组限制则在群组名称前加@符号；</p><p>第二栏为对限制的要求，soft为警告，hard为严格。</p><p>第三栏为限制的内容，这里使用的限制档案的容量。</p><p>第四栏为限制的值，这里使用的单位为KB。</p><p>限制test用户登录的最大连接数为1，设置为:</p><pre><code class="bash">test hard maxlogins 1</code></pre><p>因为PAM只用在验证的时候才使用，对于已经登入的用户没有作用。所以修改过的资料需要用户重新登入才能使设置生效。</p><h2 id="使用者的信息传递"><a href="#使用者的信息传递" class="headerlink" title="使用者的信息传递"></a>使用者的信息传递</h2><p>使用同一台电脑的不同用户之间的沟通，查看不同用户的信息。</p><h3 id="查询使用者，w，who，last，lastlog"><a href="#查询使用者，w，who，last，lastlog" class="headerlink" title="查询使用者，w，who，last，lastlog"></a>查询使用者，w，who，last，lastlog</h3><p>通过<code>w</code>或者<code>who</code>命令就可以查询到目前在线的用户。</p><p>想要查询到最近用户的登录的时间，可以使用<code>lastlog</code>命令，该指令是去读去/var/log/lastlog文档。</p><h3 id="使用者之间交流，write，mesg，wall"><a href="#使用者之间交流，write，mesg，wall" class="headerlink" title="使用者之间交流，write，mesg，wall"></a>使用者之间交流，write，mesg，wall</h3><p>利用<code>write</code>指令可以直接将信息传递给接受者。命令格式如下:</p><pre><code class="bash">write 用户名称 [用户所使用的终端]</code></pre><p>当在该指令中输入消息，回车之后会立马将该消息传递给指定用户，如果用户在做其他任务，突然出现的消息会将工作打乱，因此可以通过<code>mesg n</code>命令选择不接收消息。即使选择不接收消息，但是对于root用户的消息不受该选项的影响，会直接传递给用户。</p><p>广播则使用<code>wall</code>指令，命令使用的方法:</p><pre><code class="bash">wall &#39;消息内容&#39;</code></pre><h3 id="使用者的邮箱"><a href="#使用者的邮箱" class="headerlink" title="使用者的邮箱"></a>使用者的邮箱</h3><p>使用write、wall命令都需要用户在线才能接收到消息，除此以外还能通过mail传递信息到用户。使用<code>mail -s &quot;邮件标题&quot; username@localhost</code>命令即可开始编写邮件并发送邮件，编辑完邮件之后使用单独一行<code>.</code>表示邮件内容的结束。</p><p>mail常使用的命令:</p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">列出信件标头；如果要查阅40 封信件左右的信件标头，可以输入<code>h 40</code></td></tr><tr><td align="center">d</td><td align="center">删除后续接的信件号码，删除单封是<code>d10</code>，删除20~40 封则为<code>d20-40</code>。不过，这个动作要生效的话，必须要配合q 这个指令才行(参考底下说明)！</td></tr><tr><td align="center">s</td><td align="center">将信件储存成档案。例如我要将第5 封信件的内容存成~/mail.file:<code>s 5 ~/mail.file</code></td></tr><tr><td align="center">x</td><td align="center">或者输入exit 都可以。这个是’不作任何动作离开mail 程式’的意思。不论你刚刚删除了什么信件，或者读过什么，使用exit 都会直接离开mail，所以刚刚进行的删除与阅读工作都会无效。如果您只是查阅一下邮件而已的话，一般来说，建议使用这个离开啦！除非你真的要删除某些信件。</td></tr><tr><td align="center">q</td><td align="center">相对于exit 是不动作离开， q 则会实际进行你刚刚所执行的任何动作(尤其是删除！)</td></tr></tbody></table><h2 id="Centos下建立大量账号"><a href="#Centos下建立大量账号" class="headerlink" title="Centos下建立大量账号"></a>Centos下建立大量账号</h2><p>在Linux下创建大量的用户，需要检查用户创建是否存在问题，那么这个时候就需要使用工具进行辅助设置。</p><h3 id="一些用户相关的检查工具"><a href="#一些用户相关的检查工具" class="headerlink" title="一些用户相关的检查工具"></a>一些用户相关的检查工具</h3><h4 id="pwck"><a href="#pwck" class="headerlink" title="pwck"></a>pwck</h4><p>这个指令用于检查/etc/passwd文档中用户的设定信息，以及家目录实际存在等等信息。甚至还可以比对/etc/passwd、/etc/shadow中的信息是否一致，如果存在问题，则提示修改。</p><p><img src="/2019/11/17/linux用户及权限管理/img15.webp" alt="pwck指令检查结果"></p><p>以上为pwck检查结果，检查结果为系统用户存在部分错误，这些错误属于正常的错误，不用解决。对应的群组检查命令使用<code>grpck</code>命令。</p><h4 id="pwconv"><a href="#pwconv" class="headerlink" title="pwconv"></a>pwconv</h4><p>这个命令主要用于将/etc/passwd中的密码信息移动到/etc/shadow中，一般用在较旧的系统上，为了安全考虑，将密码从/etc/passwd中转移到/etc/shadow中。</p><h4 id="pwunconv"><a href="#pwunconv" class="headerlink" title="pwunconv"></a>pwunconv</h4><p>这个命令恰好相反，将/etc/shadow中的密码写回到/etc/passwd中，并且删除/etc/shadow档案。</p><h4 id="chpasswd"><a href="#chpasswd" class="headerlink" title="chpasswd"></a>chpasswd</h4><p>这个命令可以读入未加密的密码，并把这个密码写入到/etc/shadow中去，这个命令常常使用在大量建构用户的工作中去。读入资料的格式为”用户名:密码”。例如:</p><pre><code class="bash">echo &#39;test:123456&#39; | chpasswd</code></pre><h3 id="大量建置用户的办法-passwd-–stdin"><a href="#大量建置用户的办法-passwd-–stdin" class="headerlink" title="大量建置用户的办法(passwd –stdin)"></a>大量建置用户的办法(passwd –stdin)</h3><p>可以通过脚本使用<code>passwd --stdin</code>大量建置用户</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>伪用户资料:<a href="https://blog.csdn.net/Add_a_cat/article/details/97614942" target="_blank" rel="noopener">https://blog.csdn.net/Add_a_cat/article/details/97614942</a></p><p>开启分区ACL权限:<a href="https://www.cnblogs.com/ysocean/p/7801329.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/7801329.html</a></p><p>setfacl参数详解:<a href="https://www.cnblogs.com/ftl1012/p/setfacl.html" target="_blank" rel="noopener">https://www.cnblogs.com/ftl1012/p/setfacl.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;每次使用linux系统我们都需要登录，用户在登录过程中起到重要的作用。本篇博客主要讲解用户及其管理的相关内容。&lt;/p&gt;
&lt;h2 id=&quot;用户
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="linux" scheme="http://qzt8315.github.io/tags/linux/"/>
    
      <category term="用户" scheme="http://qzt8315.github.io/tags/%E7%94%A8%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>自编shell命令</title>
    <link href="http://qzt8315.github.io/2019/11/15/%E8%87%AA%E7%BC%96shell%E5%91%BD%E4%BB%A4/"/>
    <id>http://qzt8315.github.io/2019/11/15/自编shell命令/</id>
    <published>2019-11-14T16:30:03.000Z</published>
    <updated>2019-11-17T09:38:43.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇博客是记录我在使用lnux时写的一些shell命令或者脚本</p><h2 id="创建一个临时的脚本文件"><a href="#创建一个临时的脚本文件" class="headerlink" title="创建一个临时的脚本文件"></a>创建一个临时的脚本文件</h2><p>举例:<code>cns script.sh</code></p><pre><code class="bash">alias cns=&#39;[ ! -e /tmp/shell ] &amp;&amp; mkdir /tmp/shell; cd /tmp/shell &amp;&amp; vim&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇博客是记录我在使用lnux时写的一些shell命令或者脚本&lt;/p&gt;
&lt;h2 id=&quot;创建一个临时的脚本文件&quot;&gt;&lt;a href=&quot;#创建一
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="shell_script" scheme="http://qzt8315.github.io/tags/shell-script/"/>
    
  </entry>
  
  <entry>
    <title>shell中的判断式</title>
    <link href="http://qzt8315.github.io/2019/11/14/shell%E4%B8%AD%E7%9A%84%E5%88%A4%E6%96%AD%E5%BC%8F/"/>
    <id>http://qzt8315.github.io/2019/11/14/shell中的判断式/</id>
    <published>2019-11-14T12:21:57.000Z</published>
    <updated>2019-11-17T09:38:16.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在shell中不免会测试字符串是否为空、文件是否存在和文件是否为空等等。完成这些功能就需要使用到shell中的判断式。</p><h2 id="test命令进行判断"><a href="#test命令进行判断" class="headerlink" title="test命令进行判断"></a>test命令进行判断</h2><h3 id="某个路径的类型判断"><a href="#某个路径的类型判断" class="headerlink" title="某个路径的类型判断"></a>某个路径的类型判断</h3><p>举例：<code>test -e filename</code></p><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">测试该路径是否存在</td></tr><tr><td align="center">-f</td><td align="center">该路径是否存在且为文件</td></tr><tr><td align="center">-d</td><td align="center">该路径是否存在且为目录</td></tr><tr><td align="center">-b</td><td align="center">该路径是否存在且为block device</td></tr><tr><td align="center">-c</td><td align="center">该路径是否存在且为character device</td></tr><tr><td align="center">-S</td><td align="center">该路径是否存在且为Socket文件</td></tr><tr><td align="center">-p</td><td align="center">该路径是否存在且为PIPE文件</td></tr><tr><td align="center">-L</td><td align="center">该路径是否存在且为一个连结文件</td></tr></tbody></table><h3 id="路径的权限判断"><a href="#路径的权限判断" class="headerlink" title="路径的权限判断"></a>路径的权限判断</h3><p>举例:<code>test -r filename</code></p><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">判断路径是否存在且可以读</td></tr><tr><td align="center">-w</td><td align="center">判断路径是否存在且可写</td></tr><tr><td align="center">-x</td><td align="center">判断路径是否存在且可执行</td></tr><tr><td align="center">-u</td><td align="center">判断路径是否存在且具有SUID属性</td></tr><tr><td align="center">-g</td><td align="center">判断路径是否存在且具有SGID属性</td></tr><tr><td align="center">-k</td><td align="center">判断路径是否存在且具有sticky bit属性</td></tr><tr><td align="center">-s</td><td align="center">判断文档是否存在且为非空</td></tr></tbody></table><h3 id="两个文件之间比较"><a href="#两个文件之间比较" class="headerlink" title="两个文件之间比较"></a>两个文件之间比较</h3><p>举例:<code>test file1 -nt file2</code></p><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">两数值相等(不可以扩展到字符串比较)</td></tr><tr><td align="center">-ne</td><td align="center">两数值不相等</td></tr><tr><td align="center">-gt</td><td align="center">大于</td></tr><tr><td align="center">-lt</td><td align="center">小于</td></tr><tr><td align="center">-ge</td><td align="center">大于等于</td></tr><tr><td align="center">-le</td><td align="center">小于等于</td></tr></tbody></table><h3 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h3><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><code>test -z string</code></td><td align="center">判断字符串是否为空</td></tr><tr><td align="center"><code>test -n string</code></td><td align="center">判断字符串是否为非空</td></tr><tr><td align="center"><code>test str1 == str2</code></td><td align="center">判断两字符串是否相等</td></tr><tr><td align="center"><code>test str1 != str2</code></td><td align="center">判断两字符串是否不相等</td></tr></tbody></table><h3 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h3><p>举例:<code>test -r filename -a -x filename</code></p><table><thead><tr><th align="center">标志</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">and,两者判断成立的时候才返回true</td></tr><tr><td align="center">-o</td><td align="center">or,两者条件成立一个就返回true</td></tr><tr><td align="center">!</td><td align="center">not,相反才返回true，例如:<code>test ! -x filename</code></td></tr></tbody></table><h2 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号[]"></a>判断符号[]</h2><p>使用判断符号和使用使用<code>test</code>命令基本上是一样的，注意使用判断符号时的空格十分重要。举例<code>[▢1▢lt▢2▢]</code>（▢表示空格符号），特别注意例子中所有的分隔都是通过空格间隔的，尤其是中括号相邻的空格符号一定要注意用上。标志使用和test命令的无差别。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜:<a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php#ex_cal" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0340bashshell-scripts.php#ex_cal</a></p><p>判断符号[]补充资料来源:<a href="https://blog.csdn.net/qq_41586263/article/details/83014853" target="_blank" rel="noopener">https://blog.csdn.net/qq_41586263/article/details/83014853</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在shell中不免会测试字符串是否为空、文件是否存在和文件是否为空等等。完成这些功能就需要使用到shell中的判断式。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="linux" scheme="http://qzt8315.github.io/tags/linux/"/>
    
      <category term="判断式" scheme="http://qzt8315.github.io/tags/%E5%88%A4%E6%96%AD%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>常用linux命令列表</title>
    <link href="http://qzt8315.github.io/2019/11/12/%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/"/>
    <id>http://qzt8315.github.io/2019/11/12/常用linux命令列表/</id>
    <published>2019-11-12T08:36:02.000Z</published>
    <updated>2019-11-17T09:39:19.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客中主要用于记录linux中常用到的命令.</p><h2 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h2><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">ls</td><td align="center">查看当前目录下的文件</td><td align="center"></td></tr><tr><td align="center">$(命令)</td><td align="center">小指令</td><td align="center"></td></tr><tr><td align="center">$((string))</td><td align="center">和数值运算等有关</td><td align="center"></td></tr><tr><td align="center">ip</td><td align="center">显示或管理网络相关的路由、设置等</td><td align="center"></td></tr><tr><td align="center">touch</td><td align="center">修改文件的时间戳</td><td align="center"></td></tr><tr><td align="center">declare</td><td align="center">申明shell变量(shell内建指令)</td><td align="center"></td></tr><tr><td align="center">bc</td><td align="center">命令行计算器</td><td align="center"></td></tr><tr><td align="center">test</td><td align="center">判断路径是否存在</td><td align="center"></td></tr><tr><td align="center">netstat</td><td align="center">获取网络状态</td><td align="center">netstat属于net-tools中的一个工具，如果找不到命令的话，需要安装net-tools.</td></tr><tr><td align="center">seq</td><td align="center">以指定增量从首数打印数字到尾数</td><td align="center"><code>seq [首数 [增量]] 尾数</code>可以使用shell内建机制实现:<code>{1..10}</code></td></tr><tr><td align="center">cut</td><td align="center">摘取每行指定的字符</td><td align="center"></td></tr><tr><td align="center">awk</td><td align="center"><a href="/2019/10/18/awk工具/" title="awk工具">awk工具</a></td><td align="center"></td></tr><tr><td align="center">sed</td><td align="center"><a href="/2019/10/08/sed工具/" title="sed工具">sed工具</a></td><td align="center"></td></tr></tbody></table><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ul><li>重启网络<code>/etc/init.d/network restart</code></li><li>停止网络<code>/etc/init.d/network stop</code></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本篇博客中主要用于记录linux中常用到的命令.&lt;/p&gt;
&lt;h2 id=&quot;命令列表&quot;&gt;&lt;a href=&quot;#命令列表&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="linux" scheme="http://qzt8315.github.io/tags/linux/"/>
    
      <category term="命令" scheme="http://qzt8315.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>shell script</title>
    <link href="http://qzt8315.github.io/2019/11/11/shell-script/"/>
    <id>http://qzt8315.github.io/2019/11/11/shell-script/</id>
    <published>2019-11-11T08:11:51.000Z</published>
    <updated>2019-11-17T09:38:13.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>shell script是在shell中使用的一种脚本语言，是纯文本文档，通过shell去执行脚本。shell script通常可以应用在服务器自动化管理、简单资料的自动化处理、复杂命令单一化和服务器安全稳定性管理等方面。shell script可以帮助我们更好的使用linux系统，但是也存在着局限性。shell script不适合做大量数据处理和运算，shell script属于解释执行类语言，并且运行过程中调用的命令常常会有系统调用和外部库引用，导致占用资源高而执行效率低。我们使用shell script大多数是在管理计算机，对效率要求不高，所以能够成为我们熟练使用linux的有用工具之一。</p><h2 id="执行shell-script"><a href="#执行shell-script" class="headerlink" title="执行shell script"></a>执行shell script</h2><ol><li>直接执行（注意需要具有rx权限）：<ul><li>绝对路径执行:<code>/home/user/script.sh</code>；</li><li>相对路径路径执行:<code>./script.sh</code>；</li><li>PATH路径执行:脚本位于PATH路径下，<code>script.sh</code>。</li></ul></li><li>bash程序执行:<code>bash script_path</code>或者<code>sh script_path</code>。</li></ol><h2 id="shell-script中的一些默认规则"><a href="#shell-script中的一些默认规则" class="headerlink" title="shell script中的一些默认规则"></a>shell script中的一些默认规则</h2><ol><li>命令的执行是自上而下，从左到右执行的；</li><li>script中指令、参数和选项之间的多个空格会被忽略成一个空格；</li><li>Tab键被视为空白符号，空白行会被忽略；</li><li>当读到换行时会执行该行的命令，但是当使用\+Enter组合时表示该行命令未结束，表示该行的内容太多，延伸到下一行；</li><li>注释使用’#’，只能注释一行的内容。</li></ol><h2 id="编写程序应该养成较好的习惯"><a href="#编写程序应该养成较好的习惯" class="headerlink" title="编写程序应该养成较好的习惯"></a>编写程序应该养成较好的习惯</h2><p>在文档的开头应该做上相应的记录:</p><ol><li>实现的功能</li><li>版本</li><li>作者及其联系方式</li><li>版权</li><li>修改记录</li><li>较为特别的命令使用绝对路径调用</li><li>需要使用到环境变量的需要先声明和设定</li></ol><h2 id="shell-script常见的命令"><a href="#shell-script常见的命令" class="headerlink" title="shell script常见的命令"></a>shell script常见的命令</h2><table><thead><tr><th align="center">命令</th><th align="center">格式</th><th align="center">示例</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">echo</td><td align="center">echo string</td><td align="center">echo ‘hello world’</td><td align="center">输出一行文本</td></tr><tr><td align="center">read</td><td align="center">read -p string variable</td><td align="center">read -p ‘your name?:’ name</td><td align="center">标准输入中读入数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="脚本不同执行方式的差别"><a href="#脚本不同执行方式的差别" class="headerlink" title="脚本不同执行方式的差别"></a>脚本不同执行方式的差别</h2><ol><li>直接执行脚本：使用<code>bash script.sh</code>执行脚本，会在当前的bash中使用新的bash环境执行脚本，所有在脚本中产生的变量，会随着脚本执行完毕，bash读到文件EOF退出而消失。</li><li>使用<code>source script.sh</code>执行脚本则相反，相当该脚本由当前的bash环境执行，不需要打开新的环境，执行之后bash环境也不会退出，因此脚本中使用的变量还是存在。</li></ol><h2 id="shell-script的预设变量"><a href="#shell-script的预设变量" class="headerlink" title="shell script的预设变量"></a>shell script的预设变量</h2><pre><code class="bash">/path/to/scriptname opt1 opt2 opt3 ....               $0    $1   $2   $3   ...</code></pre><p>执行脚本档名可以用<code>$0</code>表示，第一个参数用<code>$1</code>表示、第二个参数用<code>$2</code>表示、第三个参数用<code>$3</code>表示…。</p><h3 id="变量偏移"><a href="#变量偏移" class="headerlink" title="变量偏移"></a>变量偏移</h3><p>使用<code>shift</code>命令即可将变量进行偏移。</p><h2 id="条件判断式"><a href="#条件判断式" class="headerlink" title="条件判断式"></a>条件判断式</h2><p>首先注意用到shell中的判断式：<a href="/2019/11/14/shell中的判断式/" title="shell中的判断式">shell中的判断式</a>，这里不同的是条件判断式是’if…then’这样的形式。</p><h3 id="if…then"><a href="#if…then" class="headerlink" title="if…then"></a>if…then</h3><h4 id="简单的条件判断"><a href="#简单的条件判断" class="headerlink" title="简单的条件判断"></a>简单的条件判断</h4><pre><code class="sh">    if [条件判断式]:then        条件满足执行    fi</code></pre><p>中括号之间可以使用&amp;&amp;和||连接多个条件</p><p>例如:</p><pre><code class="sh">if [条件判断式] &amp;&amp; [条件判断式] &amp;&amp; [条件判断式]:then    条件满足执行fi</code></pre><h4 id="多重复杂条件判断"><a href="#多重复杂条件判断" class="headerlink" title="多重复杂条件判断"></a>多重复杂条件判断</h4><pre><code class="sh">if [条件判断式]: then    命令else    命令fi</code></pre><p>更复杂的条件判断</p><pre><code class="sh">if [条件判断式]: then    命令elif []: then    命令else    命令fi</code></pre><h3 id="case…esac"><a href="#case…esac" class="headerlink" title="case…esac"></a>case…esac</h3><p>这种条件判断式的主要格式为：</p><pre><code class="sh">case $变量名称 in     # case式关键词    &quot;第一个变量内容&quot;)        命令        ;;    &quot;第二个变量内容&quot;)        命令        ;;    *)          # 不包含变量内容        命令        exit 1        ;;esac</code></pre><h2 id="function功能"><a href="#function功能" class="headerlink" title="function功能"></a>function功能</h2><p>函数功能使用格式</p><pre><code class="sh"># 创建函数姿势1function fname() {    命令}# 创建函数姿势2fname() {    命令}</code></pre><p>函数内建变量:在使用调用函数的时候传入参数即可使用函数的参数功能，调用形式:<code>fun par1 par2 ...</code>，在函数内使用预设变量即可获得参数的内容:<code>$1 $2 $3</code></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>当需要重复执行某个操作时可以使用循环结构实现。</p><h3 id="while-do-done-until-do-done"><a href="#while-do-done-until-do-done" class="headerlink" title="while do done, until do done"></a>while do done, until do done</h3><h4 id="while-do-done"><a href="#while-do-done" class="headerlink" title="while do done"></a>while do done</h4><p>使用方式:</p><pre><code class="sh">while [条件判断式]  # 条件成立循环do    命令done</code></pre><h4 id="until-do-done"><a href="#until-do-done" class="headerlink" title="until do done"></a>until do done</h4><p>使用方式:</p><pre><code class="sh">until [条件判断式]  # 条件不成立循环do    命令done</code></pre><h3 id="for…do…done"><a href="#for…do…done" class="headerlink" title="for…do…done"></a>for…do…done</h3><p>使用方式:</p><pre><code class="sh"># for循环姿势1for var in con1 con2 con3 ...do    命令done# for循环姿势2for ((初始值;执行条件;执行步骤)) # 和其他语言的for类似,初始值为赋初值，执行条件为判断是否满足循环要求，执行步骤为做完一次循环操作之后所要进行的步骤。do    命令done</code></pre><h2 id="script的调试和排错"><a href="#script的调试和排错" class="headerlink" title="script的调试和排错"></a>script的调试和排错</h2><pre><code class="bash">bash [-nvx] script.sh# 参数说明# -n 不执行脚本，仅检查是否有语法错误# -v 首先输出脚本内容再执行# -x 执行到哪一步将哪一步命令输出</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li><p>script的‘hello word’</p><pre><code class="sh"> #! /bin/bash # program # this program shows &#39;hello word&#39; on the screen. # name: shell.sh # history: # 2019/11/11 8315 create the script. echo &#39;hello world\n&#39; exit 0</code></pre><p> 脚本的第1行为指定脚本的执行程序；<br> 脚本的第2~6行为对该脚本的说明，方便之后对脚本进行修改；<br> 脚本的第7行为输出字符串行；<br> 脚本的第8行表示该脚本正常退出，返回值为0。<br> 运行命令<code>bash shell.sh</code>执行结果:<br> <img src="/2019/11/11/shell-script/img1.webp" alt="shell script的第一个hello world"></p></li><li><p>交互式脚本</p><pre><code class="sh"> #! /bin/bash # program # get your name and  age # name: interact.sh # history # 2019/11/12 8315 create this script echo &quot;I&#39;m glad to meet you!&quot; read -p $&#39;I\&#39;m 8315.Can I get your Name?\n&#39; name read -p $&#39;I\&#39;m 18 years old. What\&#39;s you?\n&#39; age echo &quot;${name},it&#39;s nice to meet you!&quot; exit 0</code></pre><p> 命令的前6行为该脚本的一些基本信息,便于以后修改<br> 第8行的字符串前面加’$’是为了在字符串中能使用转义字符.<br> 第10行的’${name}’表示使用name变量的内容<br> <img src="/2019/11/11/shell-script/img2.webp" alt="交互式脚本"></p></li><li><p>创建带日期的文件</p><pre><code class="sh"> #! /bin/bash # program # use date as the filename to create file.  Ps:filename_20191112 # name: createfile.sh # history: # 2019/11/12 8315 create this script echo &quot;I will use &#39;touch&#39; command to create file.&quot; read -p &#39;Please enter filename:&#39; filename  # 提示输入 # 判断文件名是否为空 if [[ -z &quot;$filename&quot; ]] then         echo &#39;empty filename!&#39;         exit 1 fi sdate=$(date +%Y%m%d) filename=${filename}&#39;_&#39;&quot;$sdate&quot; # 创建文件 touch &quot;$filename&quot; exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img3.webp" alt="创建文件名中带日期的文件"><br> 文件判断之后再讲解。</p></li><li><p>简单数值运算<br> 创建一个脚本使得两数相乘</p><pre><code class="sh"> #! /bin/bash # program # Input two integers. The program will get the product of two nums. # name: mutiply.sh # history: # 2019/11/13 8315 create this script. echo &#39;Input two integers. You will get the product of two nums.&#39; read -p &#39;the first integer:&#39; firstnum read -p &#39;the second integer:&#39; secondnum echo -e &quot;compute by \$(()):&quot; echo $((${firstnum}*${secondnum})) echo -e &quot;\ncompute by declare:&quot; declare -i result=${firstnum}*${secondnum} echo &quot;$result&quot; echo -e &quot;\ncompute by bc:&quot; echo ${firstnum}*${secondnum} | bc exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img4.webp" alt="通过三种方式计算两个整数的积"></p></li><li><p>判断路径是否存在的脚本</p><pre><code class="sh"> #! /bin/bash # program # determine whether the path exsits # name: determine,sh # history: # 2019/11/15 8315 create the script read -p &#39;please input the determined path:&#39; dpath ( [ -z ${dpath} ] &amp;&amp; echo &#39; erro:input empty string&#39; ) || ( [ -e ${dpath} ] &amp;&amp; echo &#39;path exists&#39; || echo &#39;path not exsits&#39; )</code></pre><p>​      判断式相关:<a href="/2019/11/14/shell中的判断式/" title="shell中的判断式">shell中的判断式</a></p></li><li><p>使用脚本中的预设变量</p><pre><code class="sh"> #! /bin/bash # program # use 3 preset parameter # name: presetparameter.sh # history: # 2019/11/15 8315 create this script echo &#39;this script called by:&#39;${0} echo &#39;three parameters is:&#39;${1} ${2} ${3} exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img5.webp" alt="脚本中使用预设变量"></p></li><li><p>预设变量偏移</p><pre><code class="sh"> #! /bin/bash # program # shift the preset parameters # name: shift preset parameters # history: # 2019/11/15 8315 create this script echo &quot;Total parameters num is:$#&quot; echo &quot;Your whole parameters is:$@&quot; # first shift echo &#39;first shift&#39; shift echo &quot;Total parameters num is:$#&quot; echo &quot;Your whole parameters is:$@&quot; # second shift echo &#39;second shift&#39; shift echo &quot;Total parameters num is:$#&quot; echo &quot;Your whole parameters is:$@&quot; # third shift echo &#39;third shift&#39; shift echo &quot;Total parameters num is:$#&quot; echo &quot;Your whole parameters is:$@&quot; exit 0</code></pre><p> “$#”表示预设变量总数，”$@”表示所有变量</p><p> <img src="/2019/11/11/shell-script/img6.webp" alt="预设变量偏移"></p></li><li><p>通过预设变量给函数传入参数</p><p> 函数传入多个参数，最多打印3个参数内容</p><pre><code class="sh"> #! /bin/bash # program # print parameters of function # name: funparameter.sh # history: # 2019/11/16 8315 create the script. printpara() {     case ${#} in         &quot;0&quot;)             echo &quot;no parameter!&quot;             ;;         &quot;1&quot;)             echo &quot;only one parameter:$1&quot;             ;;         &quot;2&quot;)             echo &quot;two parameters is:$1 $2&quot;             ;;         *)             echo &quot;three or more parameters, but I print the first three parameters: $1 $2 $3&quot;             ;;     esac } printpara 1 2 3 4 5 6 exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img7.webp" alt="函数参数传递"></p></li><li><p>通过/etc/passwd提取所有的用户</p><pre><code class="sh"> #! /bin/bash # program # get all users from /etc/passwd # name: getusers.sh # history: # 2019/11/16 8315 create the script. users=$(cat /etc/passwd | grep &#39;/bin/bash&#39; | cut -d &#39;:&#39; -f1)  # grep是为了过滤掉不需要的部分 # loop for printing all users echo &quot;User list:&quot; for username in ${users} do     echo ${username} done exit 0</code></pre><p> <img src="/2019/11/11/shell-script/img8.webp" alt="获取所有的用户名称"></p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜-第十三章:&lt; <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0340bashshell-scripts.php</a> &gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;shell script是在shell中使用的一种脚本语言，是纯文本文档，通过shell去执行脚本。shell script通常可以应用在服
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="linux" scheme="http://qzt8315.github.io/tags/linux/"/>
    
      <category term="shell-script" scheme="http://qzt8315.github.io/tags/shell-script/"/>
    
  </entry>
  
  <entry>
    <title>华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程</title>
    <link href="http://qzt8315.github.io/2019/10/31/%E5%8D%8E%E7%A1%95%E9%A3%9E%E8%A1%8C%E5%A0%A1%E5%9E%92fx50j%E5%8A%A0%E5%9B%BA%E6%80%81%E3%80%81%E6%B8%85%E7%81%B0%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%A1%85%E8%84%82%E8%BF%87%E7%A8%8B/"/>
    <id>http://qzt8315.github.io/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/</id>
    <published>2019-10-31T12:27:17.000Z</published>
    <updated>2019-11-10T13:04:51.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看着我2015年购入的笔记本电脑，使用差不多4年的时间了，至今没有进行过清灰和更换硅脂。最近电脑的温度偏高，估计是内部灰尘积累和硅脂已经完全干了的原因，更加坚定要拆机维护的想法。再加上最近”双十一“临近，正好看重的硬盘有优惠，萌生了给电脑进行加固态、清灰和换硅脂的想法。</p><h2 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h2><ul><li>由于这台电脑只有一个硬盘位，因此要加装固态硬盘要么使用的单个大容量固态硬盘，要么使用光驱位硬盘托架将原有的机械硬盘放到光驱位。考虑到预算，选择<strong>机械硬盘+固态硬盘</strong>的方案。原光驱接口采用的是SATA2的接口，固态硬盘在该接口下无法充分发挥性能，因此选择将机械硬盘放置到光驱位，用于电脑中存储文件等用处。</li><li>固态硬盘通过网络的多方了解，考虑到稳定第一的需求，选择了<strong>samsung 250G 860 evo</strong>。（下面会仔细分析为啥选择这款固态。）</li><li>通过度娘，了解到普通光驱位硬盘托架可能在电脑重启的时候会导致硬盘的c0值增加。c0值表示硬盘不安全掉电次数，不安全掉电可能会导致机械硬盘产生坏道，固态硬盘丢失数据甚至会损坏硬盘。考虑到机械硬盘的数据安全，选择了一款有掉电保护的硬盘托架——<strong>佳翼H95</strong>。</li><li>在选择硅脂时，在网络上了解了硅脂的选择，考虑到笔记本散热的局限性，选择了质量较好的老牌发烧友常用的<strong>猫头鹰NT-H1</strong></li><li>而拆机工具使用了目前手边有的工具以及购买时赠送的工具。</li></ul><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img1.webp" alt="大合照"></p><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img2.webp" alt="samsung 250G 860 evo"></p><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img3.webp" alt="佳翼H95光驱位硬盘托架"></p><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img4.webp" alt="猫头鹰NT-H1散热硅脂"></p><p><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img5.webp" alt="清灰使用的毛刷"></p><h2 id="关于固态硬盘"><a href="#关于固态硬盘" class="headerlink" title="关于固态硬盘"></a>关于固态硬盘</h2><p>在民用级固态硬盘中三星是最好用了（当然还有英特尔的固态硬盘，但是目前英特尔基本上都是企业级的固态硬盘，目前还暂时不考虑），无论是从稳定性方面以及性能方面来说都是做得比较好的。通过<a href="http://tieba.baidu.com/f?kw=固态硬盘" target="_blank" rel="noopener">固态硬盘吧</a>了解到目前比较推荐的SATA固态硬盘有三星的860evo、闪迪的utral 3d、西数的blue 3d NAND、英睿达的MX500和东芝的tr200。三星的质量和性能是最好的；闪迪的性能比较好，寿命相对要低一点；西数的蓝盘固态性能较好，寿命相对三星要差一点；英睿达的MX500相对要便宜很多，网上也有很多说这款固态掉盘的问题，吧友们比较建议京东入手较稳；东芝的tr200相对来说是最最便宜的固态，寿命和质量都相较三星有很大的差别，不适合作为系统盘。综合自己的需求，准备再使用这台电脑好几年，所以选择了三星，三星本身自带5年/150TBW官方保修，只要购买的是全新正品，不用担心售后问题。</p><h3 id="关于三星硬盘开箱应该做的事"><a href="#关于三星硬盘开箱应该做的事" class="headerlink" title="关于三星硬盘开箱应该做的事"></a>关于三星硬盘开箱应该做的事</h3><ul><li>首先查看包装，封口是否完整。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img6.webp" alt="查看硬盘包装，封口是否完整"></li><li>查看侧面的SN码<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img7.webp" alt="查看硬盘的SN码"></li><li>通过SN码查询硬盘的真伪，常用的查询方法有两种<ol><li>官网查询。访问<a href="https://www.samsung.com/cn/" target="_blank" rel="noopener">三星中国官网</a>，在通过<strong>售后服务</strong>-<strong>自助服务</strong>-<strong>产品验证服务</strong>，在验证界面输入SN信息即可验证（PS：我使用的谷歌浏览器访问该网页显示不正常，使用手机访问可以正常的显示）。在官网上可能会出现查不到SN码的情况，这时候需要通过电话进行查询。</li><li>电话查询。通过服务电话400-810-5858，转固态硬盘类客服，报SN码即可查询到该固态的信息，核对固态的信息可知是否是正品。</li></ol></li></ul><h3 id="固态硬盘开箱"><a href="#固态硬盘开箱" class="headerlink" title="固态硬盘开箱"></a>固态硬盘开箱</h3><ul><li>首先打开包装封口，打开包装。，首先看到的是固态硬盘的说明书，里面是对硬盘的使用的基本介绍和保修说明。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img8.webp" alt="硬盘说明书"></li><li>说明书下面就是固态硬盘<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img9.webp" alt="固态硬盘"></li><li>拿起固态硬盘，是手感非常好的磨砂材质，感觉非常轻，在背面也贴有固态硬盘的SN码等基本信息。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img10.webp" alt="固态硬盘背面"></li></ul><h2 id="清灰、换硅脂和加装固态全过程"><a href="#清灰、换硅脂和加装固态全过程" class="headerlink" title="清灰、换硅脂和加装固态全过程"></a>清灰、换硅脂和加装固态全过程</h2><p>拆机之前一定注意的是：<strong>找个地方分开放每个步骤拆下的螺丝，避免弄丢螺丝或者找不到螺丝</strong>。</p><ol><li>首先将笔记本翻过来，向两边推打开电池的锁，取下电池。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img11.webp" alt="拆下笔记本电池"></li><li>拧开图示两颗螺丝，往下推D壳盖板即可拆下。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img12.webp" alt="拆下D壳盖板"></li><li>将内存槽两边的铁片往两边向外掰即可弹出内存条。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img13.webp" alt="拆下内存条"><br> 这个内存条是我之前在某东上入手的金士顿骇客神条(4G ddr3l 1600)。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img14.webp" alt="金士顿骇客神条"></li><li>拧下硬盘位周围的三颗螺丝，往外推即可拆下机械硬盘。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img15.webp" alt="拆下机械硬盘"><br> 原装使用的是日立7200转的500G机械硬盘。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img16.webp" alt="原装日立机械硬盘"></li><li>拧开D壳面的螺丝，需要注意电池两边的螺丝要比其它的长一些，装机的时候要注意，不要拧错了。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img17.webp" alt="拧开D壳面螺丝"></li><li>拆开C壳卡扣。将电脑翻过来，打开笔记本盖，用指甲插入C壳和D壳的缝隙中，然后从指甲打开的缝隙中插入一张卡片，用这张卡片将C壳的三面的卡扣都打开，拆。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img18.webp" alt="用一张卡片打开C壳卡扣"></li><li>打开C壳的三面的卡扣之后可以很轻易的将C壳从正面打开，但是要注意打开的幅度不能太大，因为C壳上有排线连接到主板上，如果打开的幅度很大，有可能损坏排线。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img19.webp" alt="小心翼翼打开C壳，看到C壳下的排线"></li><li>断开C壳排线。排线接口有一个类似锁扣的结构防止排线从接口中脱落，因此要断开排线需要把排线接口上的锁扣往上掰，打开后就可以断开排线了。（在网上查了资料，这种应该叫做锁扣排线。几种排线接口的资料<a href="https://www.jb51.net/softjc/453914.html" target="_blank" rel="noopener">https://www.jb51.net/softjc/453914.html</a>）<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img20.webp" alt="断开三条锁扣排线"></li><li>小心移除C壳，可以看到整个电脑的内部结构。我们可以看到4年没拆过的电脑中有非常多的灰，两个扬声器上面掉满了灰尘。拧开图示的螺丝，准备拆下光驱。<br> <img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img21.webp" alt="fx50j内部结构"></li><li>往外推即可拆下光驱。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img22.webp" alt="外推拆下光驱"></li><li>拆下光驱的固定铁片，拧下上面的两颗螺丝。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img23.webp" alt="拆下固定挡片"></li><li>将拆下的贴片固定到光驱位硬盘托架上，使用之前固定的螺丝固定即可。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img24.webp" alt="贴片固定的位置"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img25.webp" alt="固定好的样子"></li><li>为了测试光驱位硬盘支架，准备先将机械硬盘装到光驱位测试开机。首先找到固定机械硬盘的4螺丝（圈起来的螺丝一边两颗），拧掉即可将机械硬盘从硬盘支架上拆下。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img26.webp" alt="拆下机械硬盘"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img27.webp" alt="硬盘位托架，之后用于固定固态硬盘"></li><li>使用硬盘托架赠送的软胶塞塞入四个固定孔位，防止在装入硬盘后硬盘在托盘内晃动。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img28.webp" alt="在螺丝孔内塞入固定胶塞"></li><li>将硬盘装入光驱硬盘托架。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img29.webp" alt="硬盘装入托架，并且使用后固定胶塞将硬盘固定在托架内"></li><li>将光驱硬盘托架装入光驱位，拧上固定螺丝。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img30.webp" alt="将托架推入光驱位，使用螺丝固定"></li><li>接上开机排线，连接外接电源，尝试开机。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img31.webp" alt="测试光驱托架正常开机"></li><li>能正常开机后，把原光驱的挡板拆下，装到光驱托架上。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img32.webp" alt="拆下光驱挡板"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img33.webp" alt="挡板装到托架的侧面"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img34.webp" alt="给光驱硬盘托架装上挡板"></li><li>将固态硬盘装到硬盘支架上，拧上固定螺丝。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img35.webp" alt="将固态硬盘放入硬盘位"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img36.webp" alt="将两侧的固定螺丝拧上"></li><li>弄完硬盘之后，进行清灰和更换硅脂。首先拆下无线网卡的天线，这里的话是一黑一白两根天线，接着拧下无线网卡的固定螺丝，即可取下无线网卡。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img37.webp" alt="拆下天线和网卡固定螺丝"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img38.webp" alt="取下无线网卡"></li><li>拧下固定主板的螺丝，注意散热器和主板是固定在一起的，所以要把固定散热器的两个螺丝也拧掉，同时取掉usb小板的排线。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img39.webp" alt="拧下主板和散热风扇的固定螺丝，取下usb小板的排线"></li><li>拆下主板可以看到在D壳里面已经积累的很多的灰尘。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img40.webp" alt="D壳"></li><li>使用软毛刷去除D壳内的灰尘。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img41.webp" alt="毛刷清除D壳的灰尘"></li><li>在处理主板之前，应该取下主板背面的电池。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img42.webp" alt="取下主板电池"></li><li>拆掉散热器的固定螺丝。取下散热器。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img43.webp" alt="拆下散热器固定螺丝"><br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img44.webp" alt="拆下散热器"></li><li>使用软毛刷去除主板两面上积累的灰尘。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img45.webp" alt="刷去主板上的灰尘"></li><li>使用软毛刷清理风扇里的灰尘。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img46.webp" alt="刷去风扇上的灰尘"></li><li>使用吹风机吹掉残余的灰尘。</li><li>去掉散热器上残留的硅脂。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img47.webp" alt="去掉散热器上的硅脂"></li><li>去掉CPU和GPU核心上残留的硅脂，如果硅脂完全硬化了，不建议强行清除，强行清除可能会损坏核心，可以使用沾有无水酒精的棉球进行擦除。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img48.webp" alt="去除CPU和GPU核心的硅脂"></li><li>给CPU和GPU核心涂上硅脂。在核心上挤上一小点硅脂，能够在核心上薄薄覆盖上一层硅脂即可（尽可能薄）。<em>忘记拍照了，网上有涂硅脂的教程</em></li><li>按照拆机的步骤将散热器装回，注意，散热器要尽量对准孔位再装上去，避免散热器移动导致硅脂不均匀。</li><li>装上主板电池之后，接上电源接口、屏线和光驱硬盘托架测试是否能正常开机。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img49.webp" alt="装上主板电池"></li><li>测试正常开机之后，按照之前的拆机步骤装好主板，连接好电源接口、扬声器接口、屏线、无线网卡和usb小板排线，注意安装usb小板的排线不要被主板压住了。</li><li>按照拆机步骤装好光驱，连接好C壳排线，扣上C壳卡扣。</li><li>拧上D壳上螺丝，装好固态硬盘和内存条。</li><li>安装好电池和D壳盖板。</li><li>测试开机是否正常。<br><img src="/2019/10/31/华硕飞行堡垒fx50j加固态、清灰及更换硅脂过程/img50.webp" alt="开机成功"></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然中间拆了好几次电脑，但是最后电脑维护完美结束。维护过程中最重要的是要细心一些，拆不下来不要使用暴力拆解。一定要注意在接触主板电路之前，释放一下人体的静电（通过接触接地的金属物品释放），避免静电击穿电路。</p><p>装机的时候一定要仔细一点，不要遗忘了安装某些东西。我最后忘记接上usb小板的排线导致又拆了一次电脑的教训。</p><p>最重要最重要的是把拆机的螺丝分步骤分开放，不然装机的时候将是噩梦。会发现找不到合适的螺丝或者装完机后还剩余螺丝。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>拆机参考资料:&lt; <a href="https://post.smzdm.com/p/395720/" target="_blank" rel="noopener">https://post.smzdm.com/p/395720/</a> &gt;<br>拆机参考资料:&lt; <a href="http://tieba.baidu.com/p/5717515872" target="_blank" rel="noopener">http://tieba.baidu.com/p/5717515872</a> &gt;<br>固态部分参考资料:&lt; <a href="http://tieba.baidu.com/p/6169820508" target="_blank" rel="noopener">http://tieba.baidu.com/p/6169820508</a> &gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看着我2015年购入的笔记本电脑，使用差不多4年的时间了，至今没有进行过清灰和更换硅脂。最近电脑的温度偏高，估计是内部灰尘积累和硅脂已经完全
      
    
    </summary>
    
      <category term="生活" scheme="http://qzt8315.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="计算机" scheme="http://qzt8315.github.io/categories/%E7%94%9F%E6%B4%BB/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="PC" scheme="http://qzt8315.github.io/tags/PC/"/>
    
      <category term="维护" scheme="http://qzt8315.github.io/tags/%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>档案对比工具</title>
    <link href="http://qzt8315.github.io/2019/10/30/%E6%A1%A3%E6%A1%88%E5%AF%B9%E6%AF%94%E5%B7%A5%E5%85%B7/"/>
    <id>http://qzt8315.github.io/2019/10/30/档案对比工具/</id>
    <published>2019-10-30T09:48:26.000Z</published>
    <updated>2019-11-17T09:39:02.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>档案对比工具一般是对ASCII纯文字文档进行对比，也可以对非纯文字文档进行对比。linux中常用的档案对比工具有diff、cmp和patch等。diff是对比ASCII纯文字文档，cmp可以对比非纯文字文档，</p><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>diff工具一般用在纯文本文档中，以行为单位。</p><p>diff的基本语法如下：</p><pre><code class="bash">diff [-bBi] from-file to-file选项与参数:-b:忽略一行中多个空格的差异，例如&#39;about me&#39;和&#39;about  me&#39;，有一个空格和两个空格，但是&#39;b&#39;选项将两个字符串判定为相同的字符串;-B:忽略空白行的差别;-i:忽略大小写的差别。from-file:文档名，对比的参考文件;to-file:文档名，目标对比文件;</code></pre><p>这里，我们使用一个例子来进行diff的演示。</p><ol><li>使用<code>mkdir /tmp/passwdt &amp;&amp; cd /tmp/passwdt &amp;&amp; cat /etc/passwd | tee passwd.old | sed -e &#39;4d&#39; &gt; passwd.new</code>创建路径/tmp/passwdt并设置当前路径为/tmp/passwdt并将原本的passwd内容制作两份文档。<br><img src="/2019/10/30/档案对比工具/img1.webp" alt="passwd.old文档内容"><br><img src="/2019/10/30/档案对比工具/img2.webp" alt="passwd.new文档内容"></li><li>比较两份文档的区别，<code>diff /tmp/passwdt/passwd.old /tmp/passwdt/passwd.new</code>结果如下图:<br><img src="/2019/10/30/档案对比工具/img3.webp" alt="用diff比较passwd.old和passwd.new的区别"><br>其中<strong>4d3</strong>表示参考文档的第四行被删除，对比的是目标对比文件的第三行。后面紧跟着的一行是被删除的内容。</li></ol><p>diff工具除了能比较纯文本文件以外还能对目录等进行比较。</p><h2 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h2><p>cmp用于比较两个文档字节的差别，与diff的行比较不同，cmp是以字节为单位进行比较，也可以比较二进制文档。下面以对比passwd.new和passwd.old两个文档，执行结果如下:</p><p><img src="/2019/10/30/档案对比工具/img4.webp" alt="cmp对比结果"></p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>patch和diff有一定的联系，在diff中得到两个文件的差异，而在patch中则是构建前后两个文档通过差异建立联系，也就是补丁档，可以一个文件通过补丁档得到另外一个文件。示例如下：</p><ol><li><p>创建补丁档<br>命令<code>diff -Naur passwd.old passwd.new &gt; passwd.patch</code><br><img src="/2019/10/30/档案对比工具/img5.webp" alt="diff创建补丁"></p></li><li><p>使用patch打补丁</p><pre><code class="bash"># patch用法讲解patch -pN &lt; patch_file #更新文件，将旧文件更新为新文件# -p 后面的数字表示取消几层目录patch -R &lt; patch_file #还原文件，将新文件还原为之前的文件# -R 表示将新档案还原成就档案</code></pre><p>命令<code>patch -p0 &lt; passwd.patch</code>即可将旧文件更新为新文件内容;<br>命令<code>patch -R &lt; passwd.patch</code>即可将新文件还原为旧文件内容;</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜-第十一章:&lt;  <a href="http://linux.vbird.org/linux_basic/0330regularex.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0330regularex.php</a> &gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;档案对比工具一般是对ASCII纯文字文档进行对比，也可以对非纯文字文档进行对比。linux中常用的档案对比工具有diff、cmp和patch
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="linux" scheme="http://qzt8315.github.io/tags/linux/"/>
    
      <category term="diff" scheme="http://qzt8315.github.io/tags/diff/"/>
    
      <category term="cmp" scheme="http://qzt8315.github.io/tags/cmp/"/>
    
      <category term="patch" scheme="http://qzt8315.github.io/tags/patch/"/>
    
  </entry>
  
  <entry>
    <title>awk工具</title>
    <link href="http://qzt8315.github.io/2019/10/18/awk%E5%B7%A5%E5%85%B7/"/>
    <id>http://qzt8315.github.io/2019/10/18/awk工具/</id>
    <published>2019-10-17T16:47:46.000Z</published>
    <updated>2019-11-17T09:38:35.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="命令形式"><a href="#命令形式" class="headerlink" title="命令形式"></a>命令形式</h2><pre><code>awk &#39;条件类型1{动作1}条件类型2{动作2}...&#39; filename</code></pre><p>awk主要是处理每一行的栏位内的资料，预设的分隔符号为空格或者制表符。</p><p><strong>例子</strong>:列出ssh最后五条登陆记录，并用awk只显示登陆用户名、登陆时间和登陆ip。命令<code>last -n 5 | egrep -v &quot;reboot|^$|wtmp&quot; | awk &#39;{print $1 &quot;\t&quot; $5&quot; &quot;$6&quot; &quot;$7 &quot;\t&quot; $3}&#39;</code><br><img src="/2019/10/18/awk工具/img1.webp" alt="提取最后5条登陆信息中的登陆用户名、登陆时间和登陆ip"></p><h2 id="awk一般处理流程"><a href="#awk一般处理流程" class="headerlink" title="awk一般处理流程"></a>awk一般处理流程</h2><p>一般awk的处理流程如下：</p><ol><li>读入一行，并根据分隔符进行分割，一次用$1、$2……表示（<em>注意</em>:$0表示的该行完整内容）；</li><li>根据条件类型，决定后面紧跟的动作是否进行；</li><li>完成所用的条件判断及符合条件的动作执行；</li><li>如果后续还有内容则选择下一行继续进行1处理</li></ol><h2 id="awk内建变量"><a href="#awk内建变量" class="headerlink" title="awk内建变量"></a>awk内建变量</h2><p>以下为常用的内建变量名称，详细的内建变量名称可以通过<code>man awk</code>查询。</p><table><thead><tr><th align="center">内建变量名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">NF</td><td align="center">每一行分割之后的栏位个数</td></tr><tr><td align="center">NR</td><td align="center">目前处理字符串的行数</td></tr><tr><td align="center">FS</td><td align="center">目前的分隔字符</td></tr></tbody></table><h2 id="awk逻辑运算符"><a href="#awk逻辑运算符" class="headerlink" title="awk逻辑运算符"></a>awk逻辑运算符</h2><p>逻辑运算符使用在条件类型中，用于判断条件，是否执行后边的动作命令。</p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">==</td><td align="center">等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr></tbody></table><h2 id="使用的注意事项"><a href="#使用的注意事项" class="headerlink" title="使用的注意事项"></a>使用的注意事项</h2><p>awk指令的间隔：所用的awk命令都用’{}’括起来，如果在一个动作中使用多个命令，则使用’;’间隔，或者使用回车换行间隔。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜:&lt; <a href="http://linux.vbird.org/" target="_blank" rel="noopener">http://linux.vbird.org/</a> &gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;命令形式&quot;&gt;&lt;a href=&quot;#命令形式&quot; class=&quot;headerlink&quot; title=&quot;命令形式&quot;&gt;&lt;/a&gt;命令形式&lt;/h
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="linux" scheme="http://qzt8315.github.io/tags/linux/"/>
    
      <category term="awk" scheme="http://qzt8315.github.io/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>sed工具</title>
    <link href="http://qzt8315.github.io/2019/10/08/sed%E5%B7%A5%E5%85%B7/"/>
    <id>http://qzt8315.github.io/2019/10/08/sed工具/</id>
    <published>2019-10-08T08:35:40.000Z</published>
    <updated>2019-11-17T09:38:07.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客中，主要是讲linux系统常用的工具sed。sed是一个管线命令可以对输入进行替换、删除、增加和检索特定行。</p><h2 id="常用的参数"><a href="#常用的参数" class="headerlink" title="常用的参数"></a>常用的参数</h2><pre><code class="bash">sed [-nefr] [动作]选项:-n: 使用静默模式，默认情况下，sed会将所有的stdin都输出到屏幕上，使用-n参数之后仅仅显示处理那一行；-e: 使用指令列模式进行sed动作编辑；-f: sed的动作来源于一个文档，一般为`-f filename`，则执行filename文件内的sed动作；-r: 表示sed支持拓展正则表达式语法；-i: 直接修改文档，不输出到屏幕。动作说明: [n1[,n2]]functionn1,n2 不一定会存在，一般表示进行动作的行数，处理10行到20行一般表示为`10,20`function一般是以下选项：a: 新增 `a 字符串`表示在当前行后面添一行，内容为字符串内容；c: 取代 `c 字符串`，表示字符串取代n1,n2表示行的内容；d: 删除 后不接内容；i: 插入 `i 字符串`,在目前行的前面新加一行，内容为字符串；p: 列印 将选择的内容打印出来，一般配合`sed -n`使用；s: 取代，直接进行取代工作，一般s配合正则表达式使用。注意，在命令后边下达的指令要用两个单引号括起来，例如操作，sed &#39;2,5d&#39;。</code></pre><p>其他更加详细的使用方法通过<code>man sed</code>指令查询。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li><p>将/etc/passwd中的的3到5行删除。命令<code>cat -n /etc/passwd | sed &#39;3,5d&#39;</code><br><img src="/2019/10/08/sed工具/img1.webp" alt="删除/etc/passwd的3到5行输出"><br>当需要删除第二行时，使用命令<code>sed &#39;2d&#39;</code>;<br>当要删除第二行到最后一行时，使用命令<code>sed &#39;2,$d&#39;</code></p></li><li><p>在/etc/passwd中的第3行前添加’add by sed’。命令<code>cat -n /etc/passwd | sed &#39;3iadd by sed&#39;</code></p></li></ol><p><img src="/2019/10/08/sed工具/img2.webp" alt="在/etc/passwd的第三行前面添加特定内容"><br>3. 在/etc/passwd中的第3行后添加’add by sed’。命令<code>cat -n /etc/passwd | sed &#39;3aadd by sed&#39;</code><br><img src="/2019/10/08/sed工具/img3.webp" alt="在/etc/passwd的第三行后面添加特定内容"></p><ol start="4"><li><p>将/etc/passwd的第二行取代为’this line is replaced by sed’，命令<code>cat -n /etc/passwd | sed &#39;2cthis line is replaced by sed&#39;</code><br><img src="/2019/10/08/sed工具/img4.webp" alt="将/etc/passwd的第二行替换"></p></li><li><p>替换行的部分数据，命令格式<code>sed &#39;s/被替换的字符串/新的字符串/g&#39;</code>，将/etc/passwd中的test替换为tt，执行命令<code>cat -n /etc/passwd | sed &#39;s/test/tt/g&#39;</code><br><img src="/2019/10/08/sed工具/img5.webp" alt="使用sed工具检索并替换"></p></li><li><p>sed可以直接修改文档内容，可以直接在命令后面接文档名称就可以直接修改文档名称，例如我们将文件中的所有’,’修改为’.’，那么命令为<code>sed &#39;s/,/\./g&#39; filename</code>。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟叔的linux私房菜:&lt; <a href="http://linux.vbird.org/" target="_blank" rel="noopener">http://linux.vbird.org/</a> &gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本篇博客中，主要是讲linux系统常用的工具sed。sed是一个管线命令可以对输入进行替换、删除、增加和检索特定行。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="linux" scheme="http://qzt8315.github.io/tags/linux/"/>
    
      <category term="入门" scheme="http://qzt8315.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://qzt8315.github.io/2019/10/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://qzt8315.github.io/2019/10/05/正则表达式/</id>
    <published>2019-10-05T15:53:31.000Z</published>
    <updated>2019-10-17T16:48:05.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正则表达式是一个优秀的文字处理方式，可以通过简单的匹配实现字符串的检索、替换或者删除处理，在信息提取、运营维护方面有重要的应用。</p><h2 id="具有特殊含义的符号"><a href="#具有特殊含义的符号" class="headerlink" title="具有特殊含义的符号"></a>具有特殊含义的符号</h2><table><thead><tr><th align="center">符号</th><th align="center">作用</th><th align="center">示例</th><th align="center">示例解释</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">表示数字和大小写英文字母</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:alpha:]</td><td align="center">表示大小写英文字母</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:blank:]</td><td align="center">表示空格和制表符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:cntrl:]</td><td align="center">表示键盘的控制按键，包括CR、LF、Tab，Del等等</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:digit:]</td><td align="center">表示数字</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:graph:]</td><td align="center">除空格和制表符之外的其他按键，不包括控制符号</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:lower:]</td><td align="center">表示小写字母</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:upper:]</td><td align="center">表示大写字母</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:print:]</td><td align="center">表示可以打印的符号</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:punct:]</td><td align="center">表示标点符号，如,.’”等等</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:space:]</td><td align="center">表示任何的空白字符，包括空格，制表符和控制符号</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[:xdigit:]</td><td align="center">表示16进制数，匹配0-9,AF和af</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[]</td><td align="center">表示中括号中任何一个字符匹配，可以使用范围表示字符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">[^]</td><td align="center">而中括号中加上’^’符号，表示不包含这个括号中的任何一个字符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">^$</td><td align="center">当’^’和’$’分开出现的时候，分表表示起始和结束</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">\</td><td align="center">后接特殊字符表示本来的字符，无特殊意义</td><td align="center">\.\+</td><td align="center"></td></tr><tr><td align="center">.</td><td align="center">表示任何一个字符</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">*</td><td align="center">表示重复匹配前面的字符0次或多次</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">\{n,m\}</td><td align="center">括号中填写数字n,m表示匹配前一字符n到m次</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">\{n\}</td><td align="center">括号中填写数字n表示匹配前一字符n次</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="拓展正则表达式"><a href="#拓展正则表达式" class="headerlink" title="拓展正则表达式"></a>拓展正则表达式</h2><p>grep默认参数仅支持基础正则表达式，可以使用<code>grep -E</code>或者<code>egrep</code>开启使用扩展正则表达式。拓展正则表达式如下表所示:</p><table><thead><tr><th align="left">RE符号</th><th align="center">意义</th><th align="center">示例</th><th align="center">示例解释</th></tr></thead><tbody><tr><td align="left">+</td><td align="center">重复一个或者以上</td><td align="center">go+d</td><td align="center">匹配god、good、goood等等</td></tr><tr><td align="left">?</td><td align="center">匹配0个或者1个</td><td align="center">go?d</td><td align="center">匹配gd和god</td></tr><tr><td align="left">|</td><td align="center">或</td><td align="center">good|glad</td><td align="center">匹配good或者glad</td></tr><tr><td align="left">()</td><td align="center">表示多个字符的字串</td><td align="center">g(oo|la)d</td><td align="center">匹配good或者glad</td></tr><tr><td align="left">()+</td><td align="center">将()内匹配的字符串匹配1次及更多</td><td align="center">a(bc)+d</td><td align="center">匹配abc…d字符串</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>鸟哥的linux私房菜第十一章:&lt; <a href="http://linux.vbird.org/linux_basic/0330regularex.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0330regularex.php</a> &gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正则表达式是一个优秀的文字处理方式，可以通过简单的匹配实现字符串的检索、替换或者删除处理，在信息提取、运营维护方面有重要的应用。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="编程" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="正则表达式" scheme="http://qzt8315.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深度学习中一些概念的东西</title>
    <link href="http://qzt8315.github.io/2019/09/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <id>http://qzt8315.github.io/2019/09/03/深度学习中一些概念的东西/</id>
    <published>2019-09-03T06:25:02.000Z</published>
    <updated>2019-09-03T06:37:43.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在本篇博客中主要是用于记录深度学习中一些概念性的词语。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><table><thead><tr><th align="center">专业术语</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">超平面</td><td align="center">n维欧式空间中余维度等于1的子空间。即n维空间中的超平面是n-1维的子空间。</td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/超平面" target="_blank" rel="noopener">超平面-来源:维基百科</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在本篇博客中主要是用于记录深度学习中一些概念性的词语。&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://qzt8315.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="概念" scheme="http://qzt8315.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>作息时间安排</title>
    <link href="http://qzt8315.github.io/2019/09/02/%E4%BD%9C%E6%81%AF%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92/"/>
    <id>http://qzt8315.github.io/2019/09/02/作息时间安排/</id>
    <published>2019-09-02T07:07:41.000Z</published>
    <updated>2019-09-02T10:49:16.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>到云南已经一个月了，但是导师安排的工作还没什么进展。为了充分利用时间和提高工作效率，特别安排工作的时间表，最大程度利用时间。</p><h3 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h3><p>目前课程主要集中在上午和晚上，主要负责初一（1）班和初一（3）班的数学课程，课程安排如下表（七年级上册）:</p><table><thead><tr><th align="center">时间</th><th align="center">星期一</th><th align="center">星期二</th><th align="center">星期三</th><th align="center">星期四</th><th align="center">星期五</th></tr></thead><tbody><tr><td align="center">上午第一节</td><td align="center"></td><td align="center">初一(1)</td><td align="center"></td><td align="center">初一(3)</td><td align="center"></td></tr><tr><td align="center">上午第二节</td><td align="center">初一(1)</td><td align="center"></td><td align="center"></td><td align="center">初一(1)</td><td align="center">初一(1)</td></tr><tr><td align="center">上午第三节</td><td align="center">初一(3)</td><td align="center">初一(3)</td><td align="center">初一(3)</td><td align="center">初一(1)</td><td align="center">初一(3)</td></tr><tr><td align="center">上午第四节</td><td align="center"></td><td align="center">初一(3)</td><td align="center">初一(1)</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">晚自习第一节</td><td align="center">初一(1)</td><td align="center"></td><td align="center"></td><td align="center">初一(3)</td><td align="center"></td></tr><tr><td align="center">晚自习第二节</td><td align="center">初一(1)</td><td align="center"></td><td align="center"></td><td align="center">初一(3)</td><td align="center"></td></tr></tbody></table><p>上午有零碎的时间，下午为较为完整的时间，上午的时间主要用于对第二天课程准备，下午和晚自习主要用于自己的事情。除要上的晚自习以外的其他时间安排如下表所示：</p><table><thead><tr><th align="center">时间</th><th align="center">计划</th></tr></thead><tbody><tr><td align="center">午饭之后半个小时</td><td align="center">饭后休息</td></tr><tr><td align="center">13:00前</td><td align="center">午休</td></tr><tr><td align="center">13:00~14:00</td><td align="center">看书</td></tr><tr><td align="center">14:00-15:00</td><td align="center">读论文</td></tr><tr><td align="center">15:00-16:00</td><td align="center">学习linux</td></tr><tr><td align="center">16:00-17:00</td><td align="center">看书</td></tr><tr><td align="center">17:00-18:30</td><td align="center">吃晚饭</td></tr><tr><td align="center">18:30-19:10</td><td align="center">休息</td></tr><tr><td align="center">19:10-19:50</td><td align="center">读论文</td></tr><tr><td align="center">19:50-20:40</td><td align="center">看书</td></tr><tr><td align="center">20:40-22:00</td><td align="center">做和计算机有关的事情</td></tr><tr><td align="center">22:00-23:00</td><td align="center">洗澡、洗衣服</td></tr><tr><td align="center">23:00-24:00</td><td align="center">准备睡觉</td></tr></tbody></table><p>安排表为初步安排，可根据实际情况调整，创建时间:2019年09月02日，修改时间：2019年09月02日。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;到云南已经一个月了，但是导师安排的工作还没什么进展。为了充分利用时间和提高工作效率，特别安排工作的时间表，最大程度利用时间。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="生活" scheme="http://qzt8315.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="作息时间" scheme="http://qzt8315.github.io/tags/%E4%BD%9C%E6%81%AF%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>西瓜书_第四章</title>
    <link href="http://qzt8315.github.io/2019/08/30/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>http://qzt8315.github.io/2019/08/30/西瓜书-第四章/</id>
    <published>2019-08-30T06:54:48.000Z</published>
    <updated>2019-08-30T13:19:29.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本章中主要学习决策树的构建，决策树就是使用“分而治之”的思想对样本进行处理。决策树学习的目标是为了产生一棵泛化能力强的模型。</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="算法结束"><a href="#算法结束" class="headerlink" title="算法结束"></a>算法结束</h3><p>决策算法使用递归方式构建模型，有三种情况会导致递归返回：</p><ol><li>当前节点包含的样本全部属于同一类别，无需划分；</li><li>当前属性集为空，或时所有样本在属性上取值相同，无法划分；</li><li>当前节点包含的样本集合为空，不能划分。</li></ol><h3 id="属性划分原则"><a href="#属性划分原则" class="headerlink" title="属性划分原则"></a>属性划分原则</h3><p>决策树中，如何选择最优的划分属性？在划分过程中，希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的“纯度”（purity）越高越好。</p><h3 id="信息增益——ID3决策树算法"><a href="#信息增益——ID3决策树算法" class="headerlink" title="信息增益——ID3决策树算法"></a>信息增益——ID3决策树算法</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>信息熵</strong>是衡量样本集合纯度最常用的一种指标。假定当前样本集合D中，第k类样本所占比例为p<sub>k</sub>,(k=1,2…,|y|),则信息熵的定义为：<br>$$<br>Ent(D)=-\sum^{|y|}_{k=1}p_k\log p_k<br>$$<br>Ent(D)的值越小，D的纯度越高，不确定性越小，决策树往熵减的方向划分。</p><p>说到信息熵不得不说到<strong>信息</strong><a href="https://blog.csdn.net/qq280929090/article/details/78135417" target="_blank" rel="noopener">（参考来源）</a>，衡量不确定性，衡量方式：$-log(x)$。</p><p><strong>信息增益(Indormation Gain)</strong>描述的是划分前后信息熵的变化。假定属性a有V个值${a^1,a^2,\ldots,a^v}$，第v个分支表示属性a取值为a<sup>v</sup>的全部样本D<sup>v</sup>,表达式如下：<br>$$<br>Gain(D,a)=Ent(D)-\sum^{V}_{v=1}\frac{|D^v|}{|D|}Ent(D^v)<br>$$</p><p><strong>ID3决策树算法使用信息增益选择划分属性。</strong></p><h3 id="增益率——C4-5决策树算法"><a href="#增益率——C4-5决策树算法" class="headerlink" title="增益率——C4.5决策树算法"></a>增益率——C4.5决策树算法</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>增益率表达如下:<br>$$<br>Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}<br>$$</p><p>其中IV(a)为属性a的固有值，计算方式如下：<br>$$<br>IV(a)=-\sum^V_{v=1}\frac{|D^v|}{|D|}\log^{\frac{|D^v|}{|D|}}_{2}<br>$$</p><h3 id="基尼指数——CART决策树算法"><a href="#基尼指数——CART决策树算法" class="headerlink" title="基尼指数——CART决策树算法"></a>基尼指数——CART决策树算法</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><strong>基尼值</strong>：</p><p>$$<br>\begin{align}<br>Gini(D) &amp;=\sum^{|y|}_{k=1}\sum_{k\neq k’}p_kp_{k’}\\<br>&amp;=1-\sum^{|y|}_{k=1}p^2_k<br>\end{align}<br>$$</p><p>其中k为样本类型。Gini(D)越小，D的纯度越高。</p><p><strong>基尼指数</strong>：<br>$$<br>Gini\_index(D,a)=\sum^V_{v=1}\frac{|D^v|}{|D|}Gini(D^v)<br>$$</p><h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>剪枝是为了防止决策树算法过拟合的方法。</p><h3 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对每个节点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能的提升，则停止划分并将当前节点标记为叶结点。经过预剪枝的决策树不易造成过拟合，并且可以减少训练时间和开销，但是有欠拟合的风险。</p><h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>先从训练集中生成一棵完整的决策树，然后自底向上考察非叶结点，如果将该子树替换为叶结点能带来决策树泛化性能提高，则将该子树他替换为叶结点。后剪枝欠拟合风险小，泛化性能优于预剪枝，但是训练时间和开销较大。</p><h2 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h2><p>即连续值离散化处理</p><p>对连续属性a，可考察包含n-1个元素的候选划分点集合。</p><p>$$<br>T_a=\{\frac{a^i+a^{i+1}}{2}|1 \leqslant i \leqslant n-1\}<br>$$</p><p>逐个对划分点进行考察，选择最佳划分点：</p><p>$$<br>\begin{align}<br>Gain(D,a)&amp;=Gain(D,a,t)\\<br>&amp;=\max_{t\in T_a}Ent(D)-\sum_{\lambda\in\{-,+\}}\frac{|D^\lambda_t|}{|D|}Ent(D^\lambda_t)<br>\end{align}<br>$$</p><p>计算出来的信息熵增益值可以离散属性相比较。</p><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>在实际中存在不完整样本，即样本的某些属性缺失。</p><p>假设数据集为$D$，属性值完整的样本构成$\widetilde D$,并且每个样本赋予一个权重$\omega_x$,则：</p><p><strong>未缺失属性样本比例：</strong><br>$$<br>\rho=\frac{\sum_{x\in\widetilde D}\omega_x}{\sum_{x\in D}\omega_x}<br>$$</p><p><strong>未缺失属性样本中k标签的比例：</strong><br>$$<br>\widetilde p_k=\frac{\sum_{x\in\widetilde D_k}\omega_x}{\sum_{x\in {\widetilde D}}\omega_x},(1\leqslant k\leqslant|y|)<br>$$</p><p><strong>无缺失样本中a取值v的比例：</strong></p><p>$$<br>\widetilde r_v=\frac{\sum_{x\in\widetilde D^v}\omega_x}{\sum_{x\in {\widetilde D}}\omega_x},(1\leqslant v\leqslant V)<br>$$</p><h3 id="插值信息增益"><a href="#插值信息增益" class="headerlink" title="插值信息增益"></a>插值信息增益</h3><p>$$<br>\begin{align}<br>Gain(D,a)&amp;=\rho×Gain(\widetilde D,a)\\<br>&amp;=\rho×(Ent(\widetilde D)-\sum^V_{v=1}\widetilde r_vEnt(\widetilde D^v))<br>\end{align}<br>$$</p><p>其中，</p><p>$$<br>Ent(\widetilde D)=-\sum^{|y|}_{k=1}\widetilde p_k \log^{\widetilde p_k}_2<br>$$</p><p>若属性已知则$\omega_x$不变，若为未知，则将x同时划入所有节点中，且样本中的权值调整为：$\widetilde r_v·\omega_x$</p><h2 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h2><p>多变量决策树的主要作用在于简化决策树结构</p><p>在非叶结点中，不是对单个属性进行判断，而是对属性的线性组合进行判断。</p><p>主要算法：OC1</p><h2 id="增量学习"><a href="#增量学习" class="headerlink" title="增量学习"></a>增量学习</h2><p>用于收到新样本之后调整模型。</p><p>算法：ID4、ID5R、ITI</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>后验概率</strong>：先知道结果，由结果估计原因的概率分布，P(交通方式|交通时间)–先知道花费的时间，估算使用交通工具的概率。</p><p><strong>先验概率</strong>：先于结果，估计原因的概率分布。</p><p><strong>似然估计</strong>： 先确定原因，根据原因估计结果的概率估计。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》作者：周志华</a>；</p><p><a href="https://blog.csdn.net/qq280929090/article/details/78135417" target="_blank" rel="noopener">详解信息熵</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本章中主要学习决策树的构建，决策树就是使用“分而治之”的思想对样本进行处理。决策树学习的目标是为了产生一棵泛化能力强的模型。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="读书" scheme="http://qzt8315.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="西瓜书" scheme="http://qzt8315.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    
      <category term="西瓜书" scheme="http://qzt8315.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
      <category term="读书" scheme="http://qzt8315.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="第四章" scheme="http://qzt8315.github.io/tags/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>linux中设置网卡bond</title>
    <link href="http://qzt8315.github.io/2019/08/25/linux%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%8D%A1bond/"/>
    <id>http://qzt8315.github.io/2019/08/25/linux中设置网卡bond/</id>
    <published>2019-08-24T17:37:32.000Z</published>
    <updated>2019-11-17T09:38:25.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇博客文章主要介绍linux系统中的网卡bond设置。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>本篇文章中使用ubuntu作为实现平台，在虚拟机下安装ubuntu 16.04版本，并添加了两张网卡设备。</p><h2 id="获取网卡设备名称"><a href="#获取网卡设备名称" class="headerlink" title="获取网卡设备名称"></a>获取网卡设备名称</h2><p>打开系统终端，运行指令<code>ifconfig -a</code><br><img src="/2019/08/25/linux中设置网卡bond/img1.webp" alt="获取网卡名称"><br>在本系统中网卡的名称为<strong>ens33</strong> 和<strong>ens38</strong> 。另外的lo为虚拟的网络接口，用于网络回环。</p><h2 id="获取网络网关"><a href="#获取网络网关" class="headerlink" title="获取网络网关"></a>获取网络网关</h2><p>在终端中运行指令<code>netstat -r</code><br><img src="/2019/08/25/linux中设置网卡bond/img2.webp" alt="从路由表中获取网关信息"><br>系统的网关地址为：192.168.59.2</p><h2 id="设置1模式的bond备份"><a href="#设置1模式的bond备份" class="headerlink" title="设置1模式的bond备份"></a>设置1模式的bond备份</h2><p>编辑/etc/network/interfaces文件，设置网卡配置如下：</p><pre><code>auto loiface lo inet loopbackauto ens33iface ens33 inet manualbond-master bond0auto ens38iface ens38 inet manualbond-master bond0auto bond0iface bond0 inet staticaddress 192.168.59.133netmask 255.255.255.0gateway 192.168.59.2dns-nameservers: 114.114.114.114bond-slaves ens33 ens38bond-lacp-rate 1bond-mode 1bond-miimon 100</code></pre><h2 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a>配置生效</h2><p>重启系统，在终端中运行<code>ifconfig</code>查看设置是否生效：<br><img src="/2019/08/25/linux中设置网卡bond/img3.webp" alt="查看bond是否成功"><br>执行命令之后，看到出现了新的虚拟网络设备bond0，设置已经生效。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>linux公社:<a href="https://www.linuxidc.com/Linux/2017-09/147164.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-09/147164.htm</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇博客文章主要介绍linux系统中的网卡bond设置。&lt;/p&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="linux" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/linux/"/>
    
    
      <category term="linux" scheme="http://qzt8315.github.io/tags/linux/"/>
    
      <category term="设置" scheme="http://qzt8315.github.io/tags/%E8%AE%BE%E7%BD%AE/"/>
    
      <category term="网卡" scheme="http://qzt8315.github.io/tags/%E7%BD%91%E5%8D%A1/"/>
    
      <category term="bond" scheme="http://qzt8315.github.io/tags/bond/"/>
    
  </entry>
  
  <entry>
    <title>网络基本概念</title>
    <link href="http://qzt8315.github.io/2019/08/21/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://qzt8315.github.io/2019/08/21/网络基本概念/</id>
    <published>2019-08-21T11:04:18.000Z</published>
    <updated>2019-08-22T06:02:29.142Z</updated>
    
    <content type="html"><![CDATA[<p>##　前言</p><p>在本篇博客中主要介绍一些基础的网络知识，对网络有基本的认识及设置。</p><h2 id="网络的概念"><a href="#网络的概念" class="headerlink" title="网络的概念"></a>网络的概念</h2><p><strong>网络</strong>的广义概念是指由若干节点和节点之间的链路组成，表示之间的相互联系。<sup>来源:<a href="https://baike.baidu.com/item/网络/143243" target="_blank" rel="noopener">百度百科</a></sup>比如电网、自来水网、路网、天然气网以及互联网（Internet）。而网络的狭义概念特指的是互联网。</p><p><strong>互联网</strong>指的是21世纪初网络与网络之间相互连接形成的超大型网络。</p><h2 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h2><p><img src="/2019/08/21/网络基本概念/img1.webp" alt="网络的结构"></p><p>从上图中可以看到网络的结构，最顶层为广域网，其下包括我们熟知的互联网、平时接触不到的大型跨地区企业内部网络等等也属于广域网。广域网是连接不同地区局域网的远程网，强调的是物理范围。而因特网仅仅指的是国际互联网，即全球计算机互联的网络，是广域网中的一种。</p><p>而互联网是由不同的网络连接形成的国际性网络，而这些不同的网络即是城域网。城域网指的是城市范围内的网络。</p><p>城域网连接的是一个个的局域网。这些局域网包括学校、公司以及家庭自建的无线局域网络等。</p><p>而在局域网下边还有个人局域网，包括各种蓝牙以及红外等连接。</p><h2 id="网络的基础设置"><a href="#网络的基础设置" class="headerlink" title="网络的基础设置"></a>网络的基础设置</h2><p>我们日常所能接触到的网络属于是局域网，掌握局域网的基本设置可以让我们获得更好的上网体验以及网络故障时做出相应的排查修复。</p><p>目前网络主要使用的是基于IPV4（32位二进制数字标签）的TCP/IP协议，由于IPV4（128位二进制数字标签）地址数量已经不能满足日益发展的网络，因此目前正在向IPV6过渡。IP地址是分配给用户上网使用的网际协议的设备的数字标签，即通过这个IP地址我们可以找到这台设备（Ps：在局域网中使用局域网地址即可找到，在广域网中使用唯一IP地址即可找到）。在局域网中常常需要设置的几个参数是：IP地址、子网掩码、默认网关、DNS服务器地址、DHCP服务。</p><p>首先说明IP地址，这里的IP地址填写的一个在网络(局域网或广域网)中唯一标志主机的地址。其作用就是能找到这台计算机。</p><p>子网掩码，指定网络号和主机号，掩码二进制位为1的部分为网络号，为0的部分为主机号。例如，IP地址为:192.168.1.10（11000000,10101000,00000001,00001010），子网掩码为:255.255.255.0（11111111,11111111,11111111,00000000），那么192.168.1是网络号，10是主机号。网络号作用是识别主机所在的网络，根据TCP/IP协议的规定，处于不同网络的计算机不能直接互相通信需要通过路由连接不同的局域网。主机号用于识别该网络中的主机。</p><p>网关就是一个网络通向另外网络的IP地址，当需要访问其他网络（如：另一个局域网或者广域网），需要通过网关来处理相应的数据，所以网关类似于一个关卡的作用，当你访问因特网或者其他网络的资源的时候都需要通过网关来实现，因此常常可以在网关上设置防火墙可以有效保证内部网络的安全。而默认网关就是当计算机找不到可用的网关时，将数据包发给默认指定的网关。</p><p>DNS服务器存在的意义在于方便人们去找到对应的计算机。如果网络资源都是通过IP来指定，那么记忆这些IP具有较大的困难。而记忆一个较短的字符串相对较为容易，那么使用一个字符串去查询一个IP地址，然后通过获取到的IP地址去访问主机相对于直接使用IP地址来说是更加合理的。这里通过一个字符串查询到一个IP地址的服务就是DNS服务，而提供这种服务的计算机就称为DNS服务器。</p><p>DHCP（全称为Dynamic Host Configuration Protocol，中文名称为动态主机配置协议）服务作用有两个，给内部的网络自动配置IP地址和管理员统一管理内部计算机。简单使用方法为：当一台计算机接入局域网中，回广播一条信息说明自己加入了这个网络，当DHCP接受到这个信息之后会私聊这台主机，并告诉这台主机的网络配置（包括IP地址，默认网关等等）。当然DHCP也可以为计算机指定固定的IP也可以不适用DHCP手动自己设置相应的网络配置。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote><p>百度百科:<a href="https://baike.baidu.com" target="_blank" rel="noopener">https://baike.baidu.com</a><br>CSDN博客:<a href="https://blog.csdn.net/huangyimo/article/details/82887367" target="_blank" rel="noopener">https://blog.csdn.net/huangyimo/article/details/82887367</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##　前言&lt;/p&gt;
&lt;p&gt;在本篇博客中主要介绍一些基础的网络知识，对网络有基本的认识及设置。&lt;/p&gt;
&lt;h2 id=&quot;网络的概念&quot;&gt;&lt;a href=&quot;#网络的概念&quot; class=&quot;headerlink&quot; title=&quot;网络的概念&quot;&gt;&lt;/a&gt;网络的概念&lt;/h2&gt;&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="网络" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://qzt8315.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="基础概念" scheme="http://qzt8315.github.io/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>秀米使用学习教程</title>
    <link href="http://qzt8315.github.io/2019/08/18/%E7%A7%80%E7%B1%B3%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"/>
    <id>http://qzt8315.github.io/2019/08/18/秀米使用学习教程/</id>
    <published>2019-08-18T05:36:50.000Z</published>
    <updated>2019-08-18T09:56:54.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客文章中主要介绍图文排版工具<strong>秀米</strong>&trade;的使用，将分别从基本工具说明和示例两个部分进行叙述。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>进入<a href="https://xiumi.us" target="_blank" rel="noopener">秀米官网</a>，登录账号(第一次使用需要注册)，选择<em>我的秀米<em>，单击</em>添加新的图文<em>进入图文排版编辑器。Ps：</em>以下的操作都是在编辑器下完成。</em></p><h2 id="基本工具说明"><a href="#基本工具说明" class="headerlink" title="基本工具说明"></a>基本工具说明</h2><ol><li><p>主要工具介绍<br><img src="/2019/08/18/秀米使用学习教程/img1.webp" alt="编辑器页面"><br>在秀米中进行图文排版十分的简单，右侧菜单主要是撤销和重做功能；上侧菜单主要是预览、保存、复制到公众号等功能；左侧菜单栏为主要的排版工作栏，其中最常用的是图文模板。其中图文模板主要分为标题、卡片、图片、布局、引导、组件等几类模板。</p><ul><li><em>标题</em>主要是用于文章中的标题部分，单击选中的标题即可添加标题到文章中，单击标题即可对标题的内容及其格式进行编辑设置。<br><img src="/2019/08/18/秀米使用学习教程/img2.webp" alt="添加并设置标题"></li><li><em>卡片</em>为文章的矩形元素，可以将文章的内容进行划分，同时加强内部的联系，可以使得文章逻辑清晰、美观。同样可以单击卡片对象即可对卡片进行编辑。<br><img src="/2019/08/18/秀米使用学习教程/img3.webp" alt="添加并设置卡片对象"></li><li><em>图片<em>可以向文章中插入图片，丰富文章内容。操作与标题类似，单击添加元素，单击即可设置自己的图片(</em>Ps:添加的图片需导入才能使用</em>)。<br><img src="/2019/08/18/秀米使用学习教程/img4.webp" alt="添加图片"></li><li><em>布局</em>是将多个元素组合之后的模板 。使用方式与标题相同。<br><img src="/2019/08/18/秀米使用学习教程/img5.webp" alt="添加布局"></li><li><em>引导</em>在文章中主要作用是引导读者的注意力的转移和集中。使用方法与标题相同。<br><img src="/2019/08/18/秀米使用学习教程/img6.webp" alt="添加引导"></li><li><em>组件</em>主要是一些小的部件，包括序号以及装饰部件等。使用方式与标题相同。<br><img src="/2019/08/18/秀米使用学习教程/img7.webp" alt="添加组件"></li></ul></li><li><p>修改文章标题和摘要。<br><img src="/2019/08/18/秀米使用学习教程/img8.webp" alt="修改标题和摘要"></p></li><li><p>点击上侧菜单栏的<em>预览</em>，预览文章。<br><img src="/2019/08/18/秀米使用学习教程/img9.webp" alt="预览"></p></li><li><p>点击上侧菜单栏的<em>保存</em>，保存文章到网站。<br><img src="/2019/08/18/秀米使用学习教程/img10.webp" alt="保存"></p></li><li><p>点击上侧菜单栏的<em>复制到微信公众号</em>按钮，按下<em>Ctrl+C</em>复制全文，将内容粘贴到微信公众平台编辑器，填入标题和摘要即可发布文章（同时也可以将多次编辑的内容粘贴到同一篇微信公众号文章中）<br><img src="/2019/08/18/秀米使用学习教程/img11.webp" alt="&quot;复制到公众号&quot;按钮"><br><img src="/2019/08/18/秀米使用学习教程/img12.webp" alt="&quot;Ctrl+C&quot;复制文章内容"><br><img src="/2019/08/18/秀米使用学习教程/img13.webp" alt="发布文章到微信公众号_图片来源于&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDE0MDA1Mw==&amp;mid=2650712096&amp;idx=1&amp;sn=7af2ea6e871f3e9679f2411fd5add5de&amp;chksm=be8652da89f1dbcc9fd1537311e5a23cb647c21a0ada716ba5ebb75e3c224f28cefec7fe6ba3#rd&quot;&gt;微信公众平台&lt;/a&gt;"></p></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2019/08/18/秀米使用学习教程/img14.webp" alt="演示示例"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>秀米官方帮助文档:<a href="https://r.xiumi.us/board/v5/2a5va/6103144" target="_blank" rel="noopener">https://r.xiumi.us/board/v5/2a5va/6103144</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本篇博客文章中主要介绍图文排版工具&lt;strong&gt;秀米&lt;/strong&gt;&amp;trade;的使用，将分别从基本工具说明和示例两个部分进行叙述。
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="秀米" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/%E7%A7%80%E7%B1%B3/"/>
    
    
      <category term="教程" scheme="http://qzt8315.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="H5" scheme="http://qzt8315.github.io/tags/H5/"/>
    
      <category term="秀米" scheme="http://qzt8315.github.io/tags/%E7%A7%80%E7%B1%B3/"/>
    
      <category term="图文排版" scheme="http://qzt8315.github.io/tags/%E5%9B%BE%E6%96%87%E6%8E%92%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>易企秀使用学习教程</title>
    <link href="http://qzt8315.github.io/2019/08/17/%E6%98%93%E4%BC%81%E7%A7%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"/>
    <id>http://qzt8315.github.io/2019/08/17/易企秀使用学习教程/</id>
    <published>2019-08-17T06:14:40.000Z</published>
    <updated>2019-08-18T03:52:48.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇博客文章中以易企秀&trade;H5应用作为示例，介绍H5应用使用的基本方法。主要分成两个部分进行学习：基本工具介绍和实际H5例子。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>在<a href="http://www.eqxiu.com" target="_blank" rel="noopener">易企秀官网</a>注册账号。在登录界面可使用已经注册好的账号密码直接登录。也可以选择第三方账号登陆（微信、QQ、微博、钉钉、企业微信），第一次登录时会验证手机号，通过手机号验证之后即可完成注册，第二次及以后可直接登录。也可以直接在注册账号界面注册，登录账号。<br><img src="/2019/08/17/易企秀使用学习教程/img1.webp" alt="易企秀登录界面"></li></ol><h2 id="基本工具介绍"><a href="#基本工具介绍" class="headerlink" title="基本工具介绍"></a>基本工具介绍</h2><ol><li><p>打开H5编辑界面：点击左侧菜单栏”创意模板”，选择空白模板即可进入H5编辑器。<br><img src="/2019/08/17/易企秀使用学习教程/img2.webp" alt="易企秀 创意模板"></p></li><li><p>右侧菜单栏为基本设置菜单栏，包括页面属性、图层管理和页面管理。</p><ul><li><em>页面属性</em>可以设置页面背景、页面音乐、页面滤镜以及翻页设置。<br><img src="/2019/08/17/易企秀使用学习教程/img3.webp" alt="页面属性"></li><li><em>图层管理</em>可以查看当前页面的元素以及可以对元素进行分组等操作。<br><img src="/2019/08/17/易企秀使用学习教程/img4.webp" alt="图层管理"></li><li><em>页面管理</em>可以调整页面顺序，可以删除和添加页面。<br><img src="/2019/08/17/易企秀使用学习教程/img5.webp" alt="页面管理"></li></ul></li><li><p>上侧菜单栏为组件菜单栏，包含文本、图片、背景、音乐、形状、组件、表单和特效。</p><ul><li><em>文本</em>主要是向页面中添加文本，可通过组件设置设置属性。</li><li><em>图片</em>向页面中添加一个图片并设置样式（功能设置、边框、阴影、尺寸和位置等等）、动画（给图片添加动画效果）和触发（设置触发功能）属性。</li><li><em>背景</em>可直接设置页面背景。</li><li><em>音乐</em>可直接设置页面背景音乐。</li><li><em>形状</em>可直接在页面中插入形状。</li><li><em>组件</em>在页面中插入如视频、外链视频等等。</li><li><em>表单</em>可向页面中插入表单。</li><li><em>特效</em>向页面中插入特效。<br><img src="/2019/08/17/易企秀使用学习教程/img6.webp" alt="组件菜单"></li></ul></li><li><p>左侧菜单栏为模板菜单，包含元素模板、功能模板和单页模板。</p><ul><li><em>元素模板</em>。编辑器中的元素模板主要包括了文本（标题以及正文部分文字）、艺术字、图片和图文4个部分。所有的元素模板都可以通过<strong>单击</strong>即可添加页面中，选中元素之后即可使用鼠标拖动调整到合适的位置。右边是模板设置，可以对选中的元素模板的属性进行设置，比如说设置文本内容、字体大小，颜色、图片、边框等等。<br><img src="/2019/08/17/易企秀使用学习教程/img7.webp" alt="元素模板 模板设置"></li><li><em>功能模板</em>。主要是使用整个页面完成一些如分享二维码，收集一些报名信息等功能。操作方法与元素模板类似，可以在模板设置中完成相应的设置。<br><img src="/2019/08/17/易企秀使用学习教程/img8.webp" alt="功能模板 模板设置"></li><li><em>单页模板</em>。主要是一些比较好的单页模板，如节日单页模板等等，选中模板中的元素可以对其进行修改。<br><img src="/2019/08/17/易企秀使用学习教程/img9.webp" alt="功能模板 模板设置"></li></ul></li><li><p>预览和设置<br>点击右上角的预览和设置，可以预览到实际效果。在该界面可以设置应用的标题、描述以及其他的设置。<br><img src="/2019/08/17/易企秀使用学习教程/img10.webp" alt="预览和设置"></p></li><li><p>保存和发布<br> 点击右上角的保存，再点击发布即可发布应用。可以通过二维码扫描、网页链接、也可以直接分享到微博、QQ和QQ空间。<br> <img src="/2019/08/17/易企秀使用学习教程/img11.webp" alt="发布"></p></li></ol><h2 id="实际应用例子"><a href="#实际应用例子" class="headerlink" title="实际应用例子"></a>实际应用例子</h2><p>链接地址:<a href="https://a.eqxiu.com/s/13ggMHc7" target="_blank" rel="noopener">https://a.eqxiu.com/s/13ggMHc7</a><br>链接二维码:<br><img src="/2019/08/17/易企秀使用学习教程/img12.webp" alt="易企秀示例应用"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote><p>易企秀官方帮助文档:<a href="http://www.eqxiu.com/c/help.html" target="_blank" rel="noopener">易企秀官方帮助文档</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本篇博客文章中以易企秀&amp;trade;H5应用作为示例，介绍H5应用使用的基本方法。主要分成两个部分进行学习：基本工具介绍和实际H5例子。&lt;
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="易企秀" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%98%93%E4%BC%81%E7%A7%80/"/>
    
    
      <category term="教程" scheme="http://qzt8315.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="H5" scheme="http://qzt8315.github.io/tags/H5/"/>
    
      <category term="易企秀" scheme="http://qzt8315.github.io/tags/%E6%98%93%E4%BC%81%E7%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>西瓜书_第三章</title>
    <link href="http://qzt8315.github.io/2019/07/29/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://qzt8315.github.io/2019/07/29/西瓜书-第三章/</id>
    <published>2019-07-29T06:43:42.000Z</published>
    <updated>2019-08-27T08:18:01.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本章中详细讲解了线性模型，包括线性回归、对数几率回归等等。线性模型形式简单、易于建模，但是蕴含着机器学习中的一些重要的基本思想，并且许多重要的非线性模型也可以在线性模型的基础上引入层级结构或者高维映射得到。此外，线性模型还具有可解释性(comprehensibility,也称为可理解性understandability)。</p><p>基本形式：给定示例x=(x<sub>1</sub>;x<sub>2</sub>;…;x<sub>d</sub>)，x<sub>i</sub>表示x的第i个属性，线性模型即通过各个属性的线性组合进行预测函数：<br>$$<br>f(x)=w_1x_1+w_2x_2+…+w_dx_d+b<br>$$</p><p>向量形式：<br>$$<br>f(x)=\boldsymbol{w}^T\boldsymbol{x}+b\\<br>\boldsymbol{w}=(w_1;w_2;..;w_d)<br>$$</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>给定数据集$D={(x_1,y_1),(x_2,y_2),…,(x_m,y_m)}$，其中$x_i=(x_{i1};x_{i2};….;x_{id}),y_i\in{\mathbb{R}}$，线性代数试图学得:<br>$$<br>f(x_i)=wx_i+b\quad 使得f(x_i)\simeq y_i<br>$$</p><p>求解该模型需要解得$w$和$b$，需要衡量$y_i$和$f(x_i)$之间的差距，一般采用均方误差（又称为平方损失(square loss)）：<br>$$<br>(w^*,b^*)=\mathop{\arg\min}\limits_{(w,b)}\sum_{i=1}^{m}(f(x_i)-y_i)^2\\<br>=\mathop{\arg\min}\limits_{(w,b)}\sum_{i=1}^{m}(y_i-wx_i-b)^2<br>$$</p><p>均方误差具有较好的几何意义，对应常用的欧几里得距离（欧氏距离）。基于均方误差最小化进行模型求解的方法称为最小二乘法（least square method）。求解$w$和$b$使得$E_{(w,b)}=\sum_{i=1}^{m}(y_i-wx_i+b)^2$最小化的过程称为线性回归模型的最小二乘“参数估计”。线性回归模型求解过程如下：</p><ol><li>对$E_{(w,b)}$分别对$w$和$b$求偏导<br>$$<br>\frac{\partial E_{(w,b)}}{\partial w} = 2(w\sum_{i=1}^mx_i^2-\sum_{i=1}^m(y_i-b)x_i),\\<br>\frac{\partial E_{(w,b)}}{\partial w} = 2(mb-\sum_{i=1}^m(y_i-wx_i)),<br>$$</li><li>令偏导值为零可求解出$w$和$b$最优解的闭式解:<br>$$<br>w = \frac{\sum\limits_{i=1}^my_i(x_i-\overline{x})}{\sum\limits_{i=1}^mx_i^2-\frac{1}{m}(\sum\limits_{i=1}^mx_i)^2}\\<br>b = \frac{1}{m}\sum\limits_{i=1}^m(y_i-wx_i),\\<br>其中\overline x=\frac{1}{m}\sum\limits_{i=1}^mx_i<br>$$</li></ol><p>针对更一般的数据集情况，每个样本由$d$个属性组成，则为多元线性回归（又称为多变量线性回归）：<br>$$<br>f(\boldsymbol{x}_i)=\boldsymbol{w}^T\boldsymbol{x}_i+b\quad使得f(\boldsymbol{x}_i)\simeq{y}_i<br>$$<br>便于表达，将$w$和$b$吸收进向量形式$\hat{w}=(w;b)$，相应的需要将数据集表示为m×(d+1)大小的矩阵$\boldsymbol{X}$<br>$$<br>\boldsymbol{X}=\begin{pmatrix}<br>x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1d} &amp; 1 \\<br>x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2d} &amp; 1 \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\<br>x_{m1} &amp; x_{m2} &amp; \ldots &amp; x_{md} &amp; 1 \\<br>\end{pmatrix}<br>$$</p><p>同时将标记写为向量形式$\boldsymbol{y}=(y_1;y_2;\ldots;y_m)$则最佳的$w$为：<br>$$<br>\hat{w}^*=\arg\min\limits_{\hat w}(\boldsymbol{y}-\boldsymbol{X}\hat{w})^T(\boldsymbol{y}-\boldsymbol{X}\hat{wz})<br>$$</p><p>令$E_{\hat{w}}=(\boldsymbol{y}-\boldsymbol{X}\hat{w})^T(\boldsymbol{y}-\boldsymbol{X}\hat{w})$，对$\hat{w}$求导得:<br>$$<br>\frac{\partial E_{\hat{w}}}{\partial\hat{w}}=2\boldsymbol{X}^T{\boldsymbol{X}\hat{w}-y}<br>$$<br>当$\boldsymbol{X}^T\boldsymbol{X}$为满秩矩阵或者正定矩阵，令$\hat{w}$偏导值为零可得：<br>$$<br>\hat{w}^*=(\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T\boldsymbol{y}<br>$$</p><p>其中$(\boldsymbol{X}^T\boldsymbol{X})^{-1}$为$(\boldsymbol{X}^T\boldsymbol{X})$的逆矩阵。令$\hat{x_i}=(x_i;1)$最终学得多元线性回归模型：<br>$$<br>f(\hat{\boldsymbol{x}}_i)=(\boldsymbol X^T\boldsymbol X)^{-1}\boldsymbol X^T\boldsymbol y<br>$$</p><p>然而，$\boldsymbol {X}^T\boldsymbol{X}$往往不是满秩矩阵，例如在许多任务中，样本的变量数目大于样本数，会导致$\boldsymbol{X}$的列数大于行数，$\boldsymbol{X}^T\boldsymbol{X}$显然不是满秩矩阵可以解出多个$\hat{\boldsymbol{w}}$，这时需要对解有所偏好决定，常见的解决方法是引入正则化方法。</p><h2 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h2><p>线性判别分析（Linear Discriminant Analysis，LDA）给定训练样例集，设法将样例投影到一条直线上，使得同类的样例的投影点尽可能接近、异类样例的投影点尽可能远离。算法如下图所示：<br><img src="/2019/07/29/西瓜书-第三章/img1.webp" alt="LDA算法作用"><br>要实现算法，就需要使得类内的协方差尽可能小，类间距离尽可能大。<br>假设数据集为$D=\{(\boldsymbol{x}_i,y_i)\}^m_{i=1},y_i\in\{0,1\}$,令$\boldsymbol X_i、\boldsymbol{\mu}_i、\boldsymbol{\Sigma}_i$分别表示第$i\in\{0,1\}$类示例的集合、均值向量和协方差矩阵。<br>类间最大化目标为:<br>$$<br>\begin{align}<br>J &amp;= \frac{\Vert \boldsymbol{\omega^T\mu_0-\omega^T\mu_1} \Vert^2_2}{\boldsymbol{\omega^T\Sigma_0\omega}+\boldsymbol{\omega^T\Sigma_1\omega}}\\<br>&amp;= \frac{\boldsymbol{\omega^T(\mu_0-\mu_1)(\mu_0-\mu_1)^T\omega}}{\boldsymbol{\omega^T(\Sigma_0+\Sigma_1)\omega}}<br>\end{align}<br>$$</p><p>假定类内散度矩阵为：</p><p>$$<br>\begin{align}<br>\boldsymbol S_\omega &amp;=\boldsymbol{\Sigma_0+\Sigma_1}\\<br>&amp;=\sum_{\boldsymbol x\in\boldsymbol X_0}\boldsymbol{(x-\mu_0){x-\mu_0}^T+\sum_{\boldsymbol x\in\boldsymbol X_1}\boldsymbol{(x-\mu_1)(x-\mu_1)^T}}<br>\end{align}<br>$$<br>类间散度矩阵为：<br>$$<br>\boldsymbol S_b=\boldsymbol{(\mu_0-\mu_1)(\mu_0-\mu_1)^T}<br>$$<br>可将$\boldsymbol J$重写为：<br>$$<br>\boldsymbol J=\boldsymbol{\frac{\omega^TS_b\omega}{\omega^TS_\omega\omega}}<br>$$<br>因为分子分母都有$\boldsymbol\omega$，因此$\boldsymbol J$的解只与$\boldsymbol\omega$的方向有关，与长度无关。可令$\boldsymbol{\frac{\omega^TS_b\omega}{\omega^TS_\omega\omega}}=1$<br>等价于：<br>$$<br>\begin{align}<br>&amp; \min\limits_{\boldsymbol\omega}\ -\boldsymbol{\omega^TS_b\omega}\\<br>&amp; \boldsymbol{s.t.}\ \boldsymbol{\omega^TS_\omega\omega}=1<br>\end{align}<br>$$<br>由拉格朗日乘子法，等价于:<br>$$<br>\boldsymbol{S_b\omega}=\lambda\boldsymbol{S_\omega\omega}<br>$$<br>其中λ拉格朗日乘子，$\boldsymbol{S_b\omega}$方向恒为$\mu_0-\mu_1$，令：<br>$$<br>\boldsymbol{S_b\omega}=\lambda(\mu_0-\mu_1)<br>$$<br>可得:<br>$$<br>\boldsymbol \omega=\boldsymbol{S_\omega^{-1}(\mu_0-\mu_1)}<br>$$<br>为了确保解值的稳定性，在实践中对$\boldsymbol{S_\omega}$进行奇异值分解，即$\boldsymbol{S_\omega}=\boldsymbol U\Sigma\boldsymbol V^T$,$\Sigma$为实对角矩阵对角线上的元素为$\boldsymbol S_\omega$的奇异值，再由$\boldsymbol S^{-1}_\omega=\boldsymbol{V\Sigma^{-1}U^{T}}$得到$\boldsymbol S^{-1}_\omega$得到$\boldsymbol S_\omega$。</p><p>也可以将LDA扩展到多分类任务中。<br>全局散度矩阵:<br>$$<br>\begin{align}<br>\boldsymbol S_t&amp;=\boldsymbol S_b+\boldsymbol S_\omega\\<br>&amp;=\sum^m_{i=1}(\boldsymbol{x_i-\mu})(\boldsymbol{x_i-\mu})^T<br>\end{align}<br>$$<br>其中$\boldsymbol\mu$是所有示例的均值向量，将类内散度矩阵$\boldsymbol S_\omega$重定义为每个类别的散度矩阵之和，即:<br>$$<br>\boldsymbol S_\omega=\sum^N_{i=1}\boldsymbol S_{\omega_i}<br>$$<br>其中$\boldsymbol S_{\omega_i}$为：<br>$$<br>\boldsymbol S_{\omega_i}=\sum_{\boldsymbol x\in X_i}(\boldsymbol x-\boldsymbol\mu_i)(\boldsymbol x-\boldsymbol\mu_i)^T<br>$$<br>可得：<br>$$<br>\begin{align}<br>\boldsymbol S_b&amp;=\boldsymbol S_t-\boldsymbol S_\omega\\<br>&amp;=\sum^N_{i=1}m_i(\boldsymbol\mu_i-\boldsymbol\mu)(\boldsymbol\mu_i-\boldsymbol\mu)^T<br>\end{align}<br>$$<br>多分类LDA可以使用多种实现方法，使用$\boldsymbol S_b,\boldsymbol S_\omega,\boldsymbol S_t$中的两个即可。常见的一种实现是采用优化目标：<br>$$<br>\max_{\boldsymbol W}\frac{tr(\boldsymbol W^T\boldsymbol S_b\boldsymbol W)}{tr(\boldsymbol W^T\boldsymbol S_\omega\boldsymbol W)}<br>$$<br>其中$\boldsymbol W\in\mathbb R^{dx(N-1)}$,tr(·)表示矩阵的迹，可通过$\boldsymbol S_b\boldsymbol W=\lambda\boldsymbol S_\omega\boldsymbol W$求解。</p><h2 id="多分类学习"><a href="#多分类学习" class="headerlink" title="多分类学习"></a>多分类学习</h2><p>拆解法：将多分类任务拆分为若干个二分类任务求解。</p><p>拆分策略：</p><ol><li>One Vs. One,将N类两两组合，使用N(N-1)/2个分类器，投票得出结果</li><li>One Vs. Rest,将N类分为N个1类和（N-1）类分类器分类，根据预测置信进行最终结果判断。</li><li>Many Vs. Many，正类和反类需要特殊设计，OVO和OVR都是MVM的特殊例子。最常用的是ECOC(Error Correcting Output Codes,纠错输出码)</li></ol><h3 id="ECOC算法过程"><a href="#ECOC算法过程" class="headerlink" title="ECOC算法过程"></a>ECOC算法过程</h3><p>ECOC过程分为两步：编码和解码。</p><h4 id="ECOC编码"><a href="#ECOC编码" class="headerlink" title="ECOC编码"></a>ECOC编码</h4><p>对N类进行M次划分，将一部分划为正类，一部分划分为反类，共产生M个数据集，可训练M个二分类器</p><h4 id="ECOC解码"><a href="#ECOC解码" class="headerlink" title="ECOC解码"></a>ECOC解码</h4><p>M个分类器对样本进行预测，这些预测的标记组成一个编码，将这个编码于各自的编码进行比较，返回其中距离最小的类作为最终的预测结果。</p><h4 id="ECOC编码的优点"><a href="#ECOC编码的优点" class="headerlink" title="ECOC编码的优点"></a>ECOC编码的优点</h4><p>ECOC具有一定的容错能力。</p><h3 id="类别不平衡"><a href="#类别不平衡" class="headerlink" title="类别不平衡"></a>类别不平衡</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>类别不平衡（class-imbalance):在分类任务中，不同的类别训练样例数目差别较大的情况。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在二分类中常使用$y=\omega^Tx+b$，常使用y&gt;0.5判断为正例，y&lt;0.5判断为反例，因此决策的规则为$\frac{y}{1-y}&gt;1$时为正例。当正反例数不同时，m<sup>+</sup>表示正例数，m<sup>-</sup>表示反例数，观测几率为$\frac{m^+}{m^-}$因此可以将判断规则调整为$\frac{y}{1-y}&gt;\frac{m^+}{m^-}$为正例。通过“再缩放”调整类间不平衡，$\frac{y’}{1-y’}=\frac{y}{1-y}×\frac{m^-}{m^+}$。</p><p>“再缩放”前提在于无偏采样，但是在实际情概况中是不成立的，因此需采取其他方法：</p><ol><li>对反例进行欠采样(undersampling),欠采样若是简单丢弃样本，可能会丢失一些重要的信息。代表算法：Easy-Ensemble:利用集成学习机制，将反例划分成若干不同的集合共学习器使用。</li><li>对正例进行过采样（upsampling），欠采样不能简单的重复采样，会导致严重的过拟合，应该采用相应的算法：代表SMOTE，在正例中插值产生额外正例。</li><li>使用再缩放的方法，”阈值移动“，同时也是代价敏感学习。</li></ol><p>Many Vs. Many 也可以通过DAG(Direct Acyclic Graph)折分法，将分类划分成树状结构，每个节点对应一个分类器。</p><h4 id="无偏采样"><a href="#无偏采样" class="headerlink" title="无偏采样"></a>无偏采样</h4><p>真实样本中的类别比例在训练集中得以保持。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》作者：周志华</a>；</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本章中详细讲解了线性模型，包括线性回归、对数几率回归等等。线性模型形式简单、易于建模，但是蕴含着机器学习中的一些重要的基本思想，并且许多重
      
    
    </summary>
    
      <category term="读书" scheme="http://qzt8315.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="西瓜书" scheme="http://qzt8315.github.io/categories/%E8%AF%BB%E4%B9%A6/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    
      <category term="西瓜书" scheme="http://qzt8315.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
      <category term="读书" scheme="http://qzt8315.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="第三章" scheme="http://qzt8315.github.io/tags/%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>成年人看的动漫-《哪吒之魔童降世》</title>
    <link href="http://qzt8315.github.io/2019/07/29/%E6%88%90%E5%B9%B4%E4%BA%BA%E7%9C%8B%E7%9A%84%E5%8A%A8%E6%BC%AB-%E3%80%8A%E5%93%AA%E5%90%92%E4%B9%8B%E9%AD%94%E7%AB%A5%E9%99%8D%E4%B8%96%E3%80%8B/"/>
    <id>http://qzt8315.github.io/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/</id>
    <published>2019-07-29T03:27:23.000Z</published>
    <updated>2019-07-30T04:22:45.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img1.webp" alt></p><p>昨天打卡了国产动漫–《哪吒之魔童降世》，不愧是国产动漫的良心之作，从剧情到布景，从配乐到人物，可以处处看出制作公司的用心。</p><hr><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>从剧情上来说，既有继承部分，也有创新部分。剧情依托于古代神话传说人物，开始部分补充了哪吒出生前的细节–来源于混元珠的魔丸，同时为故事主体高潮部分埋下伏笔，必会与有同样出生的混元珠的灵珠敖丙有一段纠葛。到高潮部分，命中注定的天劫咒来临，哪吒与敖丙不再是相互厮杀，而是创新的将其设计为携手合作共同度过这一难关。至此，哪吒也完成了人物的转变。总的来说，剧情跌宕起伏，结构完整紧凑，在国产动画中属于佳作。</p><h2 id="布景"><a href="#布景" class="headerlink" title="布景"></a>布景</h2><p>整部动画的布景完整。尤其是在山河社稷图中景色优美精致，体现了国内漫画制作的最高水平，电影院(小厅，非IMAX)第一排的位置能深深体会到3D动画的震撼，尤其配合气味散发器，可以闻到荷花的芬芳、青草的清香、美酒的醇香，让人身临其境。<br><img src="/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img2.webp" alt="山河社稷图剧照（图片来源：&lt;a href=&quot;https://img3.doubanio.com/view/photo/l/public/p2563537631.webp&quot; target=&quot;_blank&quot;&gt;豆瓣电影&lt;/a&gt;)"></p><h2 id="配乐"><a href="#配乐" class="headerlink" title="配乐"></a>配乐</h2><p>配乐部分，主题曲可以说是优秀的。无论是从歌词和配乐方面都是较好的，在电影中播放出来极具感染力，毫无违和感。以下为主题曲原音乐(来源：网易云音乐)。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1378085345&auto=0&height=66"></iframe><h2 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h2><p>人物设计上，最丑的哪吒与最帅的哪吒一体。一出场应该是主角的哪吒却给了一副魔王的外表，总给人一种失落的感觉，但是当看到哪吒的真正的面目的时候，才知道这也是最帅的哪吒。人物的性格设计上，主要角色性格丰满，哪吒自带魔属性，内心渴望被人认可，但是频频被认为是妖怪之后便破罐子破摔；李靖是一个爱子的父亲角色，希望能让虽出身魔丸的哪吒能走上斩妖除魔的正途，甚至不惜牺牲自己也要帮助哪吒度过天劫咒的完美父亲形象。<br><img src="/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img3.webp" alt="最丑哪吒(图片来源：&lt;a href=&quot;https://img3.doubanio.com/view/photo/l/public/p2545645815.webp&quot; target=&quot;_blank&quot;&gt;豆瓣电影&lt;/a&gt;)"><br><img src="/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img4.webp" alt="最帅哪吒(图片来源:(图片来源：&lt;a href=&quot;https://img3.doubanio.com/view/photo/l/public/p2563815623.webp&quot;  target=&quot;_blank&quot;&gt;豆瓣电影&lt;/a&gt;)"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：这是一部成年人的动漫，宣扬着“我命由己不由天”的正面思想，鼓励当代青年，不论出身如何，命运都是由自己掌控的努力奋斗的精神。同时也给国漫带来了一剂强心针，相对《大圣归来》，《哪吒》引入了中国家的概念，刻画了中国家长的形象，并在影片结束时预告了《姜子牙》等一系列封神榜作品，有成为和漫威齐名的封神榜的期望。最后最后，希望国漫越来越好，制作出和国外优质电影相当的动画。</p><p>剧中一首打油诗:<br>“<em>我是小妖怪 逍遥又自在<br>杀人不眨眼 吃人不放盐<br>一口七八个 肚子要撑破<br>茅房去拉屎 想起忘带纸</em>”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/07/29/成年人看的动漫-《哪吒之魔童降世》/img1.webp&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;昨天打卡了国产
      
    
    </summary>
    
      <category term="生活" scheme="http://qzt8315.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="观影" scheme="http://qzt8315.github.io/categories/%E7%94%9F%E6%B4%BB/%E8%A7%82%E5%BD%B1/"/>
    
    
      <category term="观影" scheme="http://qzt8315.github.io/tags/%E8%A7%82%E5%BD%B1/"/>
    
      <category term="动漫" scheme="http://qzt8315.github.io/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的一些插件</title>
    <link href="http://qzt8315.github.io/2019/07/25/Hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/"/>
    <id>http://qzt8315.github.io/2019/07/25/Hexo的一些插件/</id>
    <published>2019-07-25T11:46:36.000Z</published>
    <updated>2019-07-25T16:26:45.149Z</updated>
    
    <content type="html"><![CDATA[<p>在Hexo中,我们可以方便的写出我们的博客并生成网站，但是一些其他的功能需要使用Hexo的插件。</p><h2 id="Hexo中常用的一些插件"><a href="#Hexo中常用的一些插件" class="headerlink" title="Hexo中常用的一些插件"></a>Hexo中常用的一些插件</h2><ol><li><p>Hexo的Git发布插件(hexo-deployer-git)<br> 1.1. 在博客文件夹根目录下(之后使用Git Bash都默认在此路径下)打开Git Bash执行指令<code>npm install hexo-deployer-git --save</code>安装自动部署插件<br> 1.2. 修改博客文件夹下博客的配置文件，完成配置之后使用<code>hexo deploy</code>或者<code>hexo d</code>发布内容到Git。</p><pre><code> # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy:     type: git     repository: git代码仓库地址     branch: master</code></pre></li><li><p>Hexo的MathJax渲染插件(hexo-math)<br>2.1. Git Bash执行<code>npm install hexo-math --save</code><br>2.2. 设置主题配置文件</p><pre><code># MathJax 数学公式支持mathjax:   on: true #是否启用   per_page: false # 若只渲染单个页面，此选项设为false，页面内加入 mathjax: true</code></pre></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://yelog.org/2017/07/05/3-hexo-mathjax/" target="_blank" rel="noopener">MathJax配置</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Hexo中,我们可以方便的写出我们的博客并生成网站，但是一些其他的功能需要使用Hexo的插件。&lt;/p&gt;
&lt;h2 id=&quot;Hexo中常用的一些插件&quot;&gt;&lt;a href=&quot;#Hexo中常用的一些插件&quot; class=&quot;headerlink&quot; title=&quot;Hexo中常用的一些插件
      
    
    </summary>
    
      <category term="学习" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="hexo" scheme="http://qzt8315.github.io/categories/%E5%AD%A6%E4%B9%A0/hexo/"/>
    
    
      <category term="教程" scheme="http://qzt8315.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="博客" scheme="http://qzt8315.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://qzt8315.github.io/tags/hexo/"/>
    
      <category term="新手" scheme="http://qzt8315.github.io/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
</feed>
